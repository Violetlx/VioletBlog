<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SaToken鉴权框架</title>
      <link href="/posts/fe850976.html"/>
      <url>/posts/fe850976.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/load.gif" data-original="https://sa-token.cc/logo.png" alt="logo"></p><h1 id="Sa-Token-介绍"><a href="#Sa-Token-介绍" class="headerlink" title="Sa-Token 介绍"></a>Sa-Token 介绍</h1><p>Sa-Token 是一个轻量级 Java 权限认证框架，主要解决：<strong>登录认证</strong>、<strong>权限认证</strong>、<strong>单点登录</strong>、<strong>OAuth2.0</strong>、<strong>分布式 Session 会话</strong>、<strong>微服务网关鉴权</strong>等一系列权限相关问题。</p><p>Sa-Token 旨在以简单、优雅的方式完成系统的权限认证部分，以登录认证为例，你只需要：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会话登录，参数填登录人的账号id </span></span><br><span class="line">StpUtil.login(<span class="number">10001</span>);</span><br></pre></td></tr></table></figure><p>无需实现任何接口，无需创建任何配置文件，只需要这一句静态代码的调用，便可以完成会话登录认证。</p><p>如果一个接口需要登陆后才能访问，我们只需要调用以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 校验当前客户端是否已经登录，如果未登录则抛出 `NotLoginException` 异常</span></span><br><span class="line">StpUtil.checkLogin();</span><br></pre></td></tr></table></figure><p>在 Sa-Token 中，大多数功能都可以一行代码解决：</p><p>踢人下线：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将账号id为 10077 的会话踢下线 </span></span><br><span class="line">StpUtil.kickout(<span class="number">10077</span>);</span><br></pre></td></tr></table></figure><p>权限认证：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注解鉴权：只有具备 `user:add` 权限的会话才可以进入方法</span></span><br><span class="line"><span class="meta">@SaCheckPermission(&quot;user:add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">insert</span><span class="params">(SysUser user)</span> &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;用户增加&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由拦截鉴权：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据路由划分模块，不同模块不同鉴权 </span></span><br><span class="line">registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">SaInterceptor</span>(handler -&gt; &#123;</span><br><span class="line">    SaRouter.match(<span class="string">&quot;/user/**&quot;</span>, r -&gt; StpUtil.checkPermission(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">    SaRouter.match(<span class="string">&quot;/admin/**&quot;</span>, r -&gt; StpUtil.checkPermission(<span class="string">&quot;admin&quot;</span>));</span><br><span class="line">    SaRouter.match(<span class="string">&quot;/goods/**&quot;</span>, r -&gt; StpUtil.checkPermission(<span class="string">&quot;goods&quot;</span>));</span><br><span class="line">    SaRouter.match(<span class="string">&quot;/orders/**&quot;</span>, r -&gt; StpUtil.checkPermission(<span class="string">&quot;orders&quot;</span>));</span><br><span class="line">    SaRouter.match(<span class="string">&quot;/notice/**&quot;</span>, r -&gt; StpUtil.checkPermission(<span class="string">&quot;notice&quot;</span>));</span><br><span class="line">    <span class="comment">// 更多模块... </span></span><br><span class="line">&#125;)).addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br></pre></td></tr></table></figure><p>当你受够了 Shiro、SpringSecurity 等框架的三拜九叩之后，你就会明白，相对于这些传统老牌框架，Sa-Token 的 API 设计是多么的简单、优雅！</p><h2 id="Sa-Token-功能预览"><a href="#Sa-Token-功能预览" class="headerlink" title="Sa-Token 功能预览"></a>Sa-Token 功能预览</h2><p>Sa-Token 目前主要五大功能模块：登录认证、权限认证、单点登录、OAuth2.0、微服务鉴权。</p><ul><li><strong>登录认证</strong> —— 单端登录、多端登录、同端互斥登录、七天免登录。</li><li><strong>权限认证</strong> —— 权限认证、角色认证、会话二级认证。</li><li><strong>踢人下线</strong> —— 根据账号 id 踢人下线、根据 Token 值踢人下线。</li><li><strong>注解式鉴权</strong> —— 优雅的将鉴权与业务代码分离。</li><li><strong>路由拦截式鉴权</strong> —— 根据项目路由拦截鉴权，可适配 restful 模式。</li><li><strong>Session 会话</strong> —— 全端共享 Session ，单端独享 Session，自定义 Session ，方便的存取值。</li><li><strong>持久层扩展</strong> —— 可集成 Redis ，重启数据不丢失。</li><li><strong>前后台分离</strong> —— APP 、小程序等不支持 Cookie 的终端也可以轻松鉴权。</li><li><strong>Token 风格定制</strong> —— 内置流中 Token 风格，还可：自定义 Token 生成策略。</li><li><strong>记住我模式</strong> —— 适配 [记住我] 模式，重启浏览器免验证。</li><li><strong>二级认证</strong> —— 在已登录的基础上再次认证，保证安全性。</li><li><strong>模拟他人账号</strong> —— 实时操作任意用户状态数据。</li><li><strong>临时身份切换</strong> —— 将会话身份临时切换为其他账号。</li><li><strong>同端互斥登录</strong> —— 像 QQ 一样手机电脑同时在线，但是两个手机上互斥登录。</li><li><strong>账号封禁</strong> —— 登录封禁、按照业务分类封禁、按照处罚阶梯封禁。</li><li><strong>密码加密</strong> —— 提供基础加密算法，可快速 MD5、SHA1、SHA256、AES 加密。</li><li><strong>会话查询</strong> —— 提供方便灵活的会话查询接口。</li><li><strong>Http Basic 认证</strong> —— 一行代码接入 Http Basic 、Digest 认证。</li><li><strong>全局侦听器</strong> —— 在用户登录、注销、被踢下线等关键性操作时进行一些 AOP 操作。</li><li><strong>全局过滤器</strong> —— 方便的处理跨域，全局设置安全响应头等操作。</li><li><strong>多账号体系认证</strong> —— 一个系统多套账号分开鉴权（比如商城的 User 表和 Admin 表）。</li><li><strong>单点登录</strong> —— 内置三种单点登录模式：同城、跨域、同 Redis、跨 Redis、前后端分离等架构都可以搞定。</li><li><strong>单点注销</strong> —— 任意子系统内发起注销，即可全端下线。</li><li><strong>OAuth2.0 认证</strong> —— 轻松搭建 OAuth2.0 服务，支持 openid 模式。</li><li><strong>分布式会话</strong> —— 提供共享数据中心分布式会话方案。</li><li><strong>微服务网关鉴权</strong> —— 适配 Gateway 、ShenYu 、Zuul 等常见网关的路由拦截认证。</li><li><strong>RPC 调用鉴权</strong> —— 网关转发鉴权，RPC 调用鉴权，让服务调用不再裸奔。</li><li><strong>临时 Token 认证</strong> —— 解决短时间的 Token 授权问题。</li><li><strong>独立 Redis</strong> —— 将权限缓存与业务缓存分离。</li><li><strong>Quick 快速登录认证</strong> —— 为项目零代码注入一个登录页面。</li><li><strong>标签方言</strong> —— 提供 Thymeleaf 标签方言集成包，提供 beetl 集成示例。</li><li><strong>jwt 集成</strong> —— 提供三种模式的 jwt 集成方案，提供 token 扩展参数能力。</li><li><strong>RPC 调用状态传递</strong> —— 提供 dubbo 、grpc 等集成包，在 RPC 调用时登陆状态不丢失。</li><li><strong>参数签名</strong> —— 提供跨系统 API 调用签名校验模块，防止参数篡改，防止请求重放。</li><li><strong>自动续签</strong> —— 提供两种 Token 过期策略，灵活搭配使用，还可以自动续签。</li><li><strong>开箱即用</strong> —— 提供 SpringMVC 、WebFlus 、Solon 等常见框架集成包，开箱即用。</li><li><strong>最新技术栈</strong> —— 适配最新技术栈：支持 SpringBoot 3.x ，jdk 17 。</li></ul><p>功能结构图：</p><p><img src="/img/load.gif" data-original="https://color-test.oss-cn-qingdao.aliyuncs.com/sa-token/x/sa-token-js4.png" alt="sa-token-js"></p><hr><h1 id="在-SpringBoot-中集成"><a href="#在-SpringBoot-中集成" class="headerlink" title="在 SpringBoot 中集成"></a>在 SpringBoot 中集成</h1><h2 id="1、创建项目"><a href="#1、创建项目" class="headerlink" title="1、创建项目"></a>1、创建项目</h2><p>在 IDE 中新建一个 SpringBoot 项目，例如 <code>sa-token-demo-springboot</code></p><h2 id="2、添加依赖"><a href="#2、添加依赖" class="headerlink" title="2、添加依赖"></a>2、添加依赖</h2><p>在项目中添加依赖：</p><p>Maven 方式</p><p>注：如果你使用的是 SpringBoot 3.x，只需要将 <code>sa-token-spring-boot-starter</code> 修改为 <code>sa-token-spring-boot3-starter</code> 即可。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Sa-Token 权限认证，在线文档：https://sa-token.cc --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.dev33<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sa-token-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.39.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、设置配置文件"><a href="#3、设置配置文件" class="headerlink" title="3、设置配置文件"></a>3、设置配置文件</h2><p>你可以<strong>零配置启动项目</strong> ，但同时你也可以在 <code>application.yml</code> 中增加如下配置，定制性使用框架：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="comment"># 端口</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">############## Sa-Token 配置 (文档: https://sa-token.cc) ##############</span></span><br><span class="line"><span class="attr">sa-token:</span> </span><br><span class="line">    <span class="comment"># token 名称（同时也是 cookie 名称）</span></span><br><span class="line">    <span class="attr">token-name:</span> <span class="string">satoken</span></span><br><span class="line">    <span class="comment"># token 有效期（单位：秒） 默认30天，-1 代表永久有效</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">2592000</span></span><br><span class="line">    <span class="comment"># token 最低活跃频率（单位：秒），如果 token 超过此时间没有访问系统就会被冻结，默认-1 代表不限制，永不冻结</span></span><br><span class="line">    <span class="attr">active-timeout:</span> <span class="number">-1</span></span><br><span class="line">    <span class="comment"># 是否允许同一账号多地同时登录 （为 true 时允许一起登录, 为 false 时新登录挤掉旧登录）</span></span><br><span class="line">    <span class="attr">is-concurrent:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 在多人登录同一账号时，是否共用一个 token （为 true 时所有登录共用一个 token, 为 false 时每次登录新建一个 token）</span></span><br><span class="line">    <span class="attr">is-share:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># token 风格（默认可取值：uuid、simple-uuid、random-32、random-64、random-128、tik）</span></span><br><span class="line">    <span class="attr">token-style:</span> <span class="string">uuid</span></span><br><span class="line">    <span class="comment"># 是否输出操作日志 </span></span><br><span class="line">    <span class="attr">is-log:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="4、创建启动类"><a href="#4、创建启动类" class="headerlink" title="4、创建启动类"></a>4、创建启动类</h2><p>在项目中新建包 <code>com.sa.token</code> ，在此包内新建主类 <code>SaTokenDemoApplication.java</code>，复制以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaTokenDemoApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        SpringApplication.run(SaTokenDemoApplication.class, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;启动成功，Sa-Token 配置如下：&quot;</span> + SaManager.getConfig());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5、创建测试-Controller"><a href="#5、创建测试-Controller" class="headerlink" title="5、创建测试 Controller"></a>5、创建测试 Controller</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试登录，浏览器访问： http://localhost:8081/user/doLogin?username=zhang&amp;password=123456</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;doLogin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doLogin</span><span class="params">(String username, String password)</span> &#123;</span><br><span class="line">        <span class="comment">// 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对 </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhang&quot;</span>.equals(username) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(password)) &#123;</span><br><span class="line">            StpUtil.login(<span class="number">10001</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;登录成功&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;登录失败&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询登录状态，浏览器访问： http://localhost:8081/user/isLogin</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;isLogin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">isLogin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;当前会话是否登录：&quot;</span> + StpUtil.isLogin();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6、运行"><a href="#6、运行" class="headerlink" title="6、运行"></a>6、运行</h2><p>启动代码，依次运行上述接口：</p><p><img src="/img/load.gif" data-original="/../../../../../images/frameworks/Java/auth/sa-token/a/v1.png" alt="v1"></p><p><img src="/img/load.gif" data-original="/../../../../../images/frameworks/Java/auth/sa-token/a/v2.png" alt="v2"></p><p><img src="/img/load.gif" data-original="/../../../../../images/frameworks/Java/auth/sa-token/a/v3.png" alt="v3"></p><hr><h1 id="登录认证"><a href="#登录认证" class="headerlink" title="登录认证"></a>登录认证</h1><h2 id="1、设计思路"><a href="#1、设计思路" class="headerlink" title="1、设计思路"></a>1、设计思路</h2><p>对于一些登录之后才能访问的接口（例如：查询我的账号资料），我们通常的做法是增加一层接口校验：</p><ul><li>如果校验通过，则：正常返回数据</li><li>如果校验未通过，则：抛出异常，告知其需要先进性登录。</li></ul><p>那么，判断会话是否登录的依据是什么？我们先来简单分析一下登录访问流程：</p><ol><li>用户提交 <code>name</code> + <code>password</code> 参数，调用登录接口。</li><li>登录成功，返回这个用户的 Token 会话凭证。</li><li>用户后续的每次请求，都携带上这个 Token。</li><li>服务器根据 Token 判断此会话是否登录成功。</li></ol><p>所谓登录认证，指的就是服务器校验账号密码，为用户颁发 Token 会话凭证的过程，这个 Token 也是我们后续判断会话是否登录的关键所在。</p><p><button style="background: #fbca1f; font-family: inherit; padding: 0.6em 1.3em; font-weight: 900; font-size: 18px;border: 3px solid black; border-radius: 0.4em; box-shadow: 0.1em 0.1em; cursor: pointer; transition: transform 0.1s, box-shadow 0.1s;"onclick="window.open('https://oss.dev33.cn/sa-token/doc/g/g3--login-auth.gif', '_blank');"onmouseover="this.style.transform='translate(-0.05em, -0.05em)'; this.style.boxShadow='0.15em 0.15em';"onmouseout="this.style.transform=''; this.style.boxShadow='0.1em 0.1em';"onmousedown="this.style.transform='translate(0.05em, 0.05em)'; this.style.boxShadow='0.05em 0.05em';"onmouseup="this.style.transform=''; this.style.boxShadow='0.1em 0.1em';"><br>加载动态演示图<br></button></p><h2 id="2、登录与注销"><a href="#2、登录与注销" class="headerlink" title="2、登录与注销"></a>2、登录与注销</h2><p>根据以上思路，我们需要一个会话登录的函数：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会话登录：参数填写要登录的账号id，建议的数据类型：long | int | String， 不可以传入复杂类型，如：User、Admin 等等</span></span><br><span class="line">StpUtil.login(Object id);     </span><br></pre></td></tr></table></figure><p>只此一句代码，便可以使会话登录成功，实际上，Sa-Token 在背后做了大量的工作，包括但不限于：</p><ol><li>检查此账号是否之前已有登录；</li><li>为账号生成 <code>Token</code> 凭证与 <code>Session</code> 会话；</li><li>记录 Token 活跃时间；</li><li>通知全局侦听器，xx 账号登录成功；</li><li>将 <code>Token</code> 注入到请求上下问；</li></ol><p>你暂时不需要完整了解整个登录过程，你只需要记住关键一点：<code>Sa-Token 为这个账号创建了一个Token凭证，且通过 Cookie 上下文返回给了前端</code>。</p><p>所以一般情况下，我们的登录接口代码，会大致类似如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 会话登录接口 </span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;doLogin&quot;)</span></span><br><span class="line"><span class="keyword">public</span> SaResult <span class="title function_">doLogin</span><span class="params">(String name, String pwd)</span> &#123;</span><br><span class="line">    <span class="comment">// 第一步：比对前端提交的账号名称、密码</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;zhang&quot;</span>.equals(name) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(pwd)) &#123;</span><br><span class="line">        <span class="comment">// 第二步：根据账号id，进行登录 </span></span><br><span class="line">        StpUtil.login(<span class="number">10001</span>);</span><br><span class="line">        <span class="keyword">return</span> SaResult.ok(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SaResult.error(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你对以上代码阅读没有压力，你可能会注意到略显奇怪的一点：此处仅仅做了会话登录，但并没有主动向前端返回 token 信息。是因为不需要吗？严格来讲是需要的，只不过 <code>StpUtil.login(id)</code> 方法利用了 Cookie 自动注入的特性，省略了你手写返回 token 的代码。</p><blockquote><p>Cookie 是什么？</p><p>如果你对 Cookie 功能还不太了解，也不用担心，我们会在之后的 [ 前后端分离 ] 章节中详细的阐述 Cookie 功能，现在你只需要了解最基本的两点：</p><ul><li>Cookie 可以从后端控制往浏览器中写入 token 值。</li><li>Cookie 会在前端每次发起请求时自动提交 token 值。</li></ul><p>因此，在 Cookie 功能的加持下，我们可以仅靠 <code>StpUtil.login(id)</code> 一句代码就完成登录认证。</p></blockquote><p>除了登录方法，我们还需要：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前会话注销登录</span></span><br><span class="line">StpUtil.logout();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前会话是否已经登录，返回true=已登录，false=未登录</span></span><br><span class="line">StpUtil.isLogin();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验当前会话是否已经登录, 如果未登录，则抛出异常：`NotLoginException`</span></span><br><span class="line">StpUtil.checkLogin();</span><br></pre></td></tr></table></figure><p>异常 <code>NotLoginException</code> 代表当前会话暂未登录，可能的原因有很多：前端没有提交 token 、前端提交的 token 是无效的、前端提交的 token 已经过期 …… 等等，可参照：<a href="https://sa-token.cc/doc.html#/fun/not-login-scene">未登录场景值</a> 了解如何获取未登录的场景值。</p><h2 id="3、会话查询"><a href="#3、会话查询" class="headerlink" title="3、会话查询"></a>3、会话查询</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前会话账号id, 如果未登录，则抛出异常：`NotLoginException`</span></span><br><span class="line">StpUtil.getLoginId();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似查询API还有：</span></span><br><span class="line">StpUtil.getLoginIdAsString();    <span class="comment">// 获取当前会话账号id, 并转化为`String`类型</span></span><br><span class="line">StpUtil.getLoginIdAsInt();       <span class="comment">// 获取当前会话账号id, 并转化为`int`类型</span></span><br><span class="line">StpUtil.getLoginIdAsLong();      <span class="comment">// 获取当前会话账号id, 并转化为`long`类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- 指定未登录情形下返回的默认值 ----------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前会话账号id, 如果未登录，则返回 null </span></span><br><span class="line">StpUtil.getLoginIdDefaultNull();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前会话账号id, 如果未登录，则返回默认值 （`defaultValue`可以为任意类型）</span></span><br><span class="line">StpUtil.getLoginId(T defaultValue);</span><br></pre></td></tr></table></figure><h2 id="4、Token-查询"><a href="#4、Token-查询" class="headerlink" title="4、Token 查询"></a>4、Token 查询</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前会话的 token 值</span></span><br><span class="line">StpUtil.getTokenValue();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前`StpLogic`的 token 名称</span></span><br><span class="line">StpUtil.getTokenName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定 token 对应的账号id，如果未登录，则返回 null</span></span><br><span class="line">StpUtil.getLoginIdByToken(String tokenValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前会话剩余有效期（单位：s，返回-1代表永久有效）</span></span><br><span class="line">StpUtil.getTokenTimeout();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前会话的 token 信息参数</span></span><br><span class="line">StpUtil.getTokenInfo();</span><br></pre></td></tr></table></figure><p>有关<code>TokenInfo</code>参数详解，请参考：<a href="https://sa-token.cc/doc.html#/fun/token-info">TokenInfo参数详解</a></p><h2 id="5、来个小测试，加深一下理解"><a href="#5、来个小测试，加深一下理解" class="headerlink" title="5、来个小测试，加深一下理解"></a>5、来个小测试，加深一下理解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 登录测试 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/acc/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试登录  ---- http://localhost:8081/acc/doLogin?name=zhang&amp;pwd=123456</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;doLogin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SaResult <span class="title function_">doLogin</span><span class="params">(String name, String pwd)</span> &#123;</span><br><span class="line">        <span class="comment">// 此处仅作模拟示例，真实项目需要从数据库中查询数据进行比对 </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;zhang&quot;</span>.equals(name) &amp;&amp; <span class="string">&quot;123456&quot;</span>.equals(pwd)) &#123;</span><br><span class="line">            StpUtil.login(<span class="number">10001</span>);</span><br><span class="line">            <span class="keyword">return</span> SaResult.ok(<span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SaResult.error(<span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询登录状态  ---- http://localhost:8081/acc/isLogin</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;isLogin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SaResult <span class="title function_">isLogin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SaResult.ok(<span class="string">&quot;是否登录：&quot;</span> + StpUtil.isLogin());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询 Token 信息  ---- http://localhost:8081/acc/tokenInfo</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;tokenInfo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SaResult <span class="title function_">tokenInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SaResult.data(StpUtil.getTokenInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试注销  ---- http://localhost:8081/acc/logout</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;logout&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SaResult <span class="title function_">logout</span><span class="params">()</span> &#123;</span><br><span class="line">        StpUtil.logout();</span><br><span class="line">        <span class="keyword">return</span> SaResult.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[本章代码示例：Sa-Token 登录认证 —— <a href="https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-case/src/main/java/com/pj/cases/use/LoginAuthController.java"> LoginAuthController.java ]</a></p><hr><h1 id="权限认证"><a href="#权限认证" class="headerlink" title="权限认证"></a>权限认证</h1><h2 id="1、设计思路-1"><a href="#1、设计思路-1" class="headerlink" title="1、设计思路"></a>1、设计思路</h2><p>所谓权限认证，核心逻辑就是判断一个账号是否拥有指定权限：</p><ul><li>有，就让你通过。</li><li>没有？那么禁止访问！</li></ul><p>深入到底层数据中，就是每个账号都会拥有一组权限码集合，框架来校验这个集合中是否包含指定的权限码。</p><p>例如：当前账号哦拥有权限码集合 <code>[&quot;user-add&quot;, &quot;user-delete&quot;, &quot;user-get&quot;]</code> ，这时候我来校验权限 <code>&quot;user-update&quot;</code> ，则其结果就是：验证失败，禁止访问。</p><button style="background: #fbca1f; font-family: inherit; padding: 0.6em 1.3em; font-weight: 900; font-size: 18px; border: 3px solid black; border-radius: 0.4em; box-shadow: 0.1em 0.1em; cursor: pointer; transition: transform 0.1s, box-shadow 0.1s;" onclick="toggleGif()" onmouseover="this.style.transform='translate(-0.05em, -0.05em)'; this.style.boxShadow='0.15em 0.15em';" onmouseout="this.style.transform=''; this.style.boxShadow='0.1em 0.1em';" onmousedown="this.style.transform='translate(0.05em, 0.05em)'; this.style.boxShadow='0.05em 0.05em';" onmouseup="this.style.transform=''; this.style.boxShadow='0.1em 0.1em';">加载动态演示图</button><img id="gifImage" src="/img/load.gif" data-original="https://oss.dev33.cn/sa-token/doc/g/g3--jur-auth.gif" style="display:none; width: 1280px; height: auto;" alt="动态演示图"><script>function toggleGif() {    const gif = document.getElementById('gifImage');    if (gif.style.display === 'none' || gif.style.display === '') {        gif.style.display = 'block';     } else {        gif.style.display = 'none';     }}</script><p><br><br></p><p>所以现在问题的核心就是两个：</p><ol><li>如何获取一个账号所拥有的权限码集合？</li><li>本次操作需要验证的权限码是哪个？</li></ol><h2 id="2、获取当前账号权限码集合"><a href="#2、获取当前账号权限码集合" class="headerlink" title="2、获取当前账号权限码集合"></a>2、获取当前账号权限码集合</h2><p>因为每个项目的需求不同，其权限设计也千变万化，因此 [ 获取当前账号权限码集合 ] 这一操作不可能内置到框架中，所以 Sa-Token 将此操作以接口的方式暴露给你，以方便你根据自己的业务逻辑进行重写。</p><p>你需要做的是新建一个类，实现 <code>StpInterface</code> 接口，例如以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义权限加载接口实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>    <span class="comment">// 保证此类被 SpringBoot 扫描，完成 Sa-Token 的自定义权限验证扩展 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StpInterfaceImpl</span> <span class="keyword">implements</span> <span class="title class_">StpInterface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个账号所拥有的权限码集合 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getPermissionList</span><span class="params">(Object loginId, String loginType)</span> &#123;</span><br><span class="line">        <span class="comment">// 本 list 仅做模拟，实际项目中要根据具体业务逻辑来查询权限</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();    </span><br><span class="line">        list.add(<span class="string">&quot;101&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;user.add&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;user.update&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;user.get&quot;</span>);</span><br><span class="line">        <span class="comment">// list.add(&quot;user.delete&quot;);</span></span><br><span class="line">        list.add(<span class="string">&quot;art.*&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回一个账号所拥有的角色标识集合 (权限与角色可分开校验)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getRoleList</span><span class="params">(Object loginId, String loginType)</span> &#123;</span><br><span class="line">        <span class="comment">// 本 list 仅做模拟，实际项目中要根据具体业务逻辑来查询角色</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();    </span><br><span class="line">        list.add(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;super-admin&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数解释：</strong></p><ul><li>loginId：账号 id，即你在调用 <code>StpUtil.login(id)</code> 时写入的标识值。</li><li>loginType：账号体系标识，此处可以暂时忽略，在 [ 多账户认证 ] 章节下会对这个概念做详细的解释。</li></ul><blockquote><p>有同学会产生疑问：我实现了此接口，但是程序启动时好像并没有执行，是不是我写错了？</p><p>答：不执行是正常现象，程序启动时不会执行这个接口的方法，在每次调用鉴权代码时，才会执行到此。</p></blockquote><h2 id="3、权限校验"><a href="#3、权限校验" class="headerlink" title="3、权限校验"></a>3、权限校验</h2><p>然后就可以用以下 api 来鉴权了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取：当前账号所拥有的权限集合</span></span><br><span class="line">StpUtil.getPermissionList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断：当前账号是否含有指定权限, 返回 true 或 false</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;user.add&quot;</span>);        </span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验：当前账号是否含有指定权限, 如果验证未通过，则抛出异常: NotPermissionException </span></span><br><span class="line">StpUtil.checkPermission(<span class="string">&quot;user.add&quot;</span>);        </span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验：当前账号是否含有指定权限 [指定多个，必须全部验证通过]</span></span><br><span class="line">StpUtil.checkPermissionAnd(<span class="string">&quot;user.add&quot;</span>, <span class="string">&quot;user.delete&quot;</span>, <span class="string">&quot;user.get&quot;</span>);        </span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验：当前账号是否含有指定权限 [指定多个，只要其一验证通过即可]</span></span><br><span class="line">StpUtil.checkPermissionOr(<span class="string">&quot;user.add&quot;</span>, <span class="string">&quot;user.delete&quot;</span>, <span class="string">&quot;user.get&quot;</span>);    </span><br></pre></td></tr></table></figure><p>扩展：<code>NotPermissionException</code> 对象可通过 <code>getLoginType()</code> 方法获取具体是哪个 <code>StpLogic</code> 抛出的异常</p><h2 id="4、角色校验"><a href="#4、角色校验" class="headerlink" title="4、角色校验"></a>4、角色校验</h2><p>在 Sa-Token 中，角色和权限可以分开独立验证</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取：当前账号所拥有的角色集合</span></span><br><span class="line">StpUtil.getRoleList();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断：当前账号是否拥有指定角色, 返回 true 或 false</span></span><br><span class="line">StpUtil.hasRole(<span class="string">&quot;super-admin&quot;</span>);        </span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验：当前账号是否含有指定角色标识, 如果验证未通过，则抛出异常: NotRoleException</span></span><br><span class="line">StpUtil.checkRole(<span class="string">&quot;super-admin&quot;</span>);        </span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验：当前账号是否含有指定角色标识 [指定多个，必须全部验证通过]</span></span><br><span class="line">StpUtil.checkRoleAnd(<span class="string">&quot;super-admin&quot;</span>, <span class="string">&quot;shop-admin&quot;</span>);        </span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验：当前账号是否含有指定角色标识 [指定多个，只要其一验证通过即可] </span></span><br><span class="line">StpUtil.checkRoleOr(<span class="string">&quot;super-admin&quot;</span>, <span class="string">&quot;shop-admin&quot;</span>);        </span><br></pre></td></tr></table></figure><p>扩展：<code>NotRoleException</code> 对象可通过 <code>getLoginType()</code> 方法获取具体是哪个 <code>StpLogic</code> 抛出的异常</p><h2 id="5、拦截全局异常"><a href="#5、拦截全局异常" class="headerlink" title="5、拦截全局异常"></a>5、拦截全局异常</h2><p>有同学要问，鉴权失败，抛出异常，然后呢？要把异常显示给用户看吗？<strong>当然不可以！</strong></p><p>你可以创建一个全局异常拦截器，统一返回给前端的格式，参考：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 全局异常拦截 </span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="keyword">public</span> SaResult <span class="title function_">handlerException</span><span class="params">(Exception e)</span> &#123;</span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">        <span class="keyword">return</span> SaResult.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可参考：<a href="https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-case/src/main/java/com/pj/current/GlobalException.java">码云：GlobalException.java</a></p><h2 id="6、权限通配符"><a href="#6、权限通配符" class="headerlink" title="6、权限通配符"></a>6、权限通配符</h2><p>Sa-Token允许你根据通配符指定<strong>泛权限</strong>，例如当一个账号拥有<code>art.*</code>的权限时，<code>art.add</code>、<code>art.delete</code>、<code>art.update</code>都将匹配通过</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当拥有 art.* 权限时</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;art.add&quot;</span>);        <span class="comment">// true</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;art.update&quot;</span>);     <span class="comment">// true</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;goods.add&quot;</span>);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当拥有 *.delete 权限时</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;art.delete&quot;</span>);      <span class="comment">// true</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;user.delete&quot;</span>);     <span class="comment">// true</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;user.update&quot;</span>);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当拥有 *.js 权限时</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;index.js&quot;</span>);        <span class="comment">// true</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;index.css&quot;</span>);       <span class="comment">// false</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;index.html&quot;</span>);      <span class="comment">// false</span></span><br></pre></td></tr></table></figure><blockquote><p>上帝权限</p><p>当一个账号拥有 <code>&quot;*&quot;</code> 权限时，他可以验证通过任何权限码 （角色认证同理）</p></blockquote><h2 id="7、如何把权限精确到按钮级？"><a href="#7、如何把权限精确到按钮级？" class="headerlink" title="7、如何把权限精确到按钮级？"></a>7、如何把权限精确到按钮级？</h2><p>权限精确到按钮级的意思就是指：<strong>权限范围可以控制到页面上的每一个按钮是否显示</strong> 。</p><p>思路：如此精确的范围控制只依赖后端已经难以完成，此时需要前端进行一定的逻辑判断。</p><p>如果是前后端一体项目，可以参考：<a href="https://sa-token.cc/doc.html#/plugin/thymeleaf-extend">Thymeleaf 标签方言</a>，如果是前后端分离项目，则：</p><ol><li><p>在登录时，把当前账号拥有的所有权限码一次性返回给前端。</p></li><li><p>前端将权限码集合保存在 <code>localStorage</code> 或其他全局状态管理对象中。</p></li><li><p>在需要权限控制的按钮上，使用 js 进行逻辑判断，例如在 <code>Vue</code> 框架中我们可以使用如下写法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// `arr`是当前用户拥有的权限码数组</span></span><br><span class="line"><span class="comment">// `user.delete`是显示按钮需要拥有的权限码</span></span><br><span class="line"><span class="comment">// `删除按钮`是用户拥有权限码才可以看到的内容。</span></span><br><span class="line">&lt;button v-<span class="keyword">if</span>=<span class="string">&quot;arr.indexOf(&#x27;user.delete&#x27;) &gt; -1&quot;</span>&gt;删除按钮&lt;/button&gt;</span><br></pre></td></tr></table></figure></li></ol><p>以上写法只为提供一个参考示例，不同框架有不同写法，大家可根据项目技术栈灵活封装进行调用。</p><blockquote><p>✍ 前端有了鉴权后端还需要鉴权吗？</p><p><strong>需要！</strong><br>前端的鉴权只是一个辅助功能，对于专业人员这些限制都是可以轻松绕过的，为保证服务器安全：<strong>无论前端是否进行了权限校验，后端接口都需要对会话请求再次进行权限校验！</strong></p></blockquote><h2 id="8、示例代码"><a href="#8、示例代码" class="headerlink" title="8、示例代码"></a>8、示例代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sa-Token 权限认证示例 </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> click33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-10-13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/jur/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JurAuthController</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前提1：首先调用登录接口进行登录，代码在 com.pj.cases.use.LoginAuthController 中有详细解释，此处不再赘述 </span></span><br><span class="line"><span class="comment"> * ---- http://localhost:8081/acc/doLogin?name=zhang&amp;pwd=123456</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 前提2：项目实现 StpInterface 接口，代码在  com.pj.satoken.StpInterfaceImpl</span></span><br><span class="line"><span class="comment"> * Sa-Token 将从此实现类获取 每个账号拥有哪些权限。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 然后我们就可以使用以下示例中的代码进行鉴权了 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询权限   ---- http://localhost:8081/jur/getPermission</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;getPermission&quot;)</span></span><br><span class="line"><span class="keyword">public</span> SaResult <span class="title function_">getPermission</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 查询权限信息 ，如果当前会话未登录，会返回一个空集合 </span></span><br><span class="line">List&lt;String&gt; permissionList = StpUtil.getPermissionList();</span><br><span class="line">System.out.println(<span class="string">&quot;当前登录账号拥有的所有权限：&quot;</span> + permissionList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询角色信息 ，如果当前会话未登录，会返回一个空集合 </span></span><br><span class="line">List&lt;String&gt; roleList = StpUtil.getRoleList();</span><br><span class="line">System.out.println(<span class="string">&quot;当前登录账号拥有的所有角色：&quot;</span> + roleList);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回给前端 </span></span><br><span class="line"><span class="keyword">return</span> SaResult.ok()</span><br><span class="line">.set(<span class="string">&quot;roleList&quot;</span>, roleList)</span><br><span class="line">.set(<span class="string">&quot;permissionList&quot;</span>, permissionList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 权限校验  ---- http://localhost:8081/jur/checkPermission</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;checkPermission&quot;)</span></span><br><span class="line"><span class="keyword">public</span> SaResult <span class="title function_">checkPermission</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断：当前账号是否拥有一个权限，返回 true 或 false</span></span><br><span class="line"><span class="comment">// 如果当前账号未登录，则永远返回 false </span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;user.add&quot;</span>);</span><br><span class="line">StpUtil.hasPermissionAnd(<span class="string">&quot;user.add&quot;</span>, <span class="string">&quot;user.delete&quot;</span>, <span class="string">&quot;user.get&quot;</span>);  <span class="comment">// 指定多个，必须全部拥有才会返回 true </span></span><br><span class="line">StpUtil.hasPermissionOr(<span class="string">&quot;user.add&quot;</span>, <span class="string">&quot;user.delete&quot;</span>, <span class="string">&quot;user.get&quot;</span>); <span class="comment">// 指定多个，只要拥有一个就会返回 true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验：当前账号是否拥有一个权限，校验不通过时会抛出 `NotPermissionException` 异常 </span></span><br><span class="line"><span class="comment">// 如果当前账号未登录，则永远校验失败 </span></span><br><span class="line">StpUtil.checkPermission(<span class="string">&quot;user.add&quot;</span>);</span><br><span class="line">StpUtil.checkPermissionAnd(<span class="string">&quot;user.add&quot;</span>, <span class="string">&quot;user.delete&quot;</span>, <span class="string">&quot;user.get&quot;</span>);  <span class="comment">// 指定多个，必须全部拥有才会校验通过 </span></span><br><span class="line">StpUtil.checkPermissionOr(<span class="string">&quot;user.add&quot;</span>, <span class="string">&quot;user.delete&quot;</span>, <span class="string">&quot;user.get&quot;</span>);  <span class="comment">// 指定多个，只要拥有一个就会校验通过 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> SaResult.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 角色校验  ---- http://localhost:8081/jur/checkRole</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;checkRole&quot;)</span></span><br><span class="line"><span class="keyword">public</span> SaResult <span class="title function_">checkRole</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断：当前账号是否拥有一个角色，返回 true 或 false</span></span><br><span class="line"><span class="comment">// 如果当前账号未登录，则永远返回 false </span></span><br><span class="line">StpUtil.hasRole(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">StpUtil.hasRoleAnd(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;ceo&quot;</span>, <span class="string">&quot;cfo&quot;</span>);  <span class="comment">// 指定多个，必须全部拥有才会返回 true </span></span><br><span class="line">StpUtil.hasRoleOr(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;ceo&quot;</span>, <span class="string">&quot;cfo&quot;</span>);  <span class="comment">// 指定多个，只要拥有一个就会返回 true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验：当前账号是否拥有一个角色，校验不通过时会抛出 `NotRoleException` 异常 </span></span><br><span class="line"><span class="comment">// 如果当前账号未登录，则永远校验失败 </span></span><br><span class="line">StpUtil.checkRole(<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">StpUtil.checkRoleAnd(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;ceo&quot;</span>, <span class="string">&quot;cfo&quot;</span>);  <span class="comment">// 指定多个，必须全部拥有才会校验通过 </span></span><br><span class="line">StpUtil.checkRoleOr(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;ceo&quot;</span>, <span class="string">&quot;cfo&quot;</span>);  <span class="comment">// 指定多个，只要拥有一个就会校验通过 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> SaResult.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 权限通配符  ---- http://localhost:8081/jur/wildcardPermission</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;wildcardPermission&quot;)</span></span><br><span class="line"><span class="keyword">public</span> SaResult <span class="title function_">wildcardPermission</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前提条件：在 StpInterface 实现类中，为账号返回了 &quot;art.*&quot; 泛权限</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;art.add&quot;</span>);  <span class="comment">// 返回 true </span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;art.delete&quot;</span>);  <span class="comment">// 返回 true </span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;goods.add&quot;</span>);  <span class="comment">// 返回 false，因为前缀不符合  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// * 符合可以出现在任意位置，比如权限码的开头，当账号拥有 &quot;*.delete&quot; 时  </span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;goods.add&quot;</span>);        <span class="comment">// false</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;goods.delete&quot;</span>);     <span class="comment">// true</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;art.delete&quot;</span>);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以出现在权限码的中间，比如当账号拥有 &quot;shop.*.user&quot; 时  </span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;shop.add.user&quot;</span>);  <span class="comment">// true</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;shop.delete.user&quot;</span>);  <span class="comment">// true</span></span><br><span class="line">StpUtil.hasPermission(<span class="string">&quot;shop.delete.goods&quot;</span>);  <span class="comment">// false，因为后缀不符合 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意点：</span></span><br><span class="line"><span class="comment">// 1、上帝权限：当一个账号拥有 &quot;*&quot; 权限时，他可以验证通过任何权限码</span></span><br><span class="line"><span class="comment">// 2、角色校验也可以加 * ，指定泛角色，例如： &quot;*.admin&quot;，暂不赘述 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> SaResult.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[本章代码示例：Sa-Token 权限认证 —— <a href="https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-case/src/main/java/com/pj/cases/use/JurAuthController.java"> JurAuthController.java ]</a></p><hr><h1 id="踢人下线"><a href="#踢人下线" class="headerlink" title="踢人下线"></a>踢人下线</h1><p>所谓踢人下线，核心操作就是找到指定 <code>loginId</code> 对应的 <code>Token</code> ，并设置其失效。</p><p><img src="/img/load.gif" data-original="https://oss.dev33.cn/sa-token/doc/kickout.png" alt="踢下线"></p><h2 id="1、强制注销"><a href="#1、强制注销" class="headerlink" title="1、强制注销"></a>1、强制注销</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StpUtil.logout(<span class="number">10001</span>);                    <span class="comment">// 强制指定账号注销下线 </span></span><br><span class="line">StpUtil.logout(<span class="number">10001</span>, <span class="string">&quot;PC&quot;</span>);              <span class="comment">// 强制指定账号指定端注销下线 </span></span><br><span class="line">StpUtil.logoutByTokenValue(<span class="string">&quot;token&quot;</span>);      <span class="comment">// 强制指定 Token 注销下线 </span></span><br></pre></td></tr></table></figure><h2 id="2、踢人下线"><a href="#2、踢人下线" class="headerlink" title="2、踢人下线"></a>2、踢人下线</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StpUtil.kickout(<span class="number">10001</span>);                    <span class="comment">// 将指定账号踢下线 </span></span><br><span class="line">StpUtil.kickout(<span class="number">10001</span>, <span class="string">&quot;PC&quot;</span>);              <span class="comment">// 将指定账号指定端踢下线</span></span><br><span class="line">StpUtil.kickoutByTokenValue(<span class="string">&quot;token&quot;</span>);      <span class="comment">// 将指定 Token 踢下线</span></span><br></pre></td></tr></table></figure><p>强制注销 和 踢人下线 的区别在于：</p><ul><li>强制注销等价于对方主动调用了注销方法，再次访问会提示：Token无效。</li><li>踢人下线不会清除Token信息，而是将其打上特定标记，再次访问会提示：Token已被踢下线。</li></ul><p><button style="background: #fbca1f; font-family: inherit; padding: 0.6em 1.3em; font-weight: 900; font-size: 18px; border: 3px solid black; border-radius: 0.4em; box-shadow: 0.1em 0.1em; cursor: pointer; transition: transform 0.1s, box-shadow 0.1s;"       onclick="toggleGif1()" onmouseover="this.style.transform='translate(-0.05em, -0.05em)'; this.style.boxShadow='0.15em 0.15em';" onmouseout="this.style.transform=''; this.style.boxShadow='0.1em 0.1em';" onmousedown="this.style.transform='translate(0.05em, 0.05em)'; this.style.boxShadow='0.05em 0.05em';" onmouseup="this.style.transform=''; this.style.boxShadow='0.1em 0.1em';"><br>加载动态演示图<br></button></p><img id="gifImage1" src="/img/load.gif" data-original="https://oss.dev33.cn/sa-token/doc/g/g3--kickout.gif" style="display:none; width: 1280px; height: auto;" alt="动态演示图"><script>function toggleGif1() {    const gif = document.getElementById('gifImage1');    if (gif.style.display === 'none' || gif.style.display === '') {        gif.style.display = 'block';     } else {        gif.style.display = 'none';     }}</script><p><br><br></p><p>[本章代码示例：Sa-Token 踢人下线 —— <a href="https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-case/src/main/java/com/pj/cases/use/KickoutController.java"> KickoutController.java ]</a></p><hr><h1 id="注解鉴权"><a href="#注解鉴权" class="headerlink" title="注解鉴权"></a>注解鉴权</h1><h2 id="注解鉴权-1"><a href="#注解鉴权-1" class="headerlink" title="注解鉴权"></a>注解鉴权</h2><p>有同学表示：尽管使用代码鉴权非常方便，但是我们仍希望把鉴权逻辑和业务逻辑分离出来，我们可以使用注解鉴权吗？当然可以！</p><p>注解鉴权 —— 优雅的将鉴权与业务代码分离！</p><ul><li><code>@SaCheckLogin</code>：登录校验 —— 只有登录之后才能够进入该方法。</li><li><code>@SaCheckRole(&quot;admin&quot;)</code>：角色校验 —— 必须具有指定角色标识才能进入该方法。</li><li><code>@SaCheckPermission(&quot;user:add&quot;)</code>：权限校验 —— 必须具有指定权限才能进入该方法。</li><li><code>@SacheckSafe</code>：二级认证校验 —— 必须二级认证之后才能进入该方法。</li><li><code>@SaCheckHttpBasic</code>：HttpBasic 校验 —— 只有通过 HttpBasic 认证后才能进入该方法。</li><li><code>@SaCheckHttpDigest</code>：HttpDigest 校验 —— 只有通过 HttpDigest 认证后才能进入该方法。</li><li><code>@SaIgnore</code>：忽略校验 —— 表示被修饰的方法或类无需进行注解鉴权和路由拦截器鉴权。</li><li><code>@SacheckDisable(&quot;comment&quot;)</code>：账号服务封禁校验 —— 校验当前账号指定服务是否被封禁。</li></ul><p>Sa-Token 使用全局拦截器完成注解鉴权功能，为了不为项目带来不必要的性能负担，拦截器默认处于关闭状态</p><p>因此，为了使用注解鉴权，<strong>你必须手动将 Sa-Token 的全局拦截器注册到你项目中</strong></p><h2 id="1、注册拦截器"><a href="#1、注册拦截器" class="headerlink" title="1、注册拦截器"></a>1、注册拦截器</h2><p>以<code>SpringBoot2.0</code>为例，新建配置类<code>SaTokenConfigure.java</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaTokenConfigure</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// 注册 Sa-Token 拦截器，打开注解式鉴权功能 </span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 注册 Sa-Token 拦截器，打开注解式鉴权功能 </span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">SaInterceptor</span>()).addPathPatterns(<span class="string">&quot;/**&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保证此类被<code>springboot</code>启动类扫描到即可</p><h2 id="2、使用注解鉴权"><a href="#2、使用注解鉴权" class="headerlink" title="2、使用注解鉴权"></a>2、使用注解鉴权</h2><p>然后我们就可以愉快的使用注解鉴权了：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 登录校验：只有登录之后才能进入该方法 </span></span><br><span class="line"><span class="meta">@SaCheckLogin</span>                        </span><br><span class="line"><span class="meta">@RequestMapping(&quot;info&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">info</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;查询用户信息&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 角色校验：必须具有指定角色才能进入该方法 </span></span><br><span class="line"><span class="meta">@SaCheckRole(&quot;super-admin&quot;)</span>        </span><br><span class="line"><span class="meta">@RequestMapping(&quot;add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;用户增加&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 权限校验：必须具有指定权限才能进入该方法 </span></span><br><span class="line"><span class="meta">@SaCheckPermission(&quot;user-add&quot;)</span>        </span><br><span class="line"><span class="meta">@RequestMapping(&quot;add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;用户增加&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二级认证校验：必须二级认证之后才能进入该方法 </span></span><br><span class="line"><span class="meta">@SaCheckSafe()</span>        </span><br><span class="line"><span class="meta">@RequestMapping(&quot;add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;用户增加&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Http Basic 校验：只有通过 Http Basic 认证后才能进入该方法 </span></span><br><span class="line"><span class="meta">@SaCheckHttpBasic(account = &quot;sa:123456&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;用户增加&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Http Digest 校验：只有通过 Http Digest 认证后才能进入该方法 </span></span><br><span class="line"><span class="meta">@SaCheckHttpDigest(value = &quot;sa:123456&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;add&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;用户增加&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验当前账号是否被封禁 comment 服务，如果已被封禁会抛出异常，无法进入方法 </span></span><br><span class="line"><span class="meta">@SaCheckDisable(&quot;comment&quot;)</span>                </span><br><span class="line"><span class="meta">@RequestMapping(&quot;send&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;查询用户信息&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上注解都可以加在类上，代表为这个类所有方法进行鉴权</p><h2 id="3、设定校验模式"><a href="#3、设定校验模式" class="headerlink" title="3、设定校验模式"></a>3、设定校验模式</h2><p><code>@SaCheckRole</code>与<code>@SaCheckPermission</code>注解可设置校验模式，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注解式鉴权：只要具有其中一个权限即可通过校验 </span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;atJurOr&quot;)</span></span><br><span class="line"><span class="meta">@SaCheckPermission(value = &#123;&quot;user-add&quot;, &quot;user-all&quot;, &quot;user-delete&quot;&#125;, mode = SaMode.OR)</span>        </span><br><span class="line"><span class="keyword">public</span> SaResult <span class="title function_">atJurOr</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SaResult.data(<span class="string">&quot;用户信息&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mode 有两种取值：</p><ul><li><code>SaMode.AND</code>，标注一组权限，会话必须全部具有才可通过校验。</li><li><code>SaMode.OR</code>，标注一组权限，会话只要具有其一即可通过校验。</li></ul><h2 id="4、角色权限双重校验-“or-校验”"><a href="#4、角色权限双重校验-“or-校验”" class="headerlink" title="4、角色权限双重校验 “or 校验”"></a>4、角色权限双重校验 “or 校验”</h2><p>假设有以下业务场景：一个接口在具有权限 <code>user.add</code> 或角色 <code>admin</code> 时可以调通。怎么写？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 角色权限双重 “or校验”：具备指定权限或者指定角色即可通过校验</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;userAdd&quot;)</span></span><br><span class="line"><span class="meta">@SaCheckPermission(value = &quot;user.add&quot;, orRole = &quot;admin&quot;)</span>        </span><br><span class="line"><span class="keyword">public</span> SaResult <span class="title function_">userAdd</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SaResult.data(<span class="string">&quot;用户信息&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>orRole 字段代表权限校验未通过时的次要选择，两者只要一校验成功即可进入请求方法，其有三种写法：</p><ul><li>写法一：<code>orRole = &quot;admin&quot;</code>，代表需要拥有角色 admin 。</li><li>写法二：<code>orRole = &#123;&quot;admin&quot;, &quot;manager&quot;, &quot;staff&quot;&#125;</code>，代表具有三个角色其一即可。</li><li>写法三：<code>orRole = &#123;&quot;admin, manager, staff&quot;&#125;</code>，代表必须同时具有三个角色。</li></ul><h2 id="5、忽略认证"><a href="#5、忽略认证" class="headerlink" title="5、忽略认证"></a>5、忽略认证</h2><p>使用 <code>@SaIgnore</code> 可表示一个接口忽略认证：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SaCheckLogin</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... 其它方法 </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此接口加上了 @SaIgnore 可以游客访问 </span></span><br><span class="line">    <span class="meta">@SaIgnore</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;getList&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> SaResult <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        <span class="keyword">return</span> SaResult.ok(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码表示：<code>TestController</code> 中的所有方法都需要登录后才可以访问，但是 <code>getList</code> 接口可以匿名游客访问。</p><ul><li><code>@SaIgnore</code> 修饰方法时代表这个方法可以被游客访问，修饰类时代表这个类中的所有接口都可以游客访问。</li><li><code>@SaIgnore</code> 具有最高优先级，当 @SaIgnore 和其它鉴权注解一起出现时，其它鉴权注解都将被忽略。</li><li><code>@SaIgnore</code> 同样可以忽略掉 Sa-Token 拦截器中的路由鉴权，在下面的 [路由拦截鉴权] 章节中我们会讲到。</li></ul><h2 id="6、批量注解鉴权"><a href="#6、批量注解鉴权" class="headerlink" title="6、批量注解鉴权"></a>6、批量注解鉴权</h2><p>使用 <code>@SaCheckOr</code> 表示批量注解鉴权：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 `@SaCheckOr` 中可以指定多个注解，只要当前会话满足其中一个注解即可通过验证，进入方法。</span></span><br><span class="line"><span class="meta">@SaCheckOr(</span></span><br><span class="line"><span class="meta">        login = @SaCheckLogin,</span></span><br><span class="line"><span class="meta">        role = @SaCheckRole(&quot;admin&quot;),</span></span><br><span class="line"><span class="meta">        permission = @SaCheckPermission(&quot;user.add&quot;),</span></span><br><span class="line"><span class="meta">        safe = @SaCheckSafe(&quot;update-password&quot;),</span></span><br><span class="line"><span class="meta">        httpBasic = @SaCheckHttpBasic(account = &quot;sa:123456&quot;),</span></span><br><span class="line"><span class="meta">        disable = @SaCheckDisable(&quot;submit-orders&quot;)</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> SaResult <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">return</span> SaResult.ok(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一项属性都可以写成数组形式，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前客户端只要有 [ login 账号登录] 或者 [user 账号登录] 其一，就可以通过验证进入方法。</span></span><br><span class="line"><span class="comment">//         注意：`type = &quot;login&quot;` 和 `type = &quot;user&quot;` 是多账号模式章节的扩展属性，此处你可以先略过这个知识点。</span></span><br><span class="line"><span class="meta">@SaCheckOr(</span></span><br><span class="line"><span class="meta">    login = &#123; @SaCheckLogin(type = &quot;login&quot;), @SaCheckLogin(type = &quot;user&quot;) &#125;</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> SaResult <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">return</span> SaResult.ok(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>疑问：既然有了 <code>@SaCheckOr</code>，为什么没有与之对应的 <code>@SaCheckAnd</code> 呢？</p><p>因为当你写多个注解时，其天然就是 <code>and</code> 校验关系，例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当你在一个方法上写多个注解鉴权时，其默认就是要满足所有注解规则后，才可以进入方法，只要有一个不满足，就会抛出异常</span></span><br><span class="line"><span class="meta">@SaCheckLogin</span></span><br><span class="line"><span class="meta">@SaCheckRole(&quot;admin&quot;)</span></span><br><span class="line"><span class="meta">@SaCheckPermission(&quot;user.add&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> SaResult <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">return</span> SaResult.ok(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、扩展阅读"><a href="#7、扩展阅读" class="headerlink" title="7、扩展阅读"></a>7、扩展阅读</h2><ul><li>在业务逻辑层使用鉴权注解：<a href="https://sa-token.cc/doc.html#/plugin/aop-at">AOP注解鉴权</a></li><li>制作自定义鉴权注解注入到框架：<a href="https://sa-token.cc/doc.html#/fun/custom-annotations">自定义注解</a></li></ul><p>[本章代码示例：Sa-Token 注解鉴权 —— <a href="https://gitee.com/dromara/sa-token/blob/master/sa-token-demo/sa-token-demo-case/src/main/java/com/pj/cases/use/AtCheckController.java"> AtCheckController.java ]</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 开发框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SaToken </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程</title>
      <link href="/posts/1690d21b.html"/>
      <url>/posts/1690d21b.html</url>
      
        <content type="html"><![CDATA[<h1 id="一-道之伊始"><a href="#一-道之伊始" class="headerlink" title="一. 道之伊始"></a>一. 道之伊始</h1><p>宇宙初开之际，混沌之气笼罩着整个宇宙，一切模糊不清。</p><p>然后，盘古开天，女娲造人：日月乃出、星辰乃现，山川蜿蜒、江河奔流、生灵万物，欣欣向荣。此日月、星辰、山川、江河、生灵万物，谓之【对象】，皆随时间而化。</p><p>然而：日月之行、星汉灿烂、山川起伏、湖海汇聚，冥冥中有至理藏其中。名曰【道】，乃万物遵循之规律，亦谓之【函数】，它无问东西，亘古不变</p><p>作为<strong>设计宇宙洪荒</strong>的程序员</p><ul><li>造日月、筑山川、划江河、开湖海、演化生灵万物、令其生生不息，则必用面向【对象】之手段</li><li>若定规则、求本源、追纯粹，论不变，则当选【函数】编程之思想</li></ul><p>下面就让我们从【函数】开始。</p><h2 id="什么是函数"><a href="#什么是函数" class="headerlink" title="什么是函数"></a>什么是函数</h2><p>什么是函数呢？函数即规则</p><p>数学上：</p><p><img src="/img/load.gif" data-original="/images/programmer/Java/b/image-20240129152419304.png" alt="image-20240129152419304"></p><p>例如：</p><table><thead><tr><th>INPUT</th><th>f(x)</th><th>OUTPUT</th></tr></thead><tbody><tr><td>1</td><td>?</td><td>1</td></tr><tr><td>2</td><td>?</td><td>4</td></tr><tr><td>3</td><td>?</td><td>9</td></tr><tr><td>4</td><td>?</td><td>16</td></tr><tr><td>5</td><td>?</td><td>25</td></tr><tr><td>…</td><td>…</td><td>…</td></tr></tbody></table><ul><li>$f(x) &#x3D; x^2$ 是一种规律， input 按照此规律变化为 output</li><li>很多规律已经由人揭示，例如 $e &#x3D; m \cdot c^2$​</li><li>程序设计中<strong>更</strong>可以自己去制定规律，一旦成为规则的制定者，你就是神</li></ul><h2 id="大道无情"><a href="#大道无情" class="headerlink" title="大道无情"></a>大道无情</h2><h3 id="无情"><a href="#无情" class="headerlink" title="无情"></a>无情</h3><p>何为无情：</p><ul><li>只要输入相同，无论多少次调用，无论什么时间调用，输出相同。</li></ul><h3 id="佛祖成道"><a href="#佛祖成道" class="headerlink" title="佛祖成道"></a>佛祖成道</h3><p>例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMutable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(pray(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        System.out.println(pray(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">        System.out.println(pray(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Buddha</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Buddha</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Buddha</span> <span class="variable">buddha</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Buddha</span>(<span class="string">&quot;佛祖&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">pray</span><span class="params">(String person)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (person + <span class="string">&quot;向[&quot;</span> + buddha.name + <span class="string">&quot;]虔诚祈祷&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上 pray 的执行结果，除了参数变化外，希望函数的执行规则永远不变</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">张三向[佛祖]虔诚祈祷</span><br><span class="line">张三向[佛祖]虔诚祈祷</span><br><span class="line">张三向[佛祖]虔诚祈祷</span><br></pre></td></tr></table></figure><p>然而，由于设计上的缺陷，函数引用了外界可变的数据，如果这么使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buddha.name = <span class="string">&quot;魔王&quot;</span>;</span><br><span class="line">System.out.println(pray(<span class="string">&quot;张三&quot;</span>));</span><br></pre></td></tr></table></figure><p>结果就会是</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">张三向[魔王]虔诚祈祷</span><br></pre></td></tr></table></figure><p>问题出在哪儿呢？函数的目的是除了参数能变化，其它部分都要不变，这样才能成为规则的一部分。佛祖要成为规则的一部分，也要保持不变</p><p>改正方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Buddha</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Buddha</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Buddha</span><span class="params">(String name)</span> &#123; &#125;</span><br></pre></td></tr></table></figure><ul><li>不是说函数不能引用外界的数据，而是它引用的数据必须也能作为规则的一部分</li><li>让佛祖不变，佛祖才能成为规则</li></ul><h3 id="函数与方法"><a href="#函数与方法" class="headerlink" title="函数与方法"></a>函数与方法</h3><p>方法本质上也是函数。不过方法绑定在对象之上，它是对象个人法则</p><p>函数是</p><ul><li>函数（对象数据，其它参数）</li></ul><p>而方法是</p><ul><li>对象数据.方法（其它参数）</li></ul><h3 id="不变的好处"><a href="#不变的好处" class="headerlink" title="不变的好处"></a>不变的好处</h3><p>只有不变，才能在滚滚时间洪流中屹立不倒，成为规则的一部分。</p><p>多线程编程中，不变意味着线程安全</p><h3 id="合格的函数无状态"><a href="#合格的函数无状态" class="headerlink" title="合格的函数无状态"></a>合格的函数无状态</h3><h2 id="大道无形"><a href="#大道无形" class="headerlink" title="大道无形"></a>大道无形</h2><h3 id="函数化对象"><a href="#函数化对象" class="headerlink" title="函数化对象"></a>函数化对象</h3><p>函数本无形，也就是它代表的规则：位置固定、不能传播。</p><p>若要有形，让函数的规则能够传播，需要将函数化为对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>与</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lambda</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Lambda</span> <span class="variable">add</span> <span class="operator">=</span> (a, b) -&gt; a + b; <span class="comment">// 它已经变成了一个 lambda 对象</span></span><br></pre></td></tr></table></figure><p>区别在哪？</p><ul><li>前者是纯粹的一条两数加法规则，它的位置是固定的，要使用它，需要通过 MyClass.add 找到它，然后执行</li><li>而后者（add 对象）就像长了腿，它的位置是可以变化的，想去哪里就去哪里，哪里要用到这条加法规则，把它传递过去</li><li>接口的目的是为了将来用它来执行函数对象，此接口中只能有一个方法定义</li></ul><p>函数化为对象做个比喻</p><ul><li>之前是大家要统一去西天取经</li><li>现在是每个菩萨、罗汉拿着经书，入世传经</li></ul><p>例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Lambda</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8080</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">                Thread.ofVirtual().start(() -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">ObjectInputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(s.getInputStream());</span><br><span class="line">                        <span class="type">Lambda</span> <span class="variable">lambda</span> <span class="operator">=</span> (Lambda) is.readObject();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(<span class="number">10</span>);</span><br><span class="line">                        System.out.printf(<span class="string">&quot;%s %d op %d = %d%n&quot;</span>,</span><br><span class="line">                   s.getRemoteSocketAddress().toString(), a, b, lambda.calculate(a, b));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Client1</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">try</span>(<span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))&#123;</span><br><span class="line">                <span class="type">Lambda</span> <span class="variable">lambda</span> <span class="operator">=</span> (Lambda &amp; Serializable) (a, b) -&gt; a + b;</span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(s.getOutputStream());</span><br><span class="line">                os.writeObject(lambda);</span><br><span class="line">                os.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Client2</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">try</span>(<span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))&#123;</span><br><span class="line">                <span class="type">Lambda</span> <span class="variable">lambda</span> <span class="operator">=</span> (Lambda &amp; Serializable) (a, b) -&gt; a - b;</span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(s.getOutputStream());</span><br><span class="line">                os.writeObject(lambda);</span><br><span class="line">                os.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Client3</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">try</span>(<span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))&#123;</span><br><span class="line">                <span class="type">Lambda</span> <span class="variable">lambda</span> <span class="operator">=</span> (Lambda &amp; Serializable) (a, b) -&gt; a * b;</span><br><span class="line">                <span class="type">ObjectOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(s.getOutputStream());</span><br><span class="line">                os.writeObject(lambda);</span><br><span class="line">                os.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面的例子做了一些简单的扩展，可以看到不同的客户端可以上传自己的计算规则</li></ul><blockquote><p><em><strong>P.S.</strong></em></p><ul><li>大部分文献都说 lambda 是匿名函数，但我觉得需要在这个说法上进行补充</li><li>至少在 java 里，虽然 lambda 表达式本身不需要起名字，但不得提供一个对应接口嘛</li></ul></blockquote><h3 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a>行为参数化</h3><p>已知学生类定义如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对一组学生集合，筛选出男学生，下面的代码实现如何，评价一下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Student&gt; students = List.of(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张无忌&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;杨不悔&quot;</span>, <span class="number">16</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周芷若&quot;</span>, <span class="number">19</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;宋青书&quot;</span>, <span class="number">20</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    System.out.println(filter(students)); <span class="comment">// 能得到 张无忌，宋青书</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> List&lt;Student&gt; <span class="title function_">filter</span><span class="params">(List&lt;Student&gt; students)</span> &#123;</span><br><span class="line">    List&lt;Student&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        <span class="keyword">if</span> (student.sex.equals(<span class="string">&quot;男&quot;</span>)) &#123;</span><br><span class="line">            result.add(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需求再变动一下，要求找到 18 岁以下的学生，上面代码显然不能用了，改动方法如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;Student&gt; <span class="title function_">filter</span><span class="params">(List&lt;Student&gt; students)</span> &#123;</span><br><span class="line">    List&lt;Student&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        <span class="keyword">if</span> (student.age &lt;= <span class="number">18</span>) &#123;</span><br><span class="line">            result.add(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(filter(students)); <span class="comment">// 能得到 张无忌，杨不悔</span></span><br></pre></td></tr></table></figure><p>那么需求如果再要变动，找18岁以下男学生，怎么改？显然上述做法并不太好… 更希望一个方法能处理各种情况，仔细观察以上两个方法，找不同。</p><p>不同在于筛选条件部分：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">student.sex.equals(<span class="string">&quot;男&quot;</span>)</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">student.age &lt;= <span class="number">18</span></span><br></pre></td></tr></table></figure><p>既然它们就是不同，那么能否把它作为参数传递进来，这样处理起来不就一致了吗？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;Student&gt; <span class="title function_">filter</span><span class="params">(List&lt;Student&gt; students, ???)</span> &#123;</span><br><span class="line">    List&lt;Student&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        <span class="keyword">if</span> (???) &#123;</span><br><span class="line">            result.add(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它俩要判断的逻辑不同，那这两处不同的逻辑必然要用函数来表示，将来这两个函数都需要用到 student 对象来判断，都应该返回一个 boolean 结果，怎么描述函数的长相呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lambda</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(Student student)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法可以统一成下述代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;Student&gt; <span class="title function_">filter</span><span class="params">(List&lt;Student&gt; students, Lambda lambda)</span> &#123;</span><br><span class="line">    List&lt;Student&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lambda.test(student)) &#123;</span><br><span class="line">            result.add(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，最后怎么给它传递不同实现呢？</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter(students, student -&gt; student.sex.equals(<span class="string">&quot;男&quot;</span>));</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter(students, student -&gt; student.age &lt;= <span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>还有新需求也能满足</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">filter(students, student -&gt; student.sex.equals(<span class="string">&quot;男&quot;</span>) &amp;&amp; student.age &lt;= <span class="number">18</span>);</span><br></pre></td></tr></table></figure><p>这样就实现了以不变应万变，而变换即是一个个函数对象，也可以称之为行为参数化</p><h3 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h3><p>在记录日志时，假设日志级别是 INFO，debug 方法会遇到下面的问题：</p><ul><li>本不需要记录日志，但 expensive 方法仍被执行了</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LogManager.getLogger();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(logger.getLevel());</span><br><span class="line">    logger.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, expensive());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String <span class="title function_">expensive</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行耗时操作&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;结果&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进方法1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(logger.isDebugEnabled())</span><br><span class="line">    logger.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, expensive());</span><br></pre></td></tr></table></figure><p>显然这么做，很多类似代码都要加上这样 if 判断，很不优雅</p><p>改进方法2：</p><p>在 debug 方法外再套一个新方法，内部逻辑大概是这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debug</span><span class="params">(<span class="keyword">final</span> String msg, <span class="keyword">final</span> Supplier&lt;?&gt; lambda)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="built_in">this</span>.debug(msg, lambda.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用时这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, () -&gt; expensive());</span><br></pre></td></tr></table></figure><p>expensive() 变成了不是立刻执行，在未来 if 条件成立时才执行</p><h3 id="函数对象的不同类型"><a href="#函数对象的不同类型" class="headerlink" title="函数对象的不同类型"></a>函数对象的不同类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator&lt;Student&gt; c = </span><br><span class="line">    (Student s1, Student s2) -&gt; Integer.compare(s1.age, s2.age);</span><br><span class="line">        </span><br><span class="line">BiFunction&lt;Student, Student, Integer&gt; f = </span><br><span class="line">                (Student s1, Student s2) -&gt; Integer.compare(s1.age, s2.age);</span><br></pre></td></tr></table></figure><h1 id="二-函数编程语法"><a href="#二-函数编程语法" class="headerlink" title="二. 函数编程语法"></a>二. 函数编程语法</h1><h2 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h2><p>在 Java 语言中，lambda 对象有两种形式：lambda 表达式与方法引用</p><p>lambda 对象的类型是由它的行为决定的，如果有一些 lambda 对象，它们的入参类型、返回值类型都一致，那么它们可以看作是同一类的 lambda 对象，它们的类型，用函数式接口来表示</p><h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>练习：将 lambda 对象分类，见 PPT</p><p>函数接口的命名规律</p><ul><li>带有 Unary 是一元的意思，表示一个参数</li><li>带有 Bi 或 Binary 是二元的意思，表示两个参数</li><li>Ternary 三元</li><li>Quatenary 四元</li><li>…</li></ul><p>方法引用也是类似，入参类型、返回值类型都一致的话，可以看作同一类的对象，也是用函数式接口表示</p><h2 id="六种方法引用"><a href="#六种方法引用" class="headerlink" title="六种方法引用"></a>六种方法引用</h2><h3 id="1）类名-静态方法名"><a href="#1）类名-静态方法名" class="headerlink" title="1）类名::静态方法名"></a>1）类名::静态方法名</h3><p>如何理解：</p><ul><li>函数对象的逻辑部分是：调用此静态方法</li><li>因此这个静态方法需要什么参数，函数对象也提供相应的参数即可</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Type2Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            需求：挑选出所有男性学生</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream.of(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;宋青书&quot;</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .filter(Type2Test::isMale)</span><br><span class="line">                .forEach(student -&gt; System.out.println(student));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMale</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> student.sex.equals(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Student</span><span class="params">(String name, String sex)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>filter 这个高阶函数接收的函数类型（Predicate）是：一个 T 类型的入参，一个 boolean 的返回值<ul><li>因此我们只需要给它提供一个相符合的 lambda 对象即可</li></ul></li><li>isMale 这个静态方法有入参 Student 对应 T，有返回值 boolean 也能对应上，所以可以直接使用</li></ul><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student[name=张无忌, sex=男]</span><br><span class="line">Student[name=宋青书, sex=男]</span><br></pre></td></tr></table></figure><h3 id="2）类名-非静态方法名"><a href="#2）类名-非静态方法名" class="headerlink" title="2）类名::非静态方法名"></a>2）类名::非静态方法名</h3><p>如何理解：</p><ul><li>函数对象的逻辑部分是：调用此非静态方法</li><li>因此这个函数对象需要提供一个额外的对象参数，以便能够调用此非静态方法</li><li>非静态方法的剩余参数，与函数对象的剩余参数一一对应</li></ul><p>例1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Type3Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        highOrder(Student::hello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">highOrder</span><span class="params">(Type3 lambda)</span> &#123;</span><br><span class="line">        System.out.println(lambda.transfer(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>), <span class="string">&quot;你好&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Type3</span> &#123;</span><br><span class="line">        String <span class="title function_">transfer</span><span class="params">(Student stu, String message)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String message)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name + <span class="string">&quot; say: &quot;</span> + message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上例中函数类型的</p><ul><li>参数1 对应着 hello 方法所属类型 Student</li><li>参数2 对应着 hello 方法自己的参数 String</li><li>返回值对应着 hello 方法自己的返回值 String</li></ul><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">张三 say: 你好</span><br></pre></td></tr></table></figure><p>例2：改写之前根据性别过滤的需求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Type2Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            需求：挑选出所有男性学生</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Stream.of(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;宋青书&quot;</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .filter(Student::isMale)</span><br><span class="line">                .forEach(student -&gt; System.out.println(student));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Student</span><span class="params">(String name, String sex)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">isMale</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.sex.equals(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>filter 这个高阶函数接收的函数类型（Predicate）是：一个 T 类型的入参，一个 boolean 的返回值<ul><li>因此我们只需要给它提供一个相符合的 lambda 对象即可</li></ul></li><li>它的入参1 T 对应着 isMale 非静态方法的所属类型 Student</li><li>它没有其它参数，isMale 方法也没有参数</li><li>返回值都是 boolean</li></ul><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student[name=张无忌, sex=男]</span><br><span class="line">Student[name=宋青书, sex=男]</span><br></pre></td></tr></table></figure><p>例3：将学生对象仅保留学生的姓名</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Type2Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stream.of(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;宋青书&quot;</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .map(Student::name)</span><br><span class="line">                .forEach(student -&gt; System.out.println(student));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Student</span><span class="params">(String name, String sex)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">isMale</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.sex.equals(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>map 这个高阶函数接收的函数类型是（Function）是：一个 T 类型的参数，一个 R 类型的返回值</li><li>它的入参1 T 对应着 name 非静态方法的所属类型 Student</li><li>它没有剩余参数，name 方法也没有参数</li><li>它的返回值 R 对应着 name 方法的返回值 String</li></ul><p>输出</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">张无忌</span><br><span class="line">周芷若</span><br><span class="line">宋青书</span><br></pre></td></tr></table></figure><h3 id="3）对象-非静态方法名"><a href="#3）对象-非静态方法名" class="headerlink" title="3）对象::非静态方法名"></a>3）对象::非静态方法名</h3><p>如何理解：</p><ul><li>函数对象的逻辑部分是：调用此非静态方法</li><li>因为对象已提供，所以不必作为函数对象参数的一部分</li><li>非静态方法的剩余参数，与函数对象的剩余参数一一对应</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Type4Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Util</span> <span class="variable">util</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Util</span>(); <span class="comment">// 对象</span></span><br><span class="line">        Stream.of(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;宋青书&quot;</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">                )</span><br><span class="line">                .filter(util::isMale)</span><br><span class="line">                .map(util::getName)</span><br><span class="line">                .forEach(student -&gt; System.out.println(student));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Student</span><span class="params">(String name, String sex)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">isMale</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.sex.equals(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Util</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">isMale</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> student.sex.equals(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String <span class="title function_">getName</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> student.name();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实较为典型的一个应用就是 <code>System.out</code> 对象中的非静态方法，最后的输出可以修改为</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>这是因为 </p><ul><li>forEach  这个高阶函数接收的函数类型（Consumer）是一个 T 类型参数，void 无返回值</li><li>而 System.out 对象中有非静态方法 void println(Object x) 与之一致，因此可以将此方法化为 lambda 对象给 forEach 使用</li></ul><h3 id="4）类名-new"><a href="#4）类名-new" class="headerlink" title="4）类名::new"></a>4）类名::new</h3><p>对于构造方法，也有专门的语法把它们转换为 lambda 对象</p><p>函数类型应满足</p><ul><li>参数部分与构造方法参数一致</li><li>返回值类型与构造方法所在类一致</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Type5Test</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = <span class="string">&quot;某人&quot;</span>;</span><br><span class="line">            <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.name = name;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                    <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                    <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Type51</span> &#123;</span><br><span class="line">        Student <span class="title function_">create</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Type52</span> &#123;</span><br><span class="line">        Student <span class="title function_">create</span><span class="params">(String name)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Type53</span> &#123;</span><br><span class="line">        Student <span class="title function_">create</span><span class="params">(String name, <span class="type">int</span> age)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        hiOrder((Type51) Student::<span class="keyword">new</span>);</span><br><span class="line">        hiOrder((Type52) Student::<span class="keyword">new</span>);</span><br><span class="line">        hiOrder((Type53) Student::<span class="keyword">new</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hiOrder</span><span class="params">(Type51 creator)</span> &#123;</span><br><span class="line">        System.out.println(creator.create());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hiOrder</span><span class="params">(Type52 creator)</span> &#123;</span><br><span class="line">        System.out.println(creator.create(<span class="string">&quot;张三&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hiOrder</span><span class="params">(Type53 creator)</span> &#123;</span><br><span class="line">        System.out.println(creator.create(<span class="string">&quot;李四&quot;</span>, <span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5）this-非静态方法名"><a href="#5）this-非静态方法名" class="headerlink" title="5）this::非静态方法名"></a>5）this::非静态方法名</h3><p>算是形式2的特例，只能用在类内部</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Type6Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Util</span> <span class="variable">util</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UtilExt</span>();</span><br><span class="line">        util.hiOrder(Stream.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;周芷若&quot;</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;宋青书&quot;</span>, <span class="string">&quot;男&quot;</span>)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Student</span><span class="params">(String name, String sex)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Util</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">isMale</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> student.sex.equals(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">isFemale</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> student.sex.equals(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hiOrder</span><span class="params">(Stream&lt;Student&gt; stream)</span> &#123;</span><br><span class="line">            stream</span><br><span class="line">                    .filter(<span class="built_in">this</span>::isMale)</span><br><span class="line">                    .forEach(System.out::println);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6）super-非静态方法名"><a href="#6）super-非静态方法名" class="headerlink" title="6）super::非静态方法名"></a>6）super::非静态方法名</h3><p>算是形式2的特例，只能用在类内部（用在要用 super 区分重载方法时）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Type6Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UtilExt</span> <span class="keyword">extends</span> <span class="title class_">Util</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">hiOrder</span><span class="params">(Stream&lt;Student&gt; stream)</span> &#123;</span><br><span class="line">            stream</span><br><span class="line">                    .filter(<span class="built_in">super</span>::isFemale)</span><br><span class="line">                    .forEach(System.out::println);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7）特例"><a href="#7）特例" class="headerlink" title="7）特例"></a>7）特例</h3><p>函数接口和方法引用之间，可以差一个返回值，例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExceptionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> ExceptionTest::print1;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> ExceptionTest::print2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;task1 running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">print2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;task2 running...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看到 Runnable 接口不需要返回值，而实际的函数对象多出的返回值也不影响使用</li></ul><h2 id="闭包（Closure）"><a href="#闭包（Closure）" class="headerlink" title="闭包（Closure）"></a>闭包（Closure）</h2><p>何为闭包，闭包就是<strong>函数对象</strong>与<strong>外界变量</strong>绑定在一起，形成的整体。例如</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClosureTest1</span> &#123;</span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Lambda</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> y)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        highOrder(y -&gt; x + y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">highOrder</span><span class="params">(Lambda lambda)</span> &#123;</span><br><span class="line">        System.out.println(lambda.add(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码中的 $y \rightarrow x + y$ 和 $x &#x3D; 10$，就形成了一个闭包</li><li>可以想象成，函数对象有个背包，背包里可以装变量随身携带，将来函数对象甭管传递到多远的地方，包里总装着个 $x &#x3D; 10$</li><li>有个限制，局部变量 x 必须是 final 或 effective final 的，effective final 意思就是，虽然没有用 final 修饰，但就像是用 final 修饰了一样，不能重新赋值，否则就语法错误。<ul><li>意味着闭包变量，在装进包里的那一刻，就不能变化了</li><li>道理也简单，为了保证函数的不变性，防止破坏成道</li></ul></li><li>闭包是一种给函数执行提供数据的手段，函数执行既可以使用函数入参，还可以使用闭包变量</li></ul><p>例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClosureTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 闭包作用：给函数对象提供参数以外的数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建 10 个任务对象，并且每个任务对象给一个任务编号</span></span><br><span class="line">        List&lt;Runnable&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">task</span> </span><br><span class="line">                <span class="operator">=</span> () -&gt; System.out.println(Thread.currentThread()+<span class="string">&quot;:执行任务&quot;</span> + k);</span><br><span class="line">            list.add(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newVirtualThreadPerTaskExecutor();</span><br><span class="line">        <span class="keyword">for</span> (Runnable task : list) &#123;</span><br><span class="line">            service.submit(task);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="柯里化（Carrying）"><a href="#柯里化（Carrying）" class="headerlink" title="柯里化（Carrying）"></a>柯里化（Carrying）</h2><p>柯里化的作用是让函数对象分步执行（本质上是利用多个函数对象和闭包）</p><p>例如：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Carrying1Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        highOrder(a -&gt; b -&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">highOrder</span><span class="params">(Step1 step1)</span> &#123;</span><br><span class="line">        <span class="type">Step2</span> <span class="variable">step2</span> <span class="operator">=</span> step1.exec(<span class="number">10</span>);</span><br><span class="line">        System.out.println(step2.exec(<span class="number">20</span>));</span><br><span class="line">        System.out.println(step2.exec(<span class="number">50</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Step1</span> &#123;</span><br><span class="line">        Step2 <span class="title function_">exec</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Step2</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="title function_">exec</span><span class="params">(<span class="type">int</span> b)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中</p><ul><li>$a \rightarrow …$ 是第一个函数对象，它的返回结果  $b \rightarrow …$ 是第二个函数对象</li><li>后者与前面的参数 a 构成了闭包</li><li>step1.exec(10) 确定了 a 的值是 10，返回第二个函数对象 step2，a 被放入了 step2 对象的背包记下来了</li><li>step2.exec(20) 确定了 b 的值是 20，此时可以执行 a + b 的操作，得到结果 30</li><li>step2.exec(50) 分析过程类似</li></ul><h2 id="高阶函数（Higher-Order-Functions）"><a href="#高阶函数（Higher-Order-Functions）" class="headerlink" title="高阶函数（Higher-Order Functions）"></a>高阶函数（Higher-Order Functions）</h2><h3 id="1-内循环"><a href="#1-内循环" class="headerlink" title="1) 内循环"></a>1) 内循环</h3><h3 id="2-遍历二叉树"><a href="#2-遍历二叉树" class="headerlink" title="2) 遍历二叉树"></a>2) 遍历二叉树</h3><h3 id="3-简单流"><a href="#3-简单流" class="headerlink" title="3) 简单流"></a>3) 简单流</h3><h3 id="4-简单流-化简"><a href="#4-简单流-化简" class="headerlink" title="4) 简单流-化简"></a>4) 简单流-化简</h3><h3 id="5-简单流-收集"><a href="#5-简单流-收集" class="headerlink" title="5) 简单流-收集"></a>5) 简单流-收集</h3><h2 id="综合练习"><a href="#综合练习" class="headerlink" title="综合练习"></a>综合练习</h2><p>✅❌</p><h3 id="1）判断语法正确性"><a href="#1）判断语法正确性" class="headerlink" title="1）判断语法正确性"></a>1）判断语法正确性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Lambda1</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">op</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Lambda2</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">op</span><span class="params">(Object obj)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>Lambda1 lambda = a, b -&gt; a - b</code>  ❌</li><li><code>Lambda1 lambda = (c, d) -&gt; c * d</code> ✅</li><li><code>Lambda1 lambda = (int a, b) -&gt; a + b</code> ❌</li><li><code>Lambda2 lambda = Object a -&gt; System.out.println(a)</code> ❌</li></ol><h3 id="2）写出等价的-lambda-表达式"><a href="#2）写出等价的-lambda-表达式" class="headerlink" title="2）写出等价的 lambda 表达式"></a>2）写出等价的 lambda 表达式</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) o;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(name, student.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>Math::random</code>   </p><p><code>()-&gt;Math.random()</code></p></li><li><p><code>Math::sqrt</code></p><p><code>(double number)-&gt;Math.sqrt(number)</code></p></li><li><p><code>Student::getName</code></p><p><code>(Student stu)-&gt;stu.getName()</code></p></li><li><p><code>Student::setName</code></p><p><code>(Student stu, String newName) -&gt; stu.setName(newName)</code></p></li><li><p><code>Student::hashCode</code></p><p><code>(Student stu) -&gt; stu.hashCode()</code></p></li><li><p><code>Student::equals</code></p><p><code>(Student stu, Object o) -&gt; stu.equals(o)</code></p></li></ol><p>假设已有对象 <code>Student stu = new Student(&quot;张三&quot;);</code></p><ol><li><p><code>stu::getName</code></p><p><code>()-&gt;stu.getName()</code></p></li><li><p><code>stu::setName</code></p><p><code>(String newName)-&gt;stu.setName(newName)</code></p></li><li><p><code>Student::new</code></p><p><code>(String name)-&gt;new Student(name)</code></p></li></ol><h3 id="3）使用函数接口解决问题"><a href="#3）使用函数接口解决问题" class="headerlink" title="3）使用函数接口解决问题"></a>3）使用函数接口解决问题</h3><p>把下列方法中，可能存在变化的部分，抽象为函数对象，从外界传递进来</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">filter</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer number : list) &#123;</span><br><span class="line">        <span class="comment">// 筛选：判断是否是偶数，但以后可能改变判断规则</span></span><br><span class="line">        <span class="keyword">if</span>((number &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            result.add(number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;String&gt; <span class="title function_">map</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Integer number : list) &#123;</span><br><span class="line">        <span class="comment">// 转换：将数字转为字符串，但以后可能改变转换规则</span></span><br><span class="line">        result.add(String.valueOf(number));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (Integer number : list) &#123;</span><br><span class="line">        <span class="comment">// 消费：打印，但以后可能改变消费规则</span></span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">supply</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 生成：随机数，但以后可能改变生成规则</span></span><br><span class="line">        result.add(ThreadLocalRandom.current().nextInt());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4）写出等价的方法引用"><a href="#4）写出等价的方法引用" class="headerlink" title="4）写出等价的方法引用"></a>4）写出等价的方法引用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; lambda = (String s) -&gt; Integer.parseInt(s);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiPredicate&lt;List&lt;String&gt;, String&gt; lambda = (list, element) -&gt; list.contains(element);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BiPredicate&lt;Student, Object&gt; lambda = (stu, obj) -&gt; stu.equals(obj);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Predicate&lt;File&gt; lambda = (file) -&gt; file.exists();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">Supplier&lt;Long&gt; lambda = () -&gt; runtime.freeMemory();</span><br></pre></td></tr></table></figure><h3 id="5）补充代码"><a href="#5）补充代码" class="headerlink" title="5）补充代码"></a>5）补充代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Color</span><span class="params">(Integer red, Integer green, Integer blue)</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>如果想用 <code>Color::new</code> 来构造 Color 对象，还应当补充哪些代码</p><h3 id="6）实现需求"><a href="#6）实现需求" class="headerlink" title="6）实现需求"></a>6）实现需求</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">highOrder</span><span class="params">(Predicate&lt;Student&gt; predicate)</span> &#123;</span><br><span class="line">    List&lt;Student&gt; list = List.of(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">17</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">20</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">for</span> (Student stu : list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (predicate.test(stu)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;通过测试&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传入参数时，分别用</p><ul><li>类名::静态方法名</li><li>类名::非静态方法名</li></ul><p>来表示【学生年龄大于等于18】的条件</p><h1 id="三-Stream-API"><a href="#三-Stream-API" class="headerlink" title="三. Stream API"></a>三. Stream API</h1><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Fruit</span><span class="params">(String cname, String name, String category, String color)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">Stream.of(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;草莓&quot;</span>, <span class="string">&quot;Strawberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;红色&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;桑葚&quot;</span>, <span class="string">&quot;Mulberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;紫色&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;杨梅&quot;</span>, <span class="string">&quot;Waxberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;红色&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;核桃&quot;</span>, <span class="string">&quot;Walnut&quot;</span>, <span class="string">&quot;坚果&quot;</span>, <span class="string">&quot;棕色&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;草莓&quot;</span>, <span class="string">&quot;Peanut&quot;</span>, <span class="string">&quot;坚果&quot;</span>, <span class="string">&quot;棕色&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;蓝莓&quot;</span>, <span class="string">&quot;Blueberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;蓝色&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="/img/load.gif" data-original="/images/programmer/Java/b/1.png"></p><p>找到所有浆果</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.filter(f -&gt; f.category.equals(<span class="string">&quot;浆果&quot;</span>))</span><br></pre></td></tr></table></figure><p>找到蓝色的浆果</p><p>方法1：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.filter(f -&gt; f.category().equals(<span class="string">&quot;浆果&quot;</span>) &amp;&amp; f.color().equals(<span class="string">&quot;蓝色&quot;</span>))</span><br></pre></td></tr></table></figure><p>方法2：让每个 lambda 只做一件事，两次 filter 相对于并且关系</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.filter(f -&gt; f.category.equals(<span class="string">&quot;浆果&quot;</span>))</span><br><span class="line">.filter(f -&gt; f.color().equals(<span class="string">&quot;蓝色&quot;</span>))</span><br></pre></td></tr></table></figure><p>方法3：让每个 lambda 只做一件事，不过比方法2强的地方可以 or，and，nagate 运算</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.filter(((Predicate&lt;Fruit&gt;) f -&gt; f.category.equals(<span class="string">&quot;浆果&quot;</span>)).and(f -&gt; f.color().equals(<span class="string">&quot;蓝色&quot;</span>)))</span><br></pre></td></tr></table></figure><h2 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h2><p><img src="/img/load.gif" data-original="/images/programmer/Java/b/2.png"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.map(f -&gt; f.cname() + <span class="string">&quot;酱&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><p>例1</p><p><img src="/img/load.gif" data-original="/images/programmer/Java/b/image-20240301105938703.png" alt="image-20240301105938703"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(</span><br><span class="line">        List.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;草莓&quot;</span>, <span class="string">&quot;Strawberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;红色&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;桑葚&quot;</span>, <span class="string">&quot;Mulberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;紫色&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;杨梅&quot;</span>, <span class="string">&quot;Waxberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;红色&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;蓝莓&quot;</span>, <span class="string">&quot;Blueberry&quot;</span>, <span class="string">&quot;浆果&quot;</span>, <span class="string">&quot;蓝色&quot;</span>)</span><br><span class="line">        ),</span><br><span class="line">        List.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;核桃&quot;</span>, <span class="string">&quot;Walnut&quot;</span>, <span class="string">&quot;坚果&quot;</span>, <span class="string">&quot;棕色&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Fruit</span>(<span class="string">&quot;草莓&quot;</span>, <span class="string">&quot;Peanut&quot;</span>, <span class="string">&quot;坚果&quot;</span>, <span class="string">&quot;棕色&quot;</span>)</span><br><span class="line">        )</span><br><span class="line">)</span><br><span class="line">    </span><br><span class="line">.flatMap(Collection::stream)    </span><br></pre></td></tr></table></figure><ul><li>这样把坚果和浆果两个集合变成了含六个元素的水果流</li></ul><p>例2：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">1</span>, List.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">6499</span>, <span class="number">1</span>, <span class="string">&quot;HUAWEI MateBook 14s&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">6999</span>, <span class="number">1</span>, <span class="string">&quot;HUAWEI Mate 60 Pro&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">1488</span>, <span class="number">1</span>, <span class="string">&quot;HUAWEI WATCH GT 4&quot;</span>)</span><br><span class="line">        )),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">1</span>, List.of(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">8999</span>, <span class="number">1</span>, <span class="string">&quot;Apple MacBook Air 13&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">7999</span>, <span class="number">1</span>, <span class="string">&quot;Apple iPhone 15 Pro&quot;</span>),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Item</span>(<span class="number">2999</span>, <span class="number">1</span>, <span class="string">&quot;Apple Watch Series 9&quot;</span>)</span><br><span class="line">        ))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>想逐一处理每个订单中的商品</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.flatMap(order -&gt; order.items().stream())</span><br></pre></td></tr></table></figure><p>这样把一个有两个元素的订单流，变成了一个有六个元素的商品流</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>根据已有的数组构建流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.stream(array)</span><br></pre></td></tr></table></figure><p>根据已有的 Collection 构建流（包括 List，Set 等）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>).stream()</span><br></pre></td></tr></table></figure><p>把一个对象变成流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;d&quot;</span>)</span><br></pre></td></tr></table></figure><p>把多个对象变成流</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;y&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><p>两个流拼接</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.concat(Stream.of(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>), Stream.of(<span class="string">&quot;d&quot;</span>))</span><br></pre></td></tr></table></figure><h2 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.concat(Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>), Stream.of(<span class="string">&quot;d&quot;</span>))</span><br><span class="line">    .skip(<span class="number">1</span>)</span><br><span class="line">    .limit(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li><p>skip 是跳过几个元素</p></li><li><p>limit 是限制处理的元素个数</p></li><li><p>dropWhile 是 drop 流中元素，直到条件不成立，留下剩余元素</p></li><li><p>takeWhile 是 take 流中元素，直到条件不成立，舍弃剩余元素</p></li></ul><h2 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h2><p>生成从 0 ~ 9 的数字</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.range(<span class="number">0</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.rangeClosed(<span class="number">0</span>, <span class="number">9</span>)</span><br></pre></td></tr></table></figure><p>如果想订制，可以用 iterate 方法，例如下面生成奇数序列</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>参数1 是初始值</li><li>参数2 是一个特殊 Function，即参数类型与返回值相同，它会根据上一个元素 x 的值计算出当前元素</li><li>需要用 limit 限制元素个数</li></ul><p>也可以用 iterate 的重载方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IntStream.iterate(<span class="number">1</span>, x -&gt; x &lt; <span class="number">10</span>, x -&gt; x + <span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>参数1 是初始值</li><li>参数2 用来限制元素个数，一旦不满足此条件，流就结束</li><li>参数3 相当于上个方法的参数2</li></ul><p>iterate 的特点是根据上一个元素计算当前元素，如果不需要依赖上一个元素，可以改用 generate 方法</p><p>例如下面是生成 5 个随机 int</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.generate(()-&gt; ThreadLocalRandom.current().nextInt()).limit(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>不过如果只是生成随机数的话，有更简单的办法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalRandom.current().ints(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>如果要指定上下限，例如下面是生成从 0~9 的100个随机数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalRandom.current().ints(<span class="number">100</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="查找与判断"><a href="#查找与判断" class="headerlink" title="查找与判断"></a>查找与判断</h2><p>下面的代码找到流中任意（Any）一个偶数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line">Arrays.stream(array)</span><br><span class="line">    .filter(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br><span class="line">    .findAny()</span><br><span class="line">    .ifPresent(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>注意 findAny 返回的是 OptionalInt 对象，因为可能流中不存在偶数</li><li>对于 OptionalInt 对象，一般需要用 ifPresent 或 orElse（提供默认值）来处理</li></ul><p>与 findAny 比较类似的是 firstFirst，它俩的区别</p><ul><li>findAny 是找在流中任意位置的元素，不需要考虑顺序，对于上例返回 6 也是可以的</li><li>findFirst 是找第一个出现在元素，需要考虑顺序，对于上例只能返回 4</li><li>findAny 在顺序流中与 findFirst 表现相同，区别在于并行流下会更快</li></ul><p>判断流中是否存在任意一个偶数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.stream(array).anyMatch(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>它返回的是 boolean 值，可以直接用来判断</li></ul><p>判断流是否全部是偶数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.stream(array).allMatch(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>同样，它返回的是 boolean 值，可以直接用来判断</li></ul><p>判断流是否全部不是偶数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arrays.stream(array).noneMatch(x -&gt; (x &amp; <span class="number">1</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>noneMatch 与 allMatch 含义恰好相反</li></ul><h2 id="排序与去重"><a href="#排序与去重" class="headerlink" title="排序与去重"></a>排序与去重</h2><p>已知有数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Hero</span><span class="params">(String name, <span class="type">int</span> strength)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">Stream.of(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;独孤求败&quot;</span>, <span class="number">100</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;令狐冲&quot;</span>, <span class="number">90</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;风清扬&quot;</span>, <span class="number">98</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;东方不败&quot;</span>, <span class="number">98</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;方证&quot;</span>, <span class="number">92</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;任我行&quot;</span>, <span class="number">92</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;冲虚&quot;</span>, <span class="number">90</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;向问天&quot;</span>, <span class="number">88</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Hero</span>(<span class="string">&quot;不戒&quot;</span>, <span class="number">88</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>要求，首先按 strength 武力排序（逆序），武力相同的，按姓名长度排序（正序）</p><p>仅用 lambda 来解</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.sorted((a,b)-&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.compare(b.strength(), a.strength());</span><br><span class="line">    <span class="keyword">return</span> (res == <span class="number">0</span>) ? Integer.compare(a.nameLength(), b.nameLength()) : res; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>方法引用改写</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.sorted(</span><br><span class="line">    Comparator.comparingInt(Hero::strength)</span><br><span class="line">      .reversed()</span><br><span class="line">      .thenComparingInt(Hero::nameLength)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>comparingInt 接收一个 key 提取器（说明按对象中哪部分来比较），返回一个比较器</li><li>reversed 返回一个顺序相反的比较器</li><li>thenComparingInt 接收一个 key 提取器，返回一个新比较器，新比较器在原有比较器结果相等时执行新的比较逻辑</li></ul><p>增加一个辅助方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">record</span> <span class="title class_">Hero</span><span class="params">(String name, <span class="type">int</span> strength)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">nameLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.sorted((e, f) -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span></span><br><span class="line">        ((Comparator&lt;Hero&gt;) (c, d) -&gt;</span><br><span class="line">            ((Comparator&lt;Hero&gt;) (a, b) -&gt; Integer.compare(a.strength(), b.strength()))</span><br><span class="line">                .compare(d, c))</span><br><span class="line">            .compare(e, f);</span><br><span class="line">    <span class="keyword">return</span> (res == <span class="number">0</span>) ? Integer.compare(e.nameLength(), f.nameLength()) : res;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果不好看，改成下面的代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.sorted(step3(step2(step1())))</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Comparator&lt;Hero&gt; <span class="title function_">step1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a, b) -&gt; Integer.compare(a.strength(), b.strength());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Comparator&lt;Hero&gt; <span class="title function_">step2</span><span class="params">(Comparator&lt;Hero&gt; step1)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (c, d) -&gt; step1.compare(d, c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Comparator&lt;Hero&gt; <span class="title function_">step3</span><span class="params">(Comparator&lt;Hero&gt; step2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (e, f) -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> step2.compare(e, f);</span><br><span class="line">        <span class="keyword">return</span> (res == <span class="number">0</span>) ? Integer.compare(e.nameLength(), f.nameLength()) : res;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="化简"><a href="#化简" class="headerlink" title="化简"></a>化简</h2><p><code>reduce(init, (p,x) -&gt; r)</code></p><ul><li>init 代表初始值</li><li><code>(p,x) -&gt; r</code> 是一个 BinaryOperator，作用是根据上次化简结果 p 和当前元素 x，得到本次化简结果 r</li></ul><p>这样两两化简，可以将流中的所有元素合并成一个结果</p><h2 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h2><p>collect( supplier, accumulator, combiner)</p><ul><li>supplier 是描述如何创建收集容器 c ：<code>()-&gt; c</code></li><li>accumulator 是描述如何向容器 c 添加元素 x：<code>(c, x) -&gt; void</code></li><li>combiner 是描述如何合并两个容器：<code>(c1, c2) -&gt; void</code><ul><li>串行流下不需要合并容器</li><li>并行流如果用的是并发容器，也不需要合并</li></ul></li></ul><h2 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h2><p>Collectors 类中提供了很多现成的收集器，详情见网页</p><h2 id="下游收集器"><a href="#下游收集器" class="headerlink" title="下游收集器"></a>下游收集器</h2><p>做 groupingBy 分组收集时，组内可能需要进一步的数据收集，称为下游收集器，详情见网页</p><h2 id="基本流"><a href="#基本流" class="headerlink" title="基本流"></a>基本流</h2><p>基本类型流指 IntStream、LongStream 和 DoubleStream，它们在做数值计算时有更好的性能。</p><p>转换成基本流</p><ul><li>mapToInt</li><li>mapToLong</li><li>mapToDouble</li><li>flatMapToInt</li><li>flatMapToLong</li><li>flatMapToDouble</li><li>mapMultiToInt</li><li>mapMultiToLong</li><li>mapMultiToDouble</li></ul><p>基本流转对象流</p><ul><li>mapToObj</li><li>boxed</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>一次使用：流只能使用一次（终结方法只能调用一次）</li><li>两类操作：<ol><li>中间操作，lazy 懒惰的</li><li>终结操作，eager 迫切的</li></ol></li></ol><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    .parallel()</span><br><span class="line">    .collect(Collector.of(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%-12s %s%n&quot;</span>,simple(),<span class="string">&quot;create&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            &#125;,</span><br><span class="line">            (list, x) -&gt; &#123;</span><br><span class="line">                List&lt;Integer&gt; old = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">                list.add(x);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%-12s %s.add(%d)=&gt;%s%n&quot;</span>,simple(), old, x, list);</span><br><span class="line">            &#125;,</span><br><span class="line">            (list1, list2) -&gt; &#123;</span><br><span class="line">                List&lt;Integer&gt; old = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list1);</span><br><span class="line">                list1.addAll(list2);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%-12s %s.add(%s)=&gt;%s%n&quot;</span>, simple(),old, list2, list1);</span><br><span class="line">                <span class="keyword">return</span> list1;</span><br><span class="line">            &#125;,</span><br><span class="line">            list -&gt; list,</span><br><span class="line">            Collector.Characteristics.IDENTITY_FINISH</span><br><span class="line">    ));</span><br></pre></td></tr></table></figure><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><h3 id="1-数组求和"><a href="#1-数组求和" class="headerlink" title="1) 数组求和"></a>1) 数组求和</h3><p>其中</p><ul><li>primitive 用 loop 循环对 int 求和</li><li>intStream 用 IntStream 对 int 求和</li><li>boxed 用 loop 循环对 Integer 求和</li><li>stream 用 Stream 对 Integer 求和</li></ul><p>元素个数 100</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns&#x2F;op)</th><th>Error (ns&#x2F;op)</th><th>Units</th></tr></thead><tbody><tr><td>T01Sum.primitive</td><td>avgt</td><td>5</td><td>25.424</td><td>± 0.782</td><td>ns&#x2F;op</td></tr><tr><td>T01Sum.intStream</td><td>avgt</td><td>5</td><td>47.482</td><td>± 1.145</td><td>ns&#x2F;op</td></tr><tr><td>T01Sum.boxed</td><td>avgt</td><td>5</td><td>72.457</td><td>± 4.136</td><td>ns&#x2F;op</td></tr><tr><td>T01Sum.stream</td><td>avgt</td><td>5</td><td>465.141</td><td>± 4.891</td><td>ns&#x2F;op</td></tr></tbody></table><p>元素个数 1000</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns&#x2F;op)</th><th>Error (ns&#x2F;op)</th><th>Units</th></tr></thead><tbody><tr><td>T01Sum.primitive</td><td>avgt</td><td>5</td><td>270.556</td><td>± 1.277</td><td>ns&#x2F;op</td></tr><tr><td>T01Sum.intStream</td><td>avgt</td><td>5</td><td>292.467</td><td>± 10.987</td><td>ns&#x2F;op</td></tr><tr><td>T01Sum.boxed</td><td>avgt</td><td>5</td><td>583.929</td><td>± 57.338</td><td>ns&#x2F;op</td></tr><tr><td>T01Sum.stream</td><td>avgt</td><td>5</td><td>5948.294</td><td>± 2209.211</td><td>ns&#x2F;op</td></tr></tbody></table><p>元素个数 10000</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns&#x2F;op)</th><th>Error (ns&#x2F;op)</th><th>Units</th></tr></thead><tbody><tr><td>T01Sum.primitive</td><td>avgt</td><td>5</td><td>2681.651</td><td>± 12.614</td><td>ns&#x2F;op</td></tr><tr><td>T01Sum.intStream</td><td>avgt</td><td>5</td><td>2718.408</td><td>± 52.418</td><td>ns&#x2F;op</td></tr><tr><td>T01Sum.boxed</td><td>avgt</td><td>5</td><td>6391.285</td><td>± 358.154</td><td>ns&#x2F;op</td></tr><tr><td>T01Sum.stream</td><td>avgt</td><td>5</td><td>44414.884</td><td>± 3213.055</td><td>ns&#x2F;op</td></tr></tbody></table><p>结论：</p><ul><li>做数值计算，优先挑选基本流（IntStream 等）在数据量较大时，它的性能已经非常接近普通 for 循环</li><li>做数值计算，应当避免普通流（Stream）性能与其它几种相比，慢一个数量级</li></ul><h3 id="2-求最大值"><a href="#2-求最大值" class="headerlink" title="2) 求最大值"></a>2) 求最大值</h3><p>其中（原始数据都是 int，没有包装类）</p><ul><li>custom 自定义多线程并行求最大值</li><li>parallel 并行流求最大值</li><li>sequence 串行流求最大值</li><li>primitive loop 循环求最大值</li></ul><p>元素个数 100</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns&#x2F;op)</th><th>Error (ns&#x2F;op)</th><th>Units</th></tr></thead><tbody><tr><td>T02Parallel.custom</td><td>avgt</td><td>5</td><td>39619.796</td><td>± 1263.036</td><td>ns&#x2F;op</td></tr><tr><td>T02Parallel.parallel</td><td>avgt</td><td>5</td><td>6754.239</td><td>± 79.894</td><td>ns&#x2F;op</td></tr><tr><td>T02Parallel.primitive</td><td>avgt</td><td>5</td><td>29.538</td><td>± 3.056</td><td>ns&#x2F;op</td></tr><tr><td>T02Parallel.sequence</td><td>avgt</td><td>5</td><td>80.170</td><td>± 1.940</td><td>ns&#x2F;op</td></tr></tbody></table><p>元素个数 10000</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns&#x2F;op)</th><th>Error (ns&#x2F;op)</th><th>Units</th></tr></thead><tbody><tr><td>T02Parallel.custom</td><td>avgt</td><td>5</td><td>41656.093</td><td>± 1537.237</td><td>ns&#x2F;op</td></tr><tr><td>T02Parallel.parallel</td><td>avgt</td><td>5</td><td>11218.573</td><td>± 1994.863</td><td>ns&#x2F;op</td></tr><tr><td>T02Parallel.primitive</td><td>avgt</td><td>5</td><td>2217.562</td><td>± 80.981</td><td>ns&#x2F;op</td></tr><tr><td>T02Parallel.sequence</td><td>avgt</td><td>5</td><td>5682.482</td><td>± 264.645</td><td>ns&#x2F;op</td></tr></tbody></table><p>元素个数 1000000</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns&#x2F;op)</th><th>Error (ns&#x2F;op)</th><th>Units</th></tr></thead><tbody><tr><td>T02Parallel.custom</td><td>avgt</td><td>5</td><td>194984.564</td><td>± 25794.484</td><td>ns&#x2F;op</td></tr><tr><td>T02Parallel.parallel</td><td>avgt</td><td>5</td><td>298940.794</td><td>± 31944.959</td><td>ns&#x2F;op</td></tr><tr><td>T02Parallel.primitive</td><td>avgt</td><td>5</td><td>325178.873</td><td>± 81314.981</td><td>ns&#x2F;op</td></tr><tr><td>T02Parallel.sequence</td><td>avgt</td><td>5</td><td>618274.062</td><td>± 5867.812</td><td>ns&#x2F;op</td></tr></tbody></table><p>结论：</p><ul><li>并行流相对自己用多线程实现分而治之更简洁</li><li>并行流只有在数据量非常大时，才能充分发力，数据量少，还不如用串行流</li></ul><h3 id="3-并行-发-收集"><a href="#3-并行-发-收集" class="headerlink" title="3) 并行(发)收集"></a>3) 并行(发)收集</h3><p>元素个数 100</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns&#x2F;op)</th><th>Error (ns&#x2F;op)</th><th>Units</th></tr></thead><tbody><tr><td>loop1</td><td>avgt</td><td>5</td><td>1312.389</td><td>±  90.683</td><td>ns&#x2F;op</td></tr><tr><td>loop2</td><td>avgt</td><td>5</td><td>1776.391</td><td>± 255.271</td><td>ns&#x2F;op</td></tr><tr><td>sequence</td><td>avgt</td><td>5</td><td>1727.739</td><td>±  28.821</td><td>ns&#x2F;op</td></tr><tr><td>parallelNoConcurrent</td><td>avgt</td><td>5</td><td>27654.004</td><td>± 496.970</td><td>ns&#x2F;op</td></tr><tr><td>parallelConcurrent</td><td>avgt</td><td>5</td><td>16320.113</td><td>± 344.766</td><td>ns&#x2F;op</td></tr></tbody></table><p>元素个数 10000</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ns&#x2F;op)</th><th>Error (ns&#x2F;op)</th><th>Units</th></tr></thead><tbody><tr><td>loop1</td><td>avgt</td><td>5</td><td>211526.546</td><td>± 13549.703</td><td>ns&#x2F;op</td></tr><tr><td>loop2</td><td>avgt</td><td>5</td><td>203794.146</td><td>± 3525.972</td><td>ns&#x2F;op</td></tr><tr><td>sequence</td><td>avgt</td><td>5</td><td>237688.651</td><td>±  7593.483</td><td>ns&#x2F;op</td></tr><tr><td>parallelNoConcurrent</td><td>avgt</td><td>5</td><td>527203.976</td><td>±  3496.107</td><td>ns&#x2F;op</td></tr><tr><td>parallelConcurrent</td><td>avgt</td><td>5</td><td>369630.728</td><td>± 20549.731</td><td>ns&#x2F;op</td></tr></tbody></table><p>元素个数 1000000</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score (ms&#x2F;op)</th><th>Error (ms&#x2F;op)</th><th>Units</th></tr></thead><tbody><tr><td>loop1</td><td>avgt</td><td>5</td><td>69.154</td><td>± 3.456</td><td>ms&#x2F;op</td></tr><tr><td>loop2</td><td>avgt</td><td>5</td><td>83.815</td><td>± 2.307</td><td>ms&#x2F;op</td></tr><tr><td>sequence</td><td>avgt</td><td>5</td><td>103.585</td><td>± 0.834</td><td>ns&#x2F;op</td></tr><tr><td>parallelNoConcurrent</td><td>avgt</td><td>5</td><td>167.032</td><td>± 15.406</td><td>ms&#x2F;op</td></tr><tr><td>parallelConcurrent</td><td>avgt</td><td>5</td><td>52.326</td><td>± 1.501</td><td>ms&#x2F;op</td></tr></tbody></table><p>结论：</p><ul><li>sequence 是一个容器单线程收集，数据量少时性能占优</li><li>parallelNoConcurrent 是多个容器多线程并行收集，时间应该花费在合并容器上，性能最差</li><li>parallelConcurrent 是一个容器多线程并发收集，在数据量大时性能较优</li></ul><h3 id="4）MethodHandle-性能"><a href="#4）MethodHandle-性能" class="headerlink" title="4）MethodHandle 性能"></a>4）MethodHandle 性能</h3><p>正常方法调用、反射、MethodHandle、Lambda 的性能对比</p><table><thead><tr><th>Benchmark</th><th>Mode</th><th>Cnt</th><th>Score</th><th>Error</th><th>Units</th></tr></thead><tbody><tr><td>Sample2.lambda</td><td>thrpt</td><td>5</td><td>389307532.881</td><td>± 332213073.039</td><td>ops&#x2F;s</td></tr><tr><td>Sample2.method</td><td>thrpt</td><td>5</td><td>157556577.611</td><td>± 4048306.620</td><td>ops&#x2F;s</td></tr><tr><td>Sample2.origin</td><td>thrpt</td><td>5</td><td>413287866.949</td><td>± 65182730.966</td><td>ops&#x2F;s</td></tr><tr><td>Sample2.reflection</td><td>thrpt</td><td>5</td><td>91640751.456</td><td>± 37969233.369</td><td>ops&#x2F;s</td></tr></tbody></table><h2 id="综合练习-1"><a href="#综合练习-1" class="headerlink" title="综合练习"></a>综合练习</h2><ol><li><p>将 filter 的课堂例题修改为方法引用方式实现</p></li><li><p>takeWhile 与 filter 的区别</p></li><li><p>三级排序</p></li><li><p>包含 null 值的排序</p></li><li><p>二维流扁平映射</p></li><li><p>三维流扁平映射</p></li><li><p>用 stream 打印九九乘法表</p></li><li><p>用 stream 生成斐波那契数列的前 10 项</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream.iterate(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, x -&gt; <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x[<span class="number">1</span>], x[<span class="number">0</span>] + x[<span class="number">1</span>]&#125;)</span><br><span class="line">    .map(x -&gt; x[<span class="number">0</span>])</span><br><span class="line">    .limit(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></li><li><p>自定义 Collector 求平均</p></li></ol><h1 id="四-实际应用"><a href="#四-实际应用" class="headerlink" title="四. 实际应用"></a>四. 实际应用</h1><h2 id="数据统计分析"><a href="#数据统计分析" class="headerlink" title="数据统计分析"></a>数据统计分析</h2><h3 id="1）每月的销售量"><a href="#1）每月的销售量" class="headerlink" title="1）每月的销售量"></a>1）每月的销售量</h3><p>结果应为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1970-01 订单数1307</span><br><span class="line">2020-01 订单数14270</span><br><span class="line">2020-02 订单数17995</span><br><span class="line">2020-03 订单数18688</span><br><span class="line">2020-04 订单数11868</span><br><span class="line">2020-05 订单数40334</span><br><span class="line">2020-06 订单数41364</span><br><span class="line">2020-07 订单数76418</span><br><span class="line">2020-08 订单数100007</span><br><span class="line">2020-09 订单数70484</span><br><span class="line">2020-10 订单数104063</span><br><span class="line">2020-11 订单数66060</span><br></pre></td></tr></table></figure><ul><li>其中 1970-01 应该是数据的问题</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .collect(groupingBy(a -&gt; YearMonth.from(formatter.parse(a[TIME])), </span><br><span class="line">                        TreeMap::<span class="keyword">new</span>, counting()))</span><br><span class="line">    .forEach((k, v) -&gt; &#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot; 订单数 &quot;</span> + v);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="2）销量最高的月份"><a href="#2）销量最高的月份" class="headerlink" title="2）销量最高的月份"></a>2）销量最高的月份</h3><p>结果应为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1970-01 订单数1307</span><br><span class="line">2020-01 订单数14270</span><br><span class="line">2020-02 订单数17995</span><br><span class="line">2020-03 订单数18688</span><br><span class="line">2020-04 订单数11868</span><br><span class="line">2020-05 订单数40334</span><br><span class="line">2020-06 订单数41364</span><br><span class="line">2020-07 订单数76418</span><br><span class="line">2020-08 订单数100007</span><br><span class="line">2020-09 订单数70484</span><br><span class="line">2020-10 订单数104063  *</span><br><span class="line">2020-11 订单数66060</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .collect(groupingBy(a -&gt; YearMonth.from(formatter.parse(a[TIME])), counting()))</span><br><span class="line">    .entrySet()</span><br><span class="line">    .stream()</span><br><span class="line">    .max(Comparator.comparingLong(Map.Entry::getValue))</span><br><span class="line">    <span class="comment">// 也可以用 Map.Entry.comparingByValue()</span></span><br><span class="line">    .orElse(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="3）求销量最高的商品"><a href="#3）求销量最高的商品" class="headerlink" title="3）求销量最高的商品"></a>3）求销量最高的商品</h3><p>结果应为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1515966223517846928=2746</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .collect(groupingBy(a -&gt; a[PRODUCT_ID], counting()))</span><br><span class="line">    .entrySet()</span><br><span class="line">    .stream()</span><br><span class="line">    .max(Comparator.comparingLong(Map.Entry::getValue))</span><br><span class="line">    .orElse(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="4）下单最多的前10用户"><a href="#4）下单最多的前10用户" class="headerlink" title="4）下单最多的前10用户"></a>4）下单最多的前10用户</h3><p>结果应为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.515915625512423e+18 订单数1092</span><br><span class="line">1.5159156255121183e+18 订单数1073</span><br><span class="line">1.515915625512378e+18 订单数1040</span><br><span class="line">1.515915625512377e+18 订单数1028</span><br><span class="line">1.5159156255136955e+18 订单数1002</span><br><span class="line">1.515915625512422e+18 订单数957</span><br><span class="line">1.515915625513446e+18 订单数957</span><br><span class="line">1.515915625513447e+18 订单数928</span><br><span class="line">1.515915625514598e+18 订单数885</span><br><span class="line">1.5159156255147195e+18 订单数869</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .collect(groupingBy(a -&gt; a[USER_ID], counting()))</span><br><span class="line">    .entrySet()</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted(Map.Entry.&lt;String, Long&gt;comparingByValue().reversed())</span><br><span class="line">    .limit(<span class="number">10</span>).forEach(e -&gt; &#123;</span><br><span class="line">        System.out.println(e.getKey() + <span class="string">&quot; 订单数 &quot;</span> + e.getValue());</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyQueue</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">PriorityQueue</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">(Comparator&lt;? <span class="built_in">super</span> E&gt; comparator, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(comparator);</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">r</span> <span class="operator">=</span> <span class="built_in">super</span>.offer(e);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.size() &gt; max) &#123;</span><br><span class="line">            <span class="built_in">this</span>.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .collect(groupingBy(a -&gt; a[USER_ID], counting()))</span><br><span class="line">    .entrySet()</span><br><span class="line">    .stream()</span><br><span class="line">    .parallel()</span><br><span class="line">    .collect(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> <span class="title class_">MyQueue</span>&lt;&gt;(Map.Entry.comparingByValue(), <span class="number">10</span>),</span><br><span class="line">            MyQueue::offer,</span><br><span class="line">            AbstractQueue::addAll</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><h3 id="5-1）每个地区下单最多的用户"><a href="#5-1）每个地区下单最多的用户" class="headerlink" title="5.1）每个地区下单最多的用户"></a>5.1）每个地区下单最多的用户</h3><p>结果应为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上海=Optional[1.5159156255127636e+18=634]</span><br><span class="line">广东=Optional[1.515915625512377e+18=1028]</span><br><span class="line">天津=Optional[1.5159156255120858e+18=530]</span><br><span class="line">四川=Optional[1.5159156255121551e+18=572]</span><br><span class="line">浙江=Optional[1.5159156255121183e+18=564]</span><br><span class="line">重庆=Optional[1.515915625512764e+18=632]</span><br><span class="line">湖北=Optional[1.5159156255121183e+18=509]</span><br><span class="line">湖南=Optional[1.5159156255120548e+18=545]</span><br><span class="line">江苏=Optional[1.5159156255122386e+18=551]</span><br><span class="line">海南=Optional[1.5159156255121178e+18=556]</span><br><span class="line">北京=Optional[1.5159156255128172e+18=584]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(line -&gt; line.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .collect(groupingBy(array -&gt; array[USER_REGION], </span><br><span class="line">                        groupingBy(array -&gt; array[USER_ID], counting())))</span><br><span class="line">    .entrySet().stream()</span><br><span class="line">    .map(e -&gt; Map.entry(</span><br><span class="line">            e.getKey(),</span><br><span class="line">            e.getValue().entrySet().stream().max(Map.Entry.comparingByValue())</span><br><span class="line">    ))</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="5-2）每个地区下单最多的前3用户"><a href="#5-2）每个地区下单最多的前3用户" class="headerlink" title="5.2）每个地区下单最多的前3用户"></a>5.2）每个地区下单最多的前3用户</h3><p>结果应为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">上海</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255127636e+18=634</span><br><span class="line">1.515915625512118e+18=583</span><br><span class="line">1.515915625512422e+18=561</span><br><span class="line">广东</span><br><span class="line">--------------------------</span><br><span class="line">1.515915625512377e+18=1028</span><br><span class="line">1.5159156255121544e+18=572</span><br><span class="line">1.5159156255120845e+18=571</span><br><span class="line">天津</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255120858e+18=530</span><br><span class="line">1.5159156255122383e+18=504</span><br><span class="line">1.5159156255123333e+18=481</span><br><span class="line">四川</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255121551e+18=572</span><br><span class="line">1.5159156255123768e+18=568</span><br><span class="line">1.515915625512055e+18=552</span><br><span class="line">浙江</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255121183e+18=564</span><br><span class="line">1.515915625513058e+18=520</span><br><span class="line">1.515915625512423e+18=513</span><br><span class="line">重庆</span><br><span class="line">--------------------------</span><br><span class="line">1.515915625512764e+18=632</span><br><span class="line">1.5159156255121188e+18=572</span><br><span class="line">1.515915625512085e+18=562</span><br><span class="line">湖北</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255121183e+18=509</span><br><span class="line">1.515915625512818e+18=508</span><br><span class="line">1.5159156255148017e+18=386</span><br><span class="line">湖南</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255120548e+18=545</span><br><span class="line">1.5159156255120855e+18=543</span><br><span class="line">1.5159156255134449e+18=511</span><br><span class="line">江苏</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255122386e+18=551</span><br><span class="line">1.5159156255122842e+18=541</span><br><span class="line">1.5159156255120842e+18=499</span><br><span class="line">海南</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255121178e+18=556</span><br><span class="line">1.5159156255128174e+18=547</span><br><span class="line">1.5159156255122022e+18=545</span><br><span class="line">北京</span><br><span class="line">--------------------------</span><br><span class="line">1.5159156255128172e+18=584</span><br><span class="line">1.515915625512423e+18=579</span><br><span class="line">1.5159156255123786e+18=558</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .collect(groupingBy(a -&gt; a[USER_REGION], groupingBy(a -&gt; a[USER_ID], counting())))</span><br><span class="line">    <span class="comment">/*.forEach((k,v)-&gt;&#123;</span></span><br><span class="line"><span class="comment">        System.out.println(k);</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;---------------&quot;);</span></span><br><span class="line"><span class="comment">        v.forEach((x,y)-&gt;&#123;</span></span><br><span class="line"><span class="comment">            System.out.println(x + &quot;:&quot; + y);</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">    &#125;);*/</span></span><br><span class="line">    .entrySet()</span><br><span class="line">    .stream()</span><br><span class="line">    .map(e -&gt;</span><br><span class="line">        Map.entry(</span><br><span class="line">            e.getKey(),</span><br><span class="line">            e.getValue().entrySet().stream()</span><br><span class="line">                .sorted(Map.Entry.&lt;String, Long&gt;comparingByValue().reversed())</span><br><span class="line">            .limit(<span class="number">3</span>)</span><br><span class="line">            .toList()</span><br><span class="line">        )</span><br><span class="line">    ).forEach(e -&gt; &#123;</span><br><span class="line">        System.out.println(e.getKey());</span><br><span class="line">        System.out.println(<span class="string">&quot;--------------------------&quot;</span>);</span><br><span class="line">        e.getValue().forEach(System.out::println);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="6-1）按类别统计销量"><a href="#6-1）按类别统计销量" class="headerlink" title="6.1）按类别统计销量"></a>6.1）按类别统计销量</h3><p>结果应为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accessories.bag 订单数 3063</span><br><span class="line">accessories.umbrella 订单数 33</span><br><span class="line">apparel.costume 订单数 2</span><br><span class="line">apparel.glove 订单数 1942</span><br><span class="line">apparel.shirt 订单数 235</span><br><span class="line">apparel.shoes 订单数 2</span><br><span class="line">apparel.sock 订单数 21</span><br><span class="line">apparel.trousers 订单数 99</span><br><span class="line">apparel.tshirt 订单数 372</span><br><span class="line">appliances.environment.air_conditioner 订单数 7379</span><br><span class="line">appliances.environment.air_heater 订单数 2599</span><br><span class="line">appliances.environment.climate 订单数 101</span><br><span class="line">appliances.environment.fan 订单数 3855</span><br><span class="line">appliances.environment.vacuum 订单数 15971</span><br><span class="line">appliances.environment.water_heater 订单数 3644</span><br><span class="line">appliances.iron 订单数 8249</span><br><span class="line">appliances.ironing_board 订单数 2128</span><br><span class="line">appliances.kitchen.blender 订单数 8672</span><br><span class="line">appliances.kitchen.coffee_grinder 订单数 811</span><br><span class="line">appliances.kitchen.coffee_machine 订单数 1250</span><br><span class="line">appliances.kitchen.dishwasher 订单数 2663</span><br><span class="line">appliances.kitchen.fryer 订单数 97</span><br><span class="line">appliances.kitchen.grill 订单数 1579</span><br><span class="line">appliances.kitchen.hood 订单数 9045</span><br><span class="line">appliances.kitchen.juicer 订单数 1187</span><br><span class="line">appliances.kitchen.kettle 订单数 12740</span><br><span class="line">appliances.kitchen.meat_grinder 订单数 4520</span><br><span class="line">appliances.kitchen.microwave 订单数 7615</span><br><span class="line">appliances.kitchen.mixer 订单数 2610</span><br><span class="line">appliances.kitchen.oven 订单数 4000</span><br><span class="line">appliances.kitchen.refrigerators 订单数 20259</span><br><span class="line">appliances.kitchen.steam_cooker 订单数 464</span><br><span class="line">appliances.kitchen.toster 订单数 1381</span><br><span class="line">appliances.kitchen.washer 订单数 14563</span><br><span class="line">appliances.personal.hair_cutter 订单数 2716</span><br><span class="line">appliances.personal.massager 订单数 1724</span><br><span class="line">appliances.personal.scales 订单数 6727</span><br><span class="line">appliances.sewing_machine 订单数 1576</span><br><span class="line">appliances.steam_cleaner 订单数 119</span><br><span class="line">auto.accessories.alarm 订单数 252</span><br><span class="line">auto.accessories.anti_freeze 订单数 109</span><br><span class="line">auto.accessories.compressor 订单数 276</span><br><span class="line">auto.accessories.player 订单数 117</span><br><span class="line">auto.accessories.radar 订单数 80</span><br><span class="line">auto.accessories.videoregister 订单数 533</span><br><span class="line">computers.components.cdrw 订单数 158</span><br><span class="line">computers.components.cooler 订单数 3377</span><br><span class="line">computers.components.cpu 订单数 4147</span><br><span class="line">computers.components.hdd 订单数 5054</span><br><span class="line">computers.components.memory 订单数 1597</span><br><span class="line">computers.components.motherboard 订单数 860</span><br><span class="line">computers.components.power_supply 订单数 986</span><br><span class="line">computers.components.sound_card 订单数 26</span><br><span class="line">computers.components.videocards 订单数 1190</span><br><span class="line">computers.desktop 订单数 1041</span><br><span class="line">computers.ebooks 订单数 397</span><br><span class="line">computers.gaming 订单数 164</span><br><span class="line">computers.network.router 订单数 6473</span><br><span class="line">computers.notebook 订单数 25866</span><br><span class="line">computers.peripherals.camera 订单数 1041</span><br><span class="line">computers.peripherals.joystick 订单数 1192</span><br><span class="line">computers.peripherals.keyboard 订单数 3803</span><br><span class="line">computers.peripherals.monitor 订单数 3272</span><br><span class="line">computers.peripherals.mouse 订单数 12664</span><br><span class="line">computers.peripherals.printer 订单数 3458</span><br><span class="line">computers.peripherals.scanner 订单数 74</span><br><span class="line">construction.components.faucet 订单数 133</span><br><span class="line">construction.tools.drill 订单数 622</span><br><span class="line">construction.tools.generator 订单数 46</span><br><span class="line">construction.tools.heater 订单数 348</span><br><span class="line">construction.tools.light 订单数 10</span><br><span class="line">construction.tools.pump 订单数 65</span><br><span class="line">construction.tools.saw 订单数 169</span><br><span class="line">construction.tools.screw 订单数 2408</span><br><span class="line">construction.tools.welding 订单数 183</span><br><span class="line">country_yard.cultivator 订单数 33</span><br><span class="line">country_yard.lawn_mower 订单数 111</span><br><span class="line">country_yard.watering 订单数 5</span><br><span class="line">country_yard.weather_station 订单数 53</span><br><span class="line">electronics.audio.acoustic 订单数 438</span><br><span class="line">electronics.audio.dictaphone 订单数 12</span><br><span class="line">electronics.audio.headphone 订单数 20084</span><br><span class="line">electronics.audio.microphone 订单数 1062</span><br><span class="line">electronics.audio.subwoofer 订单数 70</span><br><span class="line">electronics.calculator 订单数 35</span><br><span class="line">electronics.camera.photo 订单数 348</span><br><span class="line">electronics.camera.video 订单数 133</span><br><span class="line">electronics.clocks 订单数 6474</span><br><span class="line">electronics.smartphone 订单数 102365</span><br><span class="line">electronics.tablet 订单数 6395</span><br><span class="line">electronics.telephone 订单数 2437</span><br><span class="line">electronics.video.projector 订单数 114</span><br><span class="line">electronics.video.tv 订单数 17618</span><br><span class="line">furniture.bathroom.bath 订单数 232</span><br><span class="line">furniture.bathroom.toilet 订单数 44</span><br><span class="line">furniture.bedroom.bed 订单数 451</span><br><span class="line">furniture.bedroom.blanket 订单数 68</span><br><span class="line">furniture.bedroom.pillow 订单数 1882</span><br><span class="line">furniture.kitchen.chair 订单数 3084</span><br><span class="line">furniture.kitchen.table 订单数 11260</span><br><span class="line">furniture.living_room.cabinet 订单数 3117</span><br><span class="line">furniture.living_room.chair 订单数 1439</span><br><span class="line">furniture.living_room.shelving 订单数 2572</span><br><span class="line">furniture.living_room.sofa 订单数 401</span><br><span class="line">furniture.universal.light 订单数 22</span><br><span class="line">kids.bottles 订单数 63</span><br><span class="line">kids.carriage 订单数 41</span><br><span class="line">kids.dolls 订单数 379</span><br><span class="line">kids.fmcg.diapers 订单数 11</span><br><span class="line">kids.skates 订单数 1159</span><br><span class="line">kids.swing 订单数 8</span><br><span class="line">kids.toys 订单数 643</span><br><span class="line">medicine.tools.tonometer 订单数 1106</span><br><span class="line">sport.bicycle 订单数 569</span><br><span class="line">sport.diving 订单数 10</span><br><span class="line">sport.ski 订单数 17</span><br><span class="line">sport.snowboard 订单数 3</span><br><span class="line">sport.tennis 订单数 87</span><br><span class="line">sport.trainer 订单数 210</span><br><span class="line">stationery.battery 订单数 5210</span><br><span class="line">stationery.cartrige 订单数 2473</span><br><span class="line">stationery.paper 订单数 1085</span><br><span class="line">stationery.stapler 订单数 97</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">       .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">       .filter(a -&gt; !a[CATEGORY_CODE].isEmpty())</span><br><span class="line">       .collect(groupingBy(a -&gt; a[CATEGORY_CODE], TreeMap::<span class="keyword">new</span>, counting()))</span><br><span class="line">       .forEach((k, v) -&gt; &#123;</span><br><span class="line">           System.out.println(k + <span class="string">&quot; 订单数 &quot;</span> + v);</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><h3 id="6-2）按一级类别统计销量"><a href="#6-2）按一级类别统计销量" class="headerlink" title="6.2）按一级类别统计销量"></a>6.2）按一级类别统计销量</h3><p>结果应为</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accessories 订单数 3096</span><br><span class="line">apparel 订单数 2673</span><br><span class="line">appliances 订单数 150244</span><br><span class="line">auto 订单数 1367</span><br><span class="line">computers 订单数 76840</span><br><span class="line">construction 订单数 3984</span><br><span class="line">country_yard 订单数 202</span><br><span class="line">electronics 订单数 157585</span><br><span class="line">furniture 订单数 24572</span><br><span class="line">kids 订单数 2304</span><br><span class="line">medicine 订单数 1106</span><br><span class="line">sport 订单数 896</span><br><span class="line">stationery 订单数 8865</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(l -&gt; l.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .filter(a -&gt; !a[CATEGORY_CODE].isEmpty())</span><br><span class="line">    .collect(groupingBy(TestData::firstCategory, TreeMap::<span class="keyword">new</span>, counting()))</span><br><span class="line">    .forEach((k, v) -&gt; &#123;</span><br><span class="line">        System.out.println(k + <span class="string">&quot; 订单数 &quot;</span> + v);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">firstCategory</span><span class="params">(String[] a)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">category</span> <span class="operator">=</span> a[CATEGORY_CODE];</span><br><span class="line">    <span class="type">int</span> <span class="variable">dot</span> <span class="operator">=</span> category.indexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> category.substring(<span class="number">0</span>, dot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7）按价格区间统计销量"><a href="#7）按价格区间统计销量" class="headerlink" title="7）按价格区间统计销量"></a>7）按价格区间统计销量</h3><ul><li>p &lt;100</li><li>100&lt;&#x3D; p &lt;500</li><li>500&lt;&#x3D;p&lt;1000</li><li>1000&lt;&#x3D;p</li></ul><p>结果应为</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0,100)=291624</span><br><span class="line">[1000,∞)=14514</span><br><span class="line">[500,1000)=52857</span><br><span class="line">[100,500)=203863</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">priceRange</span><span class="params">(Double price)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (price &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[0,100)&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (price &gt;= <span class="number">100</span> &amp;&amp; price &lt; <span class="number">500</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[100,500)&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (price &gt;= <span class="number">500</span> &amp;&amp; price &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[500,1000)&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[1000,∞)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(line -&gt; line.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .map(array -&gt; Double.parseDouble(array[PRICE]))</span><br><span class="line">    .collect(groupingBy(TestData::priceRange, counting()))</span><br></pre></td></tr></table></figure><h3 id="8）不同年龄段女性所下不同类别订单"><a href="#8）不同年龄段女性所下不同类别订单" class="headerlink" title="8）不同年龄段女性所下不同类别订单"></a>8）不同年龄段女性所下不同类别订单</h3><ul><li>a &lt; 18</li><li>18 &lt;&#x3D; a &lt; 30</li><li>30 &lt;&#x3D; a &lt; 50</li><li>50 &lt;&#x3D; a</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[0,18)       accessories      81</span><br><span class="line">[0,18)       apparel          60</span><br><span class="line">[0,18)       appliances       4326</span><br><span class="line">[0,18)       computers        1984</span><br><span class="line">...</span><br><span class="line">[18,30)      accessories      491</span><br><span class="line">[18,30)      apparel          488</span><br><span class="line">[18,30)      appliances       25240</span><br><span class="line">[18,30)      computers        13076</span><br><span class="line">...</span><br><span class="line">[30,50)      accessories      890</span><br><span class="line">[30,50)      apparel          893</span><br><span class="line">[30,50)      appliances       42755</span><br><span class="line">[30,50)      computers        21490</span><br><span class="line">...</span><br><span class="line">[50,∞)       accessories      41</span><br><span class="line">[50,∞)       apparel          41</span><br><span class="line">[50,∞)       appliances       2255</span><br><span class="line">[50,∞)       computers        1109</span><br><span class="line">...</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> String <span class="title function_">ageRange</span><span class="params">(String[] array)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> Double.valueOf(array[USER_AGE]).intValue();</span><br><span class="line">    <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[0,18)&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &lt; <span class="number">30</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[18,30)&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &lt; <span class="number">50</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[30,50)&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[50,∞)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lines.skip(<span class="number">1</span>)</span><br><span class="line">    .map(line -&gt; line.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">    .filter(array -&gt; !array[CATEGORY_CODE].isEmpty())</span><br><span class="line">    .filter(array -&gt; array[USER_SEX].equals(<span class="string">&quot;女&quot;</span>))</span><br><span class="line">    .collect(groupingBy(TestData::ageRange, </span><br><span class="line">                        groupingBy(TestData::firstCategory, TreeMap::<span class="keyword">new</span>, counting())))</span><br></pre></td></tr></table></figure><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><p>例子 1: 使用<code>ExecutorService</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>)) &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;开始统计&quot;</span>);</span><br><span class="line">        service.submit(() -&gt; monthlySalesReport(map-&gt;map.entrySet().forEach(e-&gt;logger.info(e.toString()))));</span><br><span class="line">        logger.info(<span class="string">&quot;执行其它操作&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">monthlySalesReport</span><span class="params">(Consumer&lt;Map&lt;YearMonth, Long&gt;&gt; consumer)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Path.of(<span class="string">&quot;./data.txt&quot;</span>))) &#123;</span><br><span class="line">        Map&lt;YearMonth, Long&gt; collect = lines.skip(<span class="number">1</span>)</span><br><span class="line">                .map(line -&gt; line.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">                .collect(groupingBy(array -&gt; YearMonth.from(formatter.parse(array[TIME])), TreeMap::<span class="keyword">new</span>, counting()));</span><br><span class="line">        consumer.accept(collect);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子 2: 使用<code>CompletableFuture</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;开始统计&quot;</span>);</span><br><span class="line">    CompletableFuture</span><br><span class="line">        .supplyAsync(() -&gt; monthlySalesReport())</span><br><span class="line">            .thenAccept(map -&gt; map.entrySet().forEach(e -&gt; logger.info(e.toString())));</span><br><span class="line">    logger.info(<span class="string">&quot;执行其它操作&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;YearMonth, Long&gt; <span class="title function_">monthlySalesReport</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Path.of(<span class="string">&quot;./data.txt&quot;</span>))) &#123;</span><br><span class="line">        Map&lt;YearMonth, Long&gt; collect = lines.skip(<span class="number">1</span>)</span><br><span class="line">                .map(line -&gt; line.split(<span class="string">&quot;,&quot;</span>))</span><br><span class="line">                .collect(groupingBy(array -&gt; YearMonth.from(formatter.parse(array[TIME])), TreeMap::<span class="keyword">new</span>, counting()));</span><br><span class="line">        <span class="keyword">return</span> collect;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="框架设计"><a href="#框架设计" class="headerlink" title="框架设计"></a>框架设计</h2><ul><li>什么是框架？<ul><li>半成品软件，帮助开发者快速构建应用程序</li><li>框架提供的都是固定<strong>不变的</strong>、<strong>已知的</strong>、可以重用的代码</li><li>而那些每个应用不同的业务逻辑，<strong>变化的</strong>、<strong>未知的</strong>部分，则在框架外由开发者自己实现</li></ul></li></ul><h3 id="将未知交给子类"><a href="#将未知交给子类" class="headerlink" title="将未知交给子类"></a>将未知交给子类</h3><p>Spring 延迟创建 bean</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line"></span><br><span class="line">class DefaultSingletonBeanRegistry &#123;</span><br><span class="line">   - singletonObjects: Map</span><br><span class="line">   + getSingleton(name, factory)</span><br><span class="line">&#125;</span><br><span class="line">class AbstractAutowireCapableBeanFactory &#123;</span><br><span class="line">   # createBean(name, definition, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultSingletonBeanRegistry &lt;|-- AbstractAutowireCapableBeanFactory</span><br></pre></td></tr></table></figure><p>Spring 中的很多类有非常复杂的继承关系，并且它们分工明确，你做什么，我做什么，职责是划分好的。例如：</p><ul><li>DefaultSingletonBeanRegistry 是父类，它有个职责是缓存单例 bean，用下面方法实现</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; factory)</span></span><br></pre></td></tr></table></figure><ul><li>但如何创建 bean，这个父类是不知道的，创建 bean 是子类 AbstractAutowireCapableBeanFactory 的职责</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>父类中 getSingleton 的内部就要使用 singletonFactory 函数对象来获得创建好的对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">Object</span> <span class="variable">singletonObject</span> <span class="operator">=</span> <span class="built_in">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span>(singletonObject == <span class="literal">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        singletonObject = singletonFactory.getObject();</span><br><span class="line">        addSingleton(beanName, singletonObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后子类创建单例 bean 时，会把 ObjectFactory 这个函数对象传进去<ul><li>创建其它 scope bean，不需要用 getSingleton 缓存</li></ul></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(...)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将未知交给用户"><a href="#将未知交给用户" class="headerlink" title="将未知交给用户"></a>将未知交给用户</h3><p>JdbcTemplate</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student (</span><br><span class="line">   id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">   name <span class="type">varchar</span>(<span class="number">16</span>),</span><br><span class="line">   sex <span class="type">char</span>(<span class="number">1</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;赵一伤&#x27;</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;钱二败&#x27;</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;孙三毁&#x27;</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;李四摧&#x27;</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;周五输&#x27;</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="string">&#x27;吴六破&#x27;</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="string">&#x27;郑七灭&#x27;</span>, <span class="string">&#x27;男&#x27;</span>),</span><br><span class="line">(<span class="number">8</span>, <span class="string">&#x27;王八衰&#x27;</span>, <span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure><p>spring 中 JdbcTemplate 代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJdbc</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HikariDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HikariDataSource</span>();</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">JdbcTemplate</span> <span class="variable">template</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(dataSource);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id,name,sex from student&quot;</span>;</span><br><span class="line">        template.query(sql, (rs, index) -&gt; &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> rs.getString(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>(id, name, sex);</span><br><span class="line">        &#125;).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">record</span> <span class="title class_">Student</span><span class="params">(<span class="type">int</span> id, String name, String sex)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对 query 来讲，建立数据库连接，创建 Statement 对象，执行查询这些步骤都是固定的</li><li>而结果要如何用 java 对象封装，这对框架代码是未知的，用 RowMapper 接口代表，将来它的 lambda 实现将结果转换成需要的 java 对象</li></ul><p>ApplicationListener</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestExtend</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> </span><br><span class="line">            <span class="operator">=</span> SpringApplication.run(TestExtend.class, args);</span><br><span class="line">        context.publishEvent(<span class="keyword">new</span> <span class="title class_">MyEvent</span>(<span class="string">&quot;context&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ApplicationListener&lt;MyEvent&gt; <span class="title function_">myListener</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (event -&gt; System.out.println(<span class="string">&quot;收到事件:&quot;</span> + event));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">        <span class="meta">@Autowired</span></span><br><span class="line">        <span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">            context.publishEvent(<span class="keyword">new</span> <span class="title class_">MyEvent</span>(<span class="string">&quot;controller&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对 spring 来讲，它并不知道如何处理事件</li><li>因此可以提供一个类型为 ApplicationListener 的 lambda 对象</li></ul><h3 id="延迟拼接条件"><a href="#延迟拼接条件" class="headerlink" title="延迟拼接条件"></a>延迟拼接条件</h3><p>Mybatis-Plus</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMyBatisPlus</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> </span><br><span class="line">            <span class="operator">=</span> SpringApplication.run(TestMyBatisPlus.class, args);</span><br><span class="line">        <span class="type">StudentMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> context.getBean(StudentMapper.class);</span><br><span class="line"></span><br><span class="line">        test(mapper, List.of(<span class="string">&quot;赵一伤&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(StudentMapper mapper, List&lt;String&gt; names)</span> &#123;</span><br><span class="line">        LambdaQueryWrapper&lt;Student&gt; query = <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;&gt;();</span><br><span class="line">        query.in(!names.isEmpty(), Student::getName, names);</span><br><span class="line">        System.out.println(mapper.selectList(query));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较典型的用法有两处：</p><p>第一，在调用 in 等方法添加条件时，第一个参数是 boolean 为 true 才会拼接 SQL 条件，否则不拼接</p><p>如何实现的呢？用 DoSomething 类型的 lambda 对象来延迟拼接操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DoSomething</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doIt</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Children <span class="title function_">maybeDo</span><span class="params">(<span class="type">boolean</span> condition, DoSomething something)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        something.doIt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> typedThis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>然而，它在实现 <code>()-&gt;appendSqlSegments(...)</code> 拼接时，是不断修改一个 expression 状态变量，为函数编程所不齿</li></ul><h3 id="偏门用法"><a href="#偏门用法" class="headerlink" title="偏门用法"></a>偏门用法</h3><p>第二，如果用 LambdaQueryWrapper 拼接 sql 条件时，<strong>为了取得列名</strong>，采用了这个办法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student::getName</span><br></pre></td></tr></table></figure><p>它要做的事很简单，但内部实现却比较复杂</p><ol><li>必须用 <code>Student::getName</code> 方法引用，而不能用其它 Lambda 对象</li><li>它会实现 Serializable 接口，序列化时会把它变成 SerializedLambda</li><li>想办法拿到 SerializedLambda 对象（反射调用 writeReplace）</li><li>通过 SerializedLambda 能够获得它对应的实际方法，也就是 String getName() 和所在类 Student</li><li>再通过方法名推导得到属性名（去掉 is，get）即 name</li><li>所在类 Student 知道了，属性名 name 也有了，就可以进一步确定列名<ol><li>属性上的 @TableField 指定的列名优先</li><li>没有 @TableField，把属性名当作列名</li></ol></li></ol><blockquote><p><em><strong>P.S.</strong></em></p><ul><li>不是很喜欢这种做法，比较恶心</li><li>但它确实是想做这么一件事：在代码中全面使用 java 的字段名，避免出现数据库的列名</li></ul></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="comment">//        Type1 lambda = (Type1 &amp; Serializable) (a, b) -&gt; a + b;</span></span><br><span class="line">    <span class="type">Type2</span> <span class="variable">lambda</span> <span class="operator">=</span> (Type2 &amp; Serializable) Student::getName;</span><br><span class="line">    <span class="comment">// 将 lambda 对象序列化</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">writeReplace</span> <span class="operator">=</span> lambda.getClass().getDeclaredMethod(<span class="string">&quot;writeReplace&quot;</span>);</span><br><span class="line">    <span class="type">SerializedLambda</span> <span class="variable">serializedLambda</span> <span class="operator">=</span> (SerializedLambda) writeReplace.invoke(lambda);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到 lambda 对象使用类、所属类和实现方法名</span></span><br><span class="line">    System.out.println(serializedLambda.getCapturingClass());</span><br><span class="line">    System.out.println(serializedLambda.getImplClass());</span><br><span class="line">    System.out.println(serializedLambda.getImplMethodName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Type2</span> &#123;</span><br><span class="line">    String <span class="title function_">get</span><span class="params">(Student student)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Type1</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h2><p>统计页面的访问次数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ParallelTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Pattern</span> <span class="variable">reg</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(\\S+) - \\[(.+)] (.+) (.+)&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FILES</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            sequence();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sequence</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        Map&lt;String, Long&gt; m0 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; FILES; i++) &#123;</span><br><span class="line">            Map&lt;String, Long&gt; mi = one(i);</span><br><span class="line">            m0 = Stream.of(m0, mi)</span><br><span class="line">                    .flatMap(m -&gt; m.entrySet().stream())</span><br><span class="line">                    .collect(toMap(Map.Entry::getKey, Map.Entry::getValue, Long::sum));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Long&gt; e : m0.entrySet()) &#123;</span><br><span class="line"><span class="comment">//            System.out.println(e);</span></span><br><span class="line">            sum += e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;cost: &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Long&gt; <span class="title function_">one</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (Stream&lt;String&gt; lines = Files.lines(Path.of(String.format(<span class="string">&quot;web_server_access_%d.log&quot;</span>, i)))) &#123;</span><br><span class="line">            <span class="keyword">return</span> lines</span><br><span class="line"><span class="comment">//                            .limit(10)</span></span><br><span class="line">                    .map(reg::matcher)</span><br><span class="line">                    .filter(Matcher::find)</span><br><span class="line">                    .map(matcher -&gt; matcher.group(<span class="number">3</span>))</span><br><span class="line">                    .collect(groupingBy(identity(), counting()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">parallel</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        List&lt;CompletableFuture&lt;Map&lt;String, Long&gt;&gt;&gt; futures = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; FILES; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">            CompletableFuture&lt;Map&lt;String, Long&gt;&gt; future = CompletableFuture.supplyAsync(() -&gt; one(k));</span><br><span class="line">            futures.add(future);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CompletableFuture&lt;Map&lt;String, Long&gt;&gt; f0 = futures.getFirst();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; futures.size(); i++) &#123;</span><br><span class="line">            f0 = f0.thenCombine(futures.get(i), (m1, m2) -&gt;</span><br><span class="line">                    Stream.of(m1, m2)</span><br><span class="line">                            .flatMap(m -&gt; m.entrySet().stream())</span><br><span class="line">                            .collect(toMap(Map.Entry::getKey, Map.Entry::getValue, Long::sum))</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, Long&gt; map = f0.get();</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Long&gt; e : map.entrySet()) &#123;</span><br><span class="line"><span class="comment">//            System.out.println(e);</span></span><br><span class="line">            sum += e.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;cost: &quot;</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="UI-事件"><a href="#UI-事件" class="headerlink" title="UI 事件"></a>UI 事件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUIEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">JFrame</span> <span class="variable">frame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFrame</span>(<span class="string">&quot;Lambda Example&quot;</span>);</span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;Click me&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Lambda表达式定义按钮的点击事件处理程序</span></span><br><span class="line">        button.addActionListener(e -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Button clicked!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        frame.add(button);</span><br><span class="line">        frame.setSize(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        frame.setVisible(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="五-实现原理"><a href="#五-实现原理" class="headerlink" title="五. 实现原理"></a>五. 实现原理</h1><h2 id="lambda-原理"><a href="#lambda-原理" class="headerlink" title="lambda 原理"></a>lambda 原理</h2><p>以下面代码为例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test((a, b) -&gt; a + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(BinaryOperator&lt;Integer&gt; lambda)</span> &#123;</span><br><span class="line">        System.out.println(lambda.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="第一步，生成静态方法"><a href="#第一步，生成静态方法" class="headerlink" title="第一步，生成静态方法"></a>第一步，生成静态方法</h3><p>如何证明？用反射</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Method method : TestLambda.class.getDeclaredMethods()) &#123;</span><br><span class="line">    System.out.println(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为（去掉了包名，容易阅读）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> TestLambda.main(java.lang.String[])</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> TestLambda.test(BinaryOperator)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> java.lang.Integer TestLambda.lambda$main$<span class="number">0</span>(Integer,Integer)</span><br></pre></td></tr></table></figure><ul><li><p>可以看到除了我们自己写的 main 和 test 以外，多出一个名为 <code>lambda$main$0</code> 的方法</p></li><li><p>这个方法是在编译期间由编译器生成的方法，是 synthetic（合成）方法</p></li><li><p>它的参数、内容就是 lambda 表达式提供的参数和内容，如下面代码片段所示</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer lambda$main$<span class="number">0</span>(Integer a, Integer b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="第二步，生成实现类字节码"><a href="#第二步，生成实现类字节码" class="headerlink" title="第二步，生成实现类字节码"></a>第二步，生成实现类字节码</h3><p>如果是我自己造一个对象包含此方法，可以这么做</p><p>先创建一个类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LambdaObject</span> <span class="keyword">implements</span> <span class="title class_">BinaryOperator</span>&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">apply</span><span class="params">(Integer a, Integer b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> TestLambda.lambda$main$<span class="number">0</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将来使用时，创建对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">test(<span class="keyword">new</span> <span class="title class_">LambdaObject</span>());</span><br></pre></td></tr></table></figure><p>只不过，jvm 是在运行期间造出的这个类以及对象而已，要想查看这个类</p><p>在 jdk 21 中运行时添加虚拟机参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Djdk.invoke.LambdaMetafactory.dumpProxyClassFiles</span><br></pre></td></tr></table></figure><p>早期 jdk 添加的参数是（没有去进行版本比对了）</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Djdk.internal.lambda.dumpProxyClasses</span><br></pre></td></tr></table></figure><p>若想实现在运行期间生成上述 class 字节码，有两种手段</p><ul><li>一是动态代理，jdk 并没有采用这种办法来生成 Lambda 类</li><li>二是用 LambdaMetaFactory，它配合 MethodHandle API 在执行时更具性能优势</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        test((a, b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line">        MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> MethodHandles.lookup();</span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">factoryType</span> <span class="operator">=</span> MethodType.methodType(BinaryOperator.class);</span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">interfaceMethodType</span> <span class="operator">=</span> MethodType.methodType(Object.class, Object.class, Object.class);</span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">implementsMethodType</span> <span class="operator">=</span> MethodType.methodType(Integer.class, Integer.class, Integer.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodHandle</span> <span class="variable">implementsMethod</span> <span class="operator">=</span> lookup.findStatic(TestLambda1.class, <span class="string">&quot;lambda$main$1&quot;</span>, implementsMethodType);</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">lambdaType</span> <span class="operator">=</span> MethodType.methodType(Integer.class, Integer.class, Integer.class);</span><br><span class="line">        <span class="type">CallSite</span> <span class="variable">callSite</span> <span class="operator">=</span> LambdaMetafactory.metafactory(lookup,</span><br><span class="line">                <span class="string">&quot;apply&quot;</span>, factoryType, interfaceMethodType,</span><br><span class="line">                implementsMethod,</span><br><span class="line">                lambdaType);</span><br><span class="line"></span><br><span class="line">        BinaryOperator&lt;Integer&gt; lambda = (BinaryOperator) callSite.getTarget().invoke();</span><br><span class="line">        test(lambda);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Integer lambda$main$<span class="number">1</span>(Integer a, Integer b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(BinaryOperator&lt;Integer&gt; lambda)</span> &#123;</span><br><span class="line">        System.out.println(lambda.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><p>“apply” 是接口方法名</p></li><li><p>factoryType 是工厂方法长相</p></li><li><p>interfaceMethodType 是接口方法长相</p></li><li><p>implementsMethod 是实现方法</p><ul><li>implementsMethodType 是实现方法长相</li></ul></li><li><p>lambdaType 是实际函数对象长相</p></li><li><p>callSite.getTarget() 实际是调用实现类的构造方法对应的 mh，最后 invoke 返回函数对象</p></li></ul><h2 id="方法引用原理"><a href="#方法引用原理" class="headerlink" title="方法引用原理"></a>方法引用原理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">test(String::toLowerCase);</span><br><span class="line">        </span><br><span class="line">        MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> MethodHandles.lookup();</span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">factoryType</span> <span class="operator">=</span> MethodType.methodType(Function.class);</span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">interfaceMethodType</span> <span class="operator">=</span> MethodType.methodType(Object.class, Object.class);</span><br><span class="line">        <span class="type">MethodHandle</span> <span class="variable">implementsMethod</span> <span class="operator">=</span> lookup.findVirtual(String.class, <span class="string">&quot;toLowerCase&quot;</span>, MethodType.methodType(String.class));</span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">lambdaType</span> <span class="operator">=</span> MethodType.methodType(String.class, String.class);</span><br><span class="line">        <span class="type">CallSite</span> <span class="variable">callSite</span> <span class="operator">=</span> LambdaMetafactory.metafactory(lookup,</span><br><span class="line">                <span class="string">&quot;apply&quot;</span>, factoryType, interfaceMethodType,</span><br><span class="line">                implementsMethod,</span><br><span class="line">                lambdaType);</span><br><span class="line"></span><br><span class="line">        Function&lt;String, String&gt; lambda = (Function&lt;String, String&gt;) callSite.getTarget().invoke();</span><br><span class="line">        System.out.println(lambda.apply(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Function&lt;String,String&gt; lambda)</span> &#123;</span><br><span class="line">        System.out.println(lambda.apply(<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包原理"><a href="#闭包原理" class="headerlink" title="闭包原理"></a>闭包原理</h2><p>捕获基本类型变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">test((a, b) -&gt; a + b + c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(BinaryOperator&lt;Integer&gt; lambda)</span> &#123;</span><br><span class="line">    System.out.println(lambda.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成一个带 3 个参数的方法，但它和 BinaryOperator 还差一个 int 参数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Integer lambda$main$<span class="number">1</span>(<span class="type">int</span> c, Integer a, Integer b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">//        int c = 10;</span></span><br><span class="line"><span class="comment">//        test((a, b) -&gt; a + b + c);</span></span><br><span class="line"></span><br><span class="line">        MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> MethodHandles.lookup();</span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">factoryType</span> <span class="operator">=</span> MethodType.methodType(BinaryOperator.class, <span class="type">int</span>.class);</span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">interfaceMethodType</span> <span class="operator">=</span> MethodType.methodType(Object.class, Object.class, Object.class);</span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">implementsMethodType</span> <span class="operator">=</span> MethodType.methodType(Integer.class, <span class="type">int</span>.class, Integer.class, Integer.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodHandle</span> <span class="variable">implementsMethod</span> <span class="operator">=</span> lookup.findStatic(TestLambda2.class, <span class="string">&quot;lambda$main$1&quot;</span>, implementsMethodType);</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">lambdaType</span> <span class="operator">=</span> MethodType.methodType(Integer.class, Integer.class, Integer.class);</span><br><span class="line">        <span class="type">CallSite</span> <span class="variable">callSite</span> <span class="operator">=</span> LambdaMetafactory.metafactory(lookup,</span><br><span class="line">                <span class="string">&quot;apply&quot;</span>, factoryType, interfaceMethodType,</span><br><span class="line">                implementsMethod,</span><br><span class="line">                lambdaType);</span><br><span class="line"></span><br><span class="line">        BinaryOperator&lt;Integer&gt; lambda = (BinaryOperator) callSite.getTarget().invoke(<span class="number">10</span>);</span><br><span class="line">        test(lambda);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Integer lambda$main$<span class="number">1</span>(<span class="type">int</span> c, Integer a, Integer b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(BinaryOperator&lt;Integer&gt; lambda)</span> &#123;</span><br><span class="line">        System.out.println(lambda.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同之处</p><ul><li>factoryType，除了原本的接口类型之外，多了实现方法第一个参数的类型</li><li>产生 lambda 对象的时候，通过 invoke 把这个参数的实际值传进去</li></ul><p>这样产生的 LambdaType 就是这样，并且生成 Lambda 对象时，c 的值被固定为 10</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">LambdaType</span> <span class="keyword">implements</span> <span class="title class_">BinaryOperator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TestLambda2$$Lambda(<span class="type">int</span> c) &#123;</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">apply</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> TestLambda2.lambda$main$<span class="number">1</span>(<span class="built_in">this</span>.c, (Integer)a, (Integer)b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>捕获引用类型变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLambda4</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyRef</span> &#123;</span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyRef</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">/*MyRef ref = new MyRef(10);</span></span><br><span class="line"><span class="comment">        test((a, b) -&gt; a + b + ref.age);*/</span></span><br><span class="line"></span><br><span class="line">        MethodHandles.<span class="type">Lookup</span> <span class="variable">lookup</span> <span class="operator">=</span> MethodHandles.lookup();</span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">factoryType</span> <span class="operator">=</span> MethodType.methodType(BinaryOperator.class, MyRef.class);</span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">interfaceMethodType</span> <span class="operator">=</span> MethodType.methodType(Object.class, Object.class, Object.class);</span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">implementsMethodType</span> <span class="operator">=</span> MethodType.methodType(Integer.class, MyRef.class, Integer.class, Integer.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodHandle</span> <span class="variable">implementsMethod</span> <span class="operator">=</span> lookup.findStatic(TestLambda4.class, <span class="string">&quot;lambda$main$1&quot;</span>, implementsMethodType);</span><br><span class="line"></span><br><span class="line">        <span class="type">MethodType</span> <span class="variable">lambdaType</span> <span class="operator">=</span> MethodType.methodType(Integer.class, Integer.class, Integer.class);</span><br><span class="line">        <span class="type">CallSite</span> <span class="variable">callSite</span> <span class="operator">=</span> LambdaMetafactory.metafactory(lookup,</span><br><span class="line">                <span class="string">&quot;apply&quot;</span>, factoryType, interfaceMethodType,</span><br><span class="line">                implementsMethod,</span><br><span class="line">                lambdaType);</span><br><span class="line"></span><br><span class="line">        BinaryOperator&lt;Integer&gt; lambda = (BinaryOperator) callSite.getTarget().bindTo(<span class="keyword">new</span> <span class="title class_">MyRef</span>(<span class="number">20</span>)).invoke();</span><br><span class="line">        test(lambda);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Integer lambda$main$<span class="number">1</span>(MyRef c, Integer a, Integer b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b + c.age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(BinaryOperator&lt;Integer&gt; lambda)</span> &#123;</span><br><span class="line">        System.out.println(lambda.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与捕获基本类型变量类似，不过</p><p>除了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">callSite.getTarget().invoke(<span class="keyword">new</span> <span class="title class_">MyRef</span>(<span class="number">20</span>));</span><br></pre></td></tr></table></figure><p>还可以</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">callSite.getTarget().bindTo(<span class="keyword">new</span> <span class="title class_">MyRef</span>(<span class="number">20</span>)).invoke();</span><br></pre></td></tr></table></figure><h2 id="Stream-构建"><a href="#Stream-构建" class="headerlink" title="Stream 构建"></a>Stream 构建</h2><p>自定义可切分迭代器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSpliterator</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MySpliterator</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Spliterator</span>&lt;T&gt; &#123;</span><br><span class="line">        T[] array;</span><br><span class="line">        <span class="type">int</span> begin;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MySpliterator</span><span class="params">(T[] array, <span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.array = array;</span><br><span class="line">            <span class="built_in">this</span>.begin = begin;</span><br><span class="line">            <span class="built_in">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAdvance</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; action)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin &gt; end) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            action.accept(array[begin++]);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Spliterator&lt;T&gt; <span class="title function_">trySplit</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (estimateSize() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (begin + end) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                MySpliterator&lt;T&gt; res = <span class="keyword">new</span> <span class="title class_">MySpliterator</span>&lt;&gt;(array, begin, mid);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + res);</span><br><span class="line">                begin = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.toString(Arrays.copyOfRange(array, begin, end + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">estimateSize</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> end - begin + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">characteristics</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Spliterator.SUBSIZED | Spliterator.ORDERED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Integer[] all = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        MySpliterator&lt;Integer&gt; spliterator = <span class="keyword">new</span> <span class="title class_">MySpliterator</span>&lt;&gt;(all, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        StreamSupport.stream(spliterator, <span class="literal">false</span>)</span><br><span class="line">                .parallel()</span><br><span class="line">                .forEach(x -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>练习：按每次切分固定大小来实现</p>]]></content>
      
      
      <categories>
          
          <category> 程序员 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 使用 Git 详解(三)</title>
      <link href="/posts/d06fc5d7.html"/>
      <url>/posts/d06fc5d7.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/load.gif" data-original="https://n.sinaimg.cn/sinakd10116/612/w2000h1012/20200629/34e0-ivrxcex3246619.jpg" alt=" https://n.sinaimg.cn/sinakd10116/612/w2000h1012/20200629/34e0-ivrxcex3246619.jpg"></p><h2 id="管理-Git-分支"><a href="#管理-Git-分支" class="headerlink" title="管理 Git 分支"></a>管理 Git 分支</h2><p>在 Git 中，分支是一种强大的机制，它允许您偏离主开发线，例如，当您需要处理<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#feature-branches">某个功能</a>，或者冻结代码库的某个状态以进行发布等时。</p><p>在 IntelliJ IDEA 中，所有分支操作都在Git Branches弹出窗口中执行。要调用它，请在主窗口标题中单击包含当前签出的分支名称的 Git 小部件：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_widget.png" alt="Git 小部件"></p><p>您还可以在Git工具窗口的<a href="https://intellijidea.com.cn/help/idea/log-tab.html#BranchesPane">“分支”窗格</a>中管理分支并对多个分支执行批量操作。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/branches_pane.png" alt="分支窗格"></p><p><strong>1、创建新分支</strong>﻿</p><blockquote><p><strong>从当前分支创建一个新分支</strong>﻿</p><ol><li><p>在“分支”弹出窗口中，选择“新建分支”或右键单击 Git工具窗口的“分支”窗格中的当前分支，然后从“分支名称”中选择“新建分支” 。</p></li><li><p>在打开的对话框中，指定分支名称，如果要切换到该分支，请确保选择“签出分支”选项。</p><p>一旦您开始为新分支输入名称，IntelliJ IDEA 将根据现有本地分支的名称建议相关前缀。</p><p>新分支将从当前分支 HEAD 开始。</p></li></ol></blockquote><blockquote><p><strong>从选定的分支创建新分支</strong>﻿</p><ol><li>在“分支”弹出窗口或 Git工具窗口的“分支”窗格中，选择要从中启动新分支的本地或远程分支，然后从“选定的”中选择“新建分支”。</li><li>在打开的对话框中，指定分支名称，如果要切换到该分支，请确保选择“签出分支”选项。</li></ol></blockquote><blockquote><p><strong>从选定的提交创建新分支</strong>﻿</p><ol><li>在<a href="https://intellijidea.com.cn/help/idea/log-tab.html">“日志”视图</a>中，选择要充当新分支起点的提交，然后从上下文菜单中选择“新建分支” 。</li><li>在打开的对话框中，指定分支名称，如果要切换到该分支，请确保选择“签出分支”选项。</li></ol></blockquote><p><strong>2、重命名分支</strong>﻿</p><blockquote><ol><li>在“分支”弹出窗口或 Git工具窗口的“分支”窗格中，选择要重命名的分支，然后选择“重命名”。</li><li>在打开的对话框中，将分支名称更改为您需要的名称。</li></ol><p>要复制分支的名称，请将鼠标悬停在该分支上并按。<code>Ctrl</code> <code>C</code></p></blockquote><p><strong>3、将分支标记为收藏夹</strong>﻿</p><blockquote><p>如果您有很多分支，您可能只想查看您最喜欢的分支。默认情况下，主分支被标记为收藏夹。最喜欢的分支始终显示在“分支”弹出窗口的顶部以及 Git工具窗口的“分支”窗格中。</p><ul><li><p>要将分支标记为收藏夹，请在“分支”弹出窗口中，将鼠标悬停在分支名称上，然后单击左侧显示的星形轮廓：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/GitFavoriteBranch.png" alt="最喜欢的分支"></p><p>或者，选择您想要标记为收藏的分支，然后按Space。</p><p>您还可以在Git工具窗口的“分支”窗格中选择一个分支 ，然后单击工具栏上的 。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.nodes.favorite.svg" alt="星形图标"></p></li></ul><blockquote><p>在搜索特定分支并导航分支列表时，按将焦点移回搜索字段。<code>Ctrl</code> <code>F</code></p></blockquote></blockquote><p><strong>4、集团分支机构</strong>﻿</p><p>在“分支”弹出窗口中，IntelliJ IDEA 将分支保留在三个节点中：</p><ul><li>最近的分支节点最多显示五个最近签出的分支。</li><li>本地分支节点列出了所有本地分支。</li><li>远程分支节点显示最新<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html#fetch">fetch</a>之后可用的所有远程分支。</li></ul><p>此外，IntelliJ IDEA 自动按前缀对分支进行分组并将它们存储在可扩展列表中。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/branches_grouped_by_prefix.png" alt="在“分支”弹出窗口中按前缀分组的分支"></p><p>为了对分支进行分组，分支名称中的前缀应使用正斜杠分隔&#x2F;。例如，<code>jd/2023.1</code>。</p><p>如果您不希望按前缀对分支进行分组，请单击“分支”<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.expui.general.settings.svg" alt="齿轮图标">弹出窗口右上角的，然后取消选择“按前缀分组”选项以将其禁用。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/group_by_prefix_option.png" alt="“分支”弹出窗口中的“按前缀分组”选项"></p><p><strong>5、检查分支（git-checkout）</strong>﻿</p><p>如果您想处理其他人创建的分支，则需要将其签出以创建该分支的本地副本。</p><p>要确保您拥有远程分支的完整列表，请单击“分支”<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.expui.vcs.fetch.svg" alt="获取图标">弹出窗口：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/VCS_fetch_from_branches_popup.png" alt="获取图标"></p><blockquote><p><strong>将分支检出为新的本地分支</strong>﻿</p><ol><li>在“分支”弹出窗口或 Git工具窗口的“分支”窗格中，选择要从“远程分支”或“公共远程分支”（如果您的项目有多个根并且启用了<a href="https://intellijidea.com.cn/help/idea/manage-branches.html#synchronous_branch_control">同步分支控制）在本地检出的分支，或者从</a>“存储库”| 远程分支（如果已禁用）。</li><li>从操作列表中选择结帐。</li></ol><p>将创建、检出并设置新的本地分支以跟踪原始远程分支。</p><p>您可能已经有一个与您要签出的远程分支同名的本地分支。根据具体情况，您可以通过以下方式完成结账流程：</p><ul><li>如果没有提交丢失，并且本地分支已经跟踪远程分支，IntelliJ IDEA 会自动将本地分支重置为远程分支，然后将其签出。</li><li>如果本地分支包含可能因重置而丢失的提交，IntelliJ IDEA 将为您提供：<ul><li>删除本地提交：IntelliJ IDEA 将删除您的本地提交、重置本地分支并更改跟踪。</li><li>变基到远程：IntelliJ IDEA 会将您的本地分支变基到远程分支，保留本地提交，重置本地分支并更改跟踪。</li></ul></li></ul></blockquote><blockquote><p><strong>分支间切换</strong>﻿</p><p>当<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html">进行多任务处理</a>时，您经常需要在分支之间跳转以提交不相关的更改。</p><ol><li><p>在“分支”弹出窗口或 Git工具窗口的“分支”窗格中，在“本地分支”下选择要切换到的分支，然后从可用操作列表中选择“签出” 。</p><p>对于多存储库项目，分支会按存储库自动分组。要检查必要的分支，请在“分支”弹出窗口中，首先选择存储库。</p></li><li><p>接下来会发生什么取决于您尚未提交的本地更改与您要签出的分支之间是否存在冲突：</p><ul><li><p>如果你的工作树是干净的（这意味着你没有未提交的更改），或者你的本地更改与指定分支不冲突，则该分支将被签出（IntelliJ IDEA 右下角会弹出通知）窗户）。</p></li><li><p>如果您的本地更改将被签出覆盖，IntelliJ IDEA 会显示阻止您签出所选分支的文件列表，并建议在Force Checkout和Smart Checkout之间进行选择。</p><blockquote><p>如果您单击“强制签出”，您本地未提交的更改将被覆盖，并且您将丢失它们。</p><p>如果您单击Smart Checkout，IntelliJ IDEA 将<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#shelve">搁置</a>未提交的更改，检出所选分支，然后取消搁置更改。如果取消搁置操作期间发生冲突，系统将提示您合并更改。有关详细信息，请参阅<a href="https://intellijidea.com.cn/help/idea/resolve-conflicts.html">解决冲突</a>。</p><pre><code>&gt; 如果您想使用[存储](https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#stash)而不是搁置来清理工作副本，请转到版本控制| IDE 设置的 Git页面，然后在“清理工作树使用”设置下选择“搁置”。`Ctrl` `Alt` `S`</code></pre></blockquote></li></ul></li></ol><blockquote><p>IntelliJ IDEA 会保存您的<a href="https://intellijidea.com.cn/help/idea/managing-tasks-and-context.html#work-with-context">上下文</a>（一组打开的文件、当前运行配置和<a href="https://intellijidea.com.cn/help/idea/using-breakpoints.html">断点</a>），前提是在“版本控制”| “设置”对话框中启用了“分支切换时恢复工作区”选项。确认。当您切换到分支时，IntelliJ IDEA 会自动恢复与该分支关联的上下文。<code>Ctrl</code> <code>Alt</code> <code>S</code></p></blockquote></blockquote><p><strong>6、比较分支机构</strong>﻿</p><blockquote><p><strong>将分支与当前分支进行比较</strong>﻿</p><p>如果你想检查一个分支与当前分支的分歧程度，你可以比较它们。</p><ol><li><p>从“分支”弹出窗口或 Git工具窗口的“分支”窗格中，选择要与当前分支进行比较的分支，然后选择“与当前比较”。</p><p>Git工具窗口中将添加一个新选项卡，列出所选分支中存在且当前分支中不存在的所有提交。</p><p>您可以单击“交换分支”链接来更改将哪个分支视为与其他分支进行比较的基础。</p></li><li><p>要查看两个分支中不同的所有文件的列表，请单击：<a href="https://intellijidea.com.cn/help/idea/log-tab.html#changedFiles">“更改的文件”窗格</a>将列出包含差异的所有文件。<code>Ctrl</code> <code>A</code></p></li></ol></blockquote><blockquote><p><strong>将分支与工作树进行比较</strong>﻿</p><p>除了将分支与当前分支进行比较之外，您还可以将其与当前分支的本地状态进行比较。如果您有本地未提交的更改，这非常有用。</p><ul><li><p>从“分支”弹出窗口或 Git工具窗口的“分支”窗格中，选择要与本地工作树进行比较的分支，然后选择“显示与工作树的差异”。</p><p>打开的“更改”工具窗口显示所选分支中与当前签出的分支相比不同的所有文件的列表：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/ij_git_branches_diff.png" alt="显示所选分支和当前工作树之间的差异"></p><ul><li>所选分支中存在且当前分支中缺失的文件标记为灰色。</li><li>当前分支中存在但所选分支中缺失的文件标记为绿色。</li><li>包含所选分支和当前分支之间差异的文件用蓝色标记。</li></ul><p>您可以单击“交换分支”链接来更改将哪个分支视为与其他分支进行比较的基础。</p><ul><li>要查看特定文件中的差异，请选择该文件并单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.diff.svg" alt="差异图标">工具栏上的 ，或按。<code>Ctrl</code> <code>D</code></li><li>要将整个文件内容应用到当前分支，请单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.download.svg" alt="从分支获取图标">。有关详细信息，请参阅<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#copy-files-to-branch">应用单独的文件</a>。</li></ul></li></ul></blockquote><p><strong>7、删除分支</strong>﻿</p><blockquote><p>将功能分支的<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html">更改集成</a>到开发主线后，您可以删除不再需要的分支。</p><ol><li>检查您将用于进一步工作的分支。</li><li>在“分支”弹出窗口中或从 Git工具窗口的“分支”窗格中，右键单击要删除的分支，然后选择“删除”。</li></ol><p>删除分支后，右下角会显示一条通知，您可以从中恢复已删除的分支：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/deleted_branch_notification.png" alt="删除分支通知"></p><p>如果分支包含尚未合并到其上游分支或当前分支的提交，它仍然会立即删除（相当于 or 命令<code>git branch --D</code>）<code>git branch --delete --force</code>，但通知还将包含一个链接，允许您查看未合并的提交。</p><p>如果删除的分支正在跟踪远程分支，则此通知中还会有一个用于删除远程分支的链接。</p><blockquote><p><a href="https://intellijidea.com.cn/help/idea/notifications.html">如果您已关闭通知并稍后决定恢复已删除的分支，则该链接将在“通知”工具窗口</a>中可用，直到您重新启动 IntelliJ IDEA。</p></blockquote></blockquote><p><strong>8、配置同步分支控制</strong>﻿</p><blockquote><p>如果您有一个多根存储库，您可以将 IntelliJ IDEA 配置为在所有根上同时执行所有分支操作（例如签出、合并、删除等），就像它是单个存储库一样。</p><ol><li>按打开 IDE 设置，然后选择版本控制 | 吉特.<code>Ctrl</code> <code>Alt</code> <code>S</code></li><li>选择“在所有根上执行分支操作”选项（请注意，此选项仅在您的项目有多个根时才可用）。</li></ol><p>如果某个操作至少在其中一个存储库中失败，IntelliJ IDEA 会建议您在成功的存储库中回滚此操作，从而防止分支出现分歧。</p><blockquote><p>如果您仅在其中一个根上检查分支，IntelliJ IDEA 将在“分支”弹出窗口中显示“分支已发散”警告。这意味着根项目位于不同的分支上。</p><p>如果您想继续，请忽略此警告或禁用“在所有根上执行分支操作”选项。如果您仍想同时对所有根执行分支操作，请手动检查其余存储库中的同名分支。</p></blockquote></blockquote><h2 id="将更改从一个-Git-分支应用到另一分支"><a href="#将更改从一个-Git-分支应用到另一分支" class="headerlink" title="将更改从一个 Git 分支应用到另一分支"></a>将更改从一个 Git 分支应用到另一分支</h2><p>在 Git 中，有多种方法可以将一个分支的更改集成到另一个分支：</p><ul><li><a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#merge">合并分支</a></li><li><a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#rebase-branch">变基分支</a></li><li><a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#cherry-pick">挑选单独的提交</a></li><li><a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#apply-separate-changes">应用提交中的单独更改</a></li><li><a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#copy-files-to-branch">将特定文件应用到分支</a></li></ul><p><strong>1、合并分支</strong>﻿</p><p>假设您创建了一个<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#feature-branches">功能分支</a>来处理特定任务，并希望在完成并测试功能后将工作结果集成到主代码库中：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/feature_branch_diagram.png" alt="特征分支图"></p><p>将分支合并到 master 是最常见的方法。</p><p>当您在功能分支中工作时，您的队友会继续将他们的工作提交给 master，这是很常见的情况：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/feature_branch_diverge_from_master_diagram.png" alt="功能分支与主分支分离"></p><p>当您运行时<code>merge</code>，功能分支中的更改将集成到目标分支的 HEAD 中：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/merge_result_diagram.png" alt="合并结果"></p><p>Git 创建一个新的提交 (M)，称为合并提交，它是从两个分支分歧点合并来自功能分支和主分支的更改而产生的。</p><blockquote><p><strong>合并分支</strong>﻿</p><ol><li><p>在<a href="https://intellijidea.com.cn/help/idea/manage-branches.html">“分支”</a>弹出窗口（主菜单Git | 分支）或 Git工具窗口的“分支”窗格中，选择要将更改集成到的目标分支，然后从上下文菜单中选择“签出”以切换到该分支。</p></li><li><p>执行以下操作之一：</p><ul><li><p>如果不需要指定合并选项，请选择要合并到当前分支的分支，然后从子菜单中选择“合并到当前”。</p></li><li><p>如果需要指定合并选项，请从主菜单中选择VCS Git | 合并更改以打开“合并”对话框：</p><blockquote><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/merge_dialog.png" alt="合并对话框"></p><p>选择要合并到当前分支的分支，单击“修改选项”并从以下选项中进行选择：</p><pre><code>- `--no-ff`：在所有情况下都会创建合并提交，即使可以将合并解析为快进。</code></pre></blockquote><ul><li><code>--ff-only</code>：只有可以快进时，合并才会被解决。</li><li><code>--squash</code>：将在当前分支之上创建包含所有拉取更改的单个提交。</li><li><code>-m</code>：您将能够编辑合并提交的消息。</li><li><code>--no-commit</code>：将执行合并，但不会创建合并提交，以便您可以在提交之前检查合并的结果。</li></ul></li></ul><p>单击“合并”。</p></li></ol><p>如果你的工作树是干净的（这意味着你没有未提交的更改），并且你的功能分支和目标分支之间没有发生冲突，Git 将合并这两个分支，并且合并提交将出现在 Git 工具的 Log选项卡 中窗户 ：<code>Alt</code> <code>9</code></p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/merge_commit.png" alt="合并提交"></p><p>如果您的分支与目标分支之间发生冲突，系统会提示您解决冲突（请参阅<a href="https://intellijidea.com.cn/help/idea/resolve-conflicts.html">解决冲突</a>）。如果合并后仍有未解决的冲突，则“合并冲突”节点将出现在 “更改”视图的相应更改列表中，并提供解决这些冲突的链接。</p><p>如果您的本地更改将被合并覆盖，IntelliJ IDEA 将建议执行智能合并。如果您选择此选项，IntelliJ IDEA 将<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#stash">存储</a>未提交的更改，执行合并，然后取消存储更改。</p><blockquote><p>您可以通过从Git Branches弹出窗口中选择Abort操作来取消未完成的合并操作。</p></blockquote></blockquote><p><strong>2、变基分支 (git-rebase)</strong>﻿</p><p>当您将<code>rebase</code>一个分支转移到另一个分支时，您可以将第一个分支的提交应用到第二个分支中的 HEAD 提交之上。</p><p>假设您创建了一个功能分支来处理特定任务并向该分支进行了多次提交：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/feature_branch_diagram.png" alt="特征分支"></p><p>当您在分支中开发时，您的队友会继续致力于掌握他们的工作：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/feature_branch_diverge_from_master_diagram.png" alt="功能分支与主分支分离"></p><p>当您执行操作时，您可以通过将您的提交应用到当前 HEAD 提交之上，将<code>rebase</code>您在功能分支中所做的更改集成到该分支中：<code>master``master</code></p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/rebase_result_diagram.png" alt="变基操作结果"></p><blockquote><p><strong>将一个分支重新建立在另一个分支之上</strong>﻿</p><ol><li><p>从主菜单中选择 Git | 变基：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_rebase_dialog.png" alt="Git 变基对话框"></p></li><li><p>从列表中，选择要将当前分支变基到的目标分支：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_rebase_choose_target_branch_no_interactive.png" alt="在 Git rebase 对话框中选择目标分支"></p></li><li><p>如果您需要从特定提交开始对源分支进行变基，而不是对整个分支进行变基，请单击修改选项并选择–onto。在源分支字段中，输入要将当前分支应用到新基础的提交的哈希值：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_rebase_specify_commit_no_interactive.png" alt="使用 --onto 指定提交哈希"></p><blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>要复制提交哈希，请在Log中选择它，右键单击它并选择Copy Revision Number。</p></blockquote></li><li><p>如果您要变基的分支当前未签出，请单击“修改选项”，单击“选择另一个要变基的分支”，然后从显示的列表中选择一个分支：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_rebase_choose_source_branch_no_interactive.png" alt="选择您想要变基的分支"></p><p>IntelliJ IDEA 将在开始变基操作之前检查此分支。</p></li><li><p>如果要对分支中可访问的所有提交进行变基，请单击修改选项并选择–root（有关此选项的更多信息，请参阅<a href="https://git-scm.com/docs/git-rebase">git-rebase</a>）。</p></li><li><p>如果您需要保留空提交（即不会从其父级更改任何内容的提交），请单击修改选项并选择–keep-empty（有关此选项的更多信息，请参阅<a href="https://git-scm.com/docs/git-rebase">git-rebase</a>）。</p></li><li><p>如果您想在变基期间保留合并提交以便将它们保留在分支历史记录中，请单击“修改选项”并选择–preserve-merges（此选项对于<code>interactive</code>变基不可用）。</p></li><li><p>单击变基。</p></li></ol><blockquote><p>您可以通过从Git 分支弹出窗口顶部分别选择“中止”或“继续”操作来取消未完成的变基操作或恢复中断的变基操作。</p></blockquote><p>如果不需要指定变基选项，则可以在不调用变基对话框的情况下启动变基。在“分支”弹出窗口或<a href="https://intellijidea.com.cn/help/idea/version-control-tool-window.html">Git</a>工具窗口的<a href="https://intellijidea.com.cn/help/idea/log-tab.html#branches_pane_context_menu">“分支”窗格</a>中，选择一个分支并选择以下操作之一：</p><ul><li>使用 Rebase （对于远程分支）拉入 Current以从所选分支中<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html#fetch">获取更改，并在这些更改的基础上对当前分支进行变基。</a></li><li>检出并重新定基到当前（对于远程和本地分支）以检出所选分支并将其重新定基到当前检出的分支之上。如果远程分支本地不存在，IntelliJ IDEA 将静默创建一个跟踪的本地分支，检出并重新设置基准。</li><li>将当前分支重新设置为所选分支（对于远程和本地分支）以将当前签出的分支重新设置为所选分支的基础。</li></ul></blockquote><p><strong>3、挑选单独的提交</strong>﻿</p><p>有时，您只需要将单个提交应用到不同的分支，而不是变基或合并整个分支。这可能很有用，例如，如果您正在一个功能分支中工作，并且想要集成在两个分支分歧后提交的master 的修补程序。或者您可能想要将修复向后移植到以前的版本分支。您可以通过使用Cherry-pick操作来完成此操作。</p><p>挑选操作的状态显示在状态栏中。您始终可以通过在Git Branches弹出窗口中选择Abort Cherry-Pick来中止正在进行的 Cherry-Pick 。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/cherry_pick_status.png" alt="樱桃采摘作业状况"></p><blockquote><p><strong>将提交应用到另一个分支</strong>﻿</p><ol><li><p>在<a href="https://intellijidea.com.cn/help/idea/manage-branches.html">“分支”</a>弹出窗口（主菜单Git | Branches）中，选择要将更改集成到的目标分支，然后从弹出菜单中选择“签出”以切换到该分支。</p></li><li><p>打开 Git工具窗口 并切换到“日志”选项卡。<code>Alt</code> <code>9</code></p></li><li><p>找到包含您要挑选的更改的提交。</p><p>您可以按分支、用户或日期过滤提交。您还可以单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.inspectionsEye.svg" alt="眼睛图标">工具栏上的 并选择突出显示| 未选择的提交选项可将已应用于当前分支的提交灰显。如果您知道提交哈希，或者正在寻找标记的提交，您还可以使用“转到哈希&#x2F;分支&#x2F;标记”操作（按Git 工具窗口 的 “日志”选项卡，或单击工具栏上的 ）。Ctrl0FAlt09<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.find.svg" alt="搜索"></p></li><li><p>选择所需的提交。使用“提交详细信息”区域中的信息来确保这些是您想要传输到另一个分支的更改。</p></li><li><p>单击工具栏上的择优挑选。 <img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.icons.cherryPick.svg" alt="择优选择按钮">IntelliJ IDEA 将应用更改并将更改提交到目标分支。</p></li><li><p>如果挑选因冲突而失败，所选更改将显示在“更改”区域中，您可以在“更改”视图中看到 。您可以查看这些更改并在必要时稍后提交。</p><p>如果您希望 IntelliJ IDEA 在cherry-pick失败的情况下自动创建变更列表，请在“设置”|“设置”中打开相应的设置。版本控制 | 变更列表。</p></li><li><p>将更改推送到目标分支。</p></li></ol></blockquote><p><strong>4、应用单独的更改</strong>﻿</p><p>想象一下，您对一个文件进行了一些更改，并希望将其应用到不同的分支，但这些更改是与其他修改的文件一起提交的。IntelliJ IDEA 允许您应用单独的更改，而不是挑选整个提交。</p><blockquote><ol><li><p>在<a href="https://intellijidea.com.cn/help/idea/manage-branches.html">“分支”</a>弹出窗口（主菜单Git | Branches）中，选择要将更改集成到的目标分支，然后从弹出菜单中选择“签出”以切换到该分支。</p></li><li><p>打开 Git工具窗口 并切换到“日志”选项卡。Alt09</p></li><li><p>找到包含您要应用的更改的提交。</p><p>您可以按分支、用户或日期过滤提交。您还可以单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.inspectionsEye.svg" alt="眼睛图标">工具栏上的 并选择突出显示| 未选择的提交选项可将已应用于当前分支的提交灰显。如果您知道提交哈希，或者正在寻找标记的提交，您还可以使用“转到哈希&#x2F;分支&#x2F;标记”操作（按Git 工具窗口 的 “日志”选项卡，或单击工具栏上的 ）。<code>Ctrl</code> <code>F</code> <code>Alt</code> <code>9</code> <img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.find.svg" alt="搜索"></p></li><li><p>在右侧的“提交详细信息”窗格中，选择包含要应用到目标分支的更改的文件，然后从上下文菜单中选择“Cherry-Pick Selected Changes” 。</p></li><li><p>在打开的对话框中，选择现有变更列表或输入新变更列表的名称，然后单击“确定”。</p></li><li><p>提交更改，然后将其推送到目标分支。</p></li></ol></blockquote><p><strong>5、应用单独的文件</strong>﻿</p><p>除了对单个文件应用单独的更改之外，您还可以将整个文件的内容复制到不同的分支。例如，如果目标分支中不存在要应用的文件，或者在多次提交中对其进行了更改，这可能很有用。</p><blockquote><ol><li><p><a href="https://intellijidea.com.cn/help/idea/manage-branches.html#switch-branches">切换</a>到将应用更改的分支。</p></li><li><p>在<a href="https://intellijidea.com.cn/help/idea/manage-branches.html">“分支”</a>弹出窗口（主菜单Git | Branches）或 Git工具窗口的“分支”窗格中，选择包含要应用的文件的分支，然后从上下文菜单中选择“显示与工作树的差异” 。</p><p>打开的“更改”工具窗口显示所选分支中与当前签出的分支相比不同的所有文件的列表：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/ij_git_branches_diff.png" alt="显示所选分支和当前工作树之间的差异"></p><ul><li>所选分支中存在且当前分支中缺失的文件标记为灰色。</li><li>当前分支中存在但所选分支中缺失的文件标记为绿色。</li><li>包含所选分支和当前分支之间差异的文件用蓝色标记。</li></ul><p>您可以单击“交换分支”链接来更改将哪个分支视为与其他分支进行比较的基础。</p></li><li><p>选择要应用到当前分支的文件，然后从上下文菜单中选择“从分支获取”<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.download.svg" alt="从分行获取">或单击工具栏上的 。</p></li><li><p>提交并推动更改。IntelliJ IDEA 会将文件的全部内容复制到当前分支。</p></li></ol><blockquote><p>您还可以从“项目”视图将文件应用到另一个分支：选择包含要复制的文件的文件夹，然后选择“Git |”。与分支比较| 从上下文菜单中选择<branch_name> ，然后单击工具栏上的“获取”图标。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.download.svg" alt="得到"></p></blockquote></blockquote><h2 id="解决-Git-冲突"><a href="#解决-Git-冲突" class="headerlink" title="解决 Git 冲突"></a>解决 Git 冲突</h2><p>当您在团队中工作时，您可能会遇到有人将更改推送到您当前正在处理的文件的情况。如果这些更改不重叠（即，对不同的代码行进行了更改），则会自动合并冲突的文件。但是，如果相同的行受到影响，Git 无法随机选择一侧而不是另一侧，并要求您解决冲突。</p><p>在 Git 中，当您尝试执行以下操作之一时可能会出现冲突：<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html#pull">pull</a>、<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#merge">merge</a>、<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#rebase-branch">rebase</a>、<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#cherry-pick">cherry-pick</a>、<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#unstash">unstash 更改</a>或<a href="https://intellijidea.com.cn/help/idea/using-patches.html#apply-patch">apply a patch</a>。如果存在冲突，这些操作将失败，并且系统将提示您接受上游版本、首选您的版本或合并更改：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/merge_conflicts_dialog.png" alt="合并冲突的文件对话框"></p><p>当在 Git 级别检测到冲突时，会自动触发“冲突”对话框。</p><p>如果您在此对话框中单击“关闭”或从命令行调用导致合并冲突的 Git 操作，则“本地更改”视图中将出现“合并冲突”节点，并提供用于解决这些问题的链接：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_merge_conflicts_node.png" alt="本地更改视图中的合并冲突节点"></p><p>IntelliJ IDEA 提供了一个在本地解决冲突的工具。该工具由三个窗格组成：</p><ul><li>左侧窗格显示只读本地副本</li><li>右窗格显示签入存储库的只读版本。</li><li>中央窗格是一个功能齐全的编辑器，其中显示解决冲突的结果。最初，此窗格的内容与文件的基本修订版本相同，即派生两个冲突版本的修订版本。</li></ul><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflict_resolution_tool_legend.png" alt="冲突解决工具中的颜色编码"></p><blockquote><p><strong>解决冲突</strong>﻿</p><ol><li><p>单击“冲突”对话框中的“合并”、“本地更改”视图中的“解决”链接，或在编辑器中选择冲突文件并选择“VCS | ”。git | git 从主菜单解决冲突。</p></li><li><p>要自动合并所有不冲突的更改，请单击工具栏上的<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.diff.applyNotConflicts.svg" alt="应用不冲突的更改按钮">(应用所有不冲突的更改)。您还可以使用<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.diff.applyNotConflictsLeft.svg" alt="从左侧应用不冲突的更改按钮">（从左侧应用非冲突更改）和<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.diff.applyNotConflictsRight.svg" alt="从右侧按钮应用不冲突的更改">（从右侧应用非冲突更改）分别合并对话框左&#x2F;右部分的非冲突更改。</p></li><li><p>要解决冲突，您需要选择对左侧（本地）和右侧（存储库）版本应用哪个操作（接受<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.diff.arrow.svg" alt="接受按钮">或忽略），并在中央窗格中检查生成的代码：<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.diff.remove.svg" alt="忽略按钮"></p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/resolveConflict.png" alt="解决冲突"></p><p>您还可以右键单击中央窗格中突出显示的冲突，然后使用上下文菜单中的命令。使用左侧解决和使用右侧解决命令分别提供了从一侧接受更改并从另一侧忽略更改的快捷方式：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/resolve_using_left_right.png" alt="冲突更改的上下文菜单"></p><p>对于简单冲突（例如，如果同一行的开头和结尾已在不同的文件修订版中修改），可以使用“解决简单冲突” <img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.diff.magicResolve.svg" alt="解决简单冲突按钮">按钮，该按钮允许一键合并更改。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/simple_conflict_resolve.png" alt="解决简单冲突按钮"></p><p>此类冲突无法通过“应用所有非冲突更改”操作来解决，因为您必须确保它们得到正确解决。</p><blockquote><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3><p>请注意，中央窗格是一个功能齐全的编辑器，因此您可以直接在此对话框中更改结果代码。</p></blockquote></li><li><p>比较不同版本以解决冲突也可能很有用。使用<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.diff.svg" alt="比较内容按钮">工具栏按钮调用选项列表。请注意，Base是指本地版本和存储库版本源自的文件版本（最初显示在中间窗格中），而Middle是指结果版本。</p></li><li><p>在中央窗格中查看合并结果，然后单击“应用”。</p></li></ol></blockquote><p><strong>1、生产力技巧</strong>﻿</p><blockquote><p>自动应用不冲突的更改</p><p>您可以将 IntelliJ IDEA 配置为始终自动应用不冲突的更改，而不是从“合并”对话框中告诉它这样做。为此，请选择“工具”| “自动应用不冲突的更改”选项。IDE 设置的 Diff Merge页面。<code>Ctrl</code> <code>Alt</code> <code>S</code></p></blockquote><blockquote><p>在中央窗格中管理更改</p><p>您可以使用将鼠标悬停在装订线中的更改标记上然后单击它时出现的工具栏来管理中央窗格中的更改。工具栏与一个框架一起显示，该框架显示修改行的先前内容：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflicts_change_toolbar.png" alt="更改工具栏"></p><p>例如，当存在多个不冲突的更改时，您只需跳过其中一两个更改，则可以更轻松地使用“应用所有不冲突的更改”操作同时应用所有更改，然后使用“还原”撤消不需要的更改。从此工具栏执行操作。</p></blockquote><p><strong>2、处理与 LF 和 CRLF 行结尾相关的冲突</strong>﻿</p><p>通常，在团队中工作并为同一存储库做出贡献的人们使用不同的操作系统。这可能会导致行结束问题，因为 Unix、Linux 和 macOS 使用<code>LF</code>，而 Windows 使用<code>CRLF</code>来标记行结束。</p><p>IntelliJ IDEA 在差异查看器中显示行结尾的差异，以便您可以手动修复它们。如果您希望 Git 自动解决此类冲突，则需要在 Windows 上将该<code>core.autocrlf</code>属性设置为to ，在 Linux 和 macOS 上则需要将该属性设置为 to（更多详细信息，请参阅<a href="https://help.github.com/articles/dealing-with-line-endings/">处理行结尾</a>）。您可以通过在 Windows 或Linux 和 macOS 上运行来手动更改配置。<code>true``input``git config --global core.autocrlf true``git config --global core.autocrlf input</code></p><p>但是，IntelliJ IDEA 可以自动分析您的配置，在您要提交<code>CRLF</code>到远程存储库时发出警告，并建议将设置设置<code>core.autocrlf</code>为<code>true</code>或<code>input</code>取决于您的操作系统。</p><p>要启用对<code>LF</code>和<code>CRLF</code>行分隔符的智能处理，请打开“设置”对话框，然后选择“版本控制”|“版本控制”|“版本控制”。左侧的Git节点。启用“如果将要提交 CRLF 行分隔符则发出警告”选项。CtrlAlt0S</p><p>启用此选项后，每次您要提交带有分隔符的文件时， IntelliJ IDEA 都会显示行分隔符警告对话框，除非您在受影响的文件中<code>CRLF</code>设置了任何相关的<a href="https://www.kernel.org/pub/software/scm/git/docs/gitattributes.html">Git 属性</a>（在这种情况下，IntelliJ IDEA 假设您清楚地了解您在做什么并从分析中排除该文件）。</p><p>在“行分隔符警告”对话框中，单击以下选项之一：</p><ul><li>按原样提交忽略警告并提交带有<code>CRLF</code>分隔符的文件。</li><li>修复并提交以将<code>core.autocrlf</code>属性设置为<code>true</code>或<code>input</code>取决于您的操作系统。因此，行分隔符将在提交之前<code>CRLF</code>被替换。<code>LF</code></li></ul><p>如果稍后您需要查看合并过程中冲突的具体解决情况，可以在 Git工具窗口 的 “日志”选项卡中找到所需的合并提交，然后在右侧的“提交详细信息”窗格中选择有冲突的文件，然后单击或按。有关详细信息，请参阅<a href="https://intellijidea.com.cn/help/idea/investigate-changes.html#review_merge_commit">查看如何合并更改</a>。<code>Alt</code> <code>9</code><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.diff.svg" alt="显示差异图标"><code>Ctrl</code> <code>D</code></p><h2 id="使用-Git-同时处理多个功能"><a href="#使用-Git-同时处理多个功能" class="headerlink" title="使用 Git 同时处理多个功能"></a>使用 Git 同时处理多个功能</h2><p>有时，您需要在未完成的任务之间切换，然后再返回。IntelliJ IDEA 为您提供了几种方法来方便地处理多种不同的功能，而不会丢失您的工作：</p><ul><li><p>您可以<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#stash">隐藏</a>或<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#shelve">搁置</a>待处理的更改。</p><p>隐藏更改与搁置非常相似。唯一的区别在于补丁的生成和应用方式。存储由 Git 生成，可以从 IntelliJ IDEA 内部或外部应用。搁置更改的补丁由 IntelliJ IDEA 生成，也通过 IDE 应用。此外，存储涉及所有未提交的更改，而当您将更改放入搁置时，您可以选择一些本地更改，而不是搁置所有更改。</p></li><li><p>您可以<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#changelists">将与不同任务或功能相关的更改保留在不同的更改列表中</a>。</p></li><li><p>您可以创建<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#feature-branches">分支来处理不同的不相关功能</a>。</p></li></ul><p><strong>1、搁置变更</strong>﻿</p><p>搁置是暂时存储您尚未提交的待处理更改。例如，如果您需要切换到另一个任务，并且希望将更改放在一边以供稍后处理，则这非常有用。</p><p>使用 IntelliJ IDEA，您可以搁置单独的文件和整个变更列表。</p><blockquote><p>您无法搁置未版本化的文件，即尚未<a href="https://intellijidea.com.cn/help/idea/adding-files-to-version-control.html#add-files-to-vcs">添加到版本控制的</a>文件。</p></blockquote><p>搁置后，可以根据需要多次应用更改。</p><blockquote><p><strong>搁置变更</strong>﻿</p><ol><li><p>在 “提交”工具窗口中，右键单击要搁置的文件或更改列表，然后从上下文菜单中选择“搁置更改” 。<code>Alt</code> <code>0</code></p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/shelve-changes.png" alt="搁置变化"></p></li><li><p>在“搁置更改”对话框中，查看已修改文件的列表。</p></li><li><p>在“提交消息”字段中，输入要创建的架子的名称，然后单击“架子更改”按钮。</p></li></ol><p>您还可以静默搁置更改，而不显示“搁置更改”对话框。为此，请选择要搁置的文件或更改列表，然后单击工具栏上的“静默搁置”图标或按。包含要搁置的更改的更改列表的名称将用作搁置名称。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.shelveSilent.svg" alt="默默搁置"><code>Ctrl</code> <code>Shift</code> <code>H</code></p><p>为了避免出现多个同名的架子（例如Default），您可以将文件或更改列表从“提交到 <branch>”选项卡拖到“提交”工具窗口的“架子”选项卡，稍等片刻直到它被激活，释放鼠标按钮后编辑新的架子名称。</p><blockquote><p>如果您需要将更改复制到架子而不重置本地更改，请按并查找“保存到架子”操作。<code>Ctrl</code> <code>Shift</code> <code>A</code></p></blockquote></blockquote><blockquote><p><strong>取消搁置变更</strong>﻿</p><p>取消搁置是将推迟的更改从搁架移动到待处理的更改列表。未搁置的更改可以从视图中过滤掉或从搁置中删除。</p><ol><li><p>在<a href="https://intellijidea.com.cn/help/idea/shelf-tab.html">“搁置”</a>选项卡中，选择更改列表或要取消搁置的文件。</p></li><li><p>按或从所选内容的上下文菜单中选择“取消搁置” 。<code>Ctrl</code> <code>Shift</code> <code>U</code></p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/py_unshelve_changes.png" alt="取消搁置变更"></p></li><li><p>在“取消搁置更改”对话框中，在“名称”字段中指定要将未搁置的更改恢复到的更改列表。您可以从列表中选择现有变更列表或输入要创建的新变更列表的名称。您可以在注释字段中输入新变更列表的描述（可选）。</p><p>如果您想让新的更改列表处于活动状态，请选择“设置活动”。否则，当前活动变更列表保持活动状态。</p></li><li><p>如果您希望 IntelliJ IDEA 在停用时保存与新变更列表关联的任务的上下文，并在变更列表变为活动状态时恢复上下文，请选择“跟踪上下文”选项（有关详细信息，请参阅<a href="https://intellijidea.com.cn/help/idea/managing-tasks-and-context.html">任务和上下文）。</a></p></li><li><p>如果要删除要取消搁置的更改，请选择“从搁置中删除已成功应用的文件”选项。未搁置的文件将从该搁置中删除，添加到另一个更改列表中，并标记为已应用。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.gc.svg" alt="删除图标">只有通过单击工具栏上的 或从上下文菜单中选择清理已取消搁置来明确删除它们，它们才会被完全删除。</p><blockquote><p>如果您意外删除了未搁置的文件，您可以从“最近删除”节点查看和恢复它们。</p></blockquote></li><li><p>单击“确定”。如果修补版本与当前版本发生冲突，请按照<a href="https://intellijidea.com.cn/help/idea/resolving-conflicts.html">解决冲突</a>中的说明进行解决。</p></li></ol><p>您还可以静默取消搁置更改，而不显示“取消搁置更改”对话框。为此，请选择要取消搁置的文件或更改列表，然后单击工具栏上的“静默取消搁置”图标或按。未搁置的文件将移至活动的挂起更改列表。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.unshelveSilent.svg" alt="默默取消搁置图标"><code>Ctrl</code> <code>Alt</code> <code>U</code></p><p>您还可以将文件或更改列表从“搁置”选项卡拖到“提交到 <branch>”选项卡以静默取消搁置。如果按住键拖动它，它将被复制到“提交到分支”选项卡，但也会保留在架子中。<code>Ctrl</code></p></blockquote><blockquote><p><strong>放弃搁置的更改</strong>﻿</p><ol><li>在“书架”视图中，选择包含您不想再保留的更改的更改列表。</li><li>右键单击更改列表，然后从上下文菜单中选择“删除”或按。<code>Delete</code></li></ol></blockquote><blockquote><p><strong>恢复未搁置的更改</strong>﻿</p><p>IntelliJ IDEA 允许您在必要时重新应用未搁置的更改。所有未搁置的更改都可以重复使用，直到通过单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.gc.svg" alt="删除未搁置的更改">工具栏上的图标或从上下文菜单中选择“清理已未搁置”来明确删除它们为止。</p><ol><li>确保已启用显示已取消搁置的工具栏选项。 <img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.patch_applied.svg" alt="显示已下架按钮"></li><li>选择要恢复的文件或架子。</li><li>从所选内容的上下文菜单中，选择“恢复”。</li></ol></blockquote><blockquote><p><strong>应用外部补丁</strong>﻿</p><p>您可以导入在 IntelliJ IDEA 内部或外部创建的补丁，并将它们作为搁置的更改应用。</p><ol><li>在Shelf视图中，从上下文菜单中选择Import Patches 。</li><li>在打开的对话框中，选择要应用的补丁文件。选定的补丁将在“Shelf”选项卡中显示为“shelf”。</li><li>选择新添加的带有补丁的架子，然后从所选内容的上下文菜单中选择“取消搁置更改” 。</li></ol></blockquote><blockquote><p><strong>自动搁置基础修订</strong>﻿</p><p>将 IntelliJ IDEA 配置为始终搁置受 Git 版本控制的文件的基本修订版本可能很有用。</p><ol><li><p>按打开 IDE 设置，然后选择版本控制 | 架子。<code>Ctrl</code> <code>Alt</code> <code>S</code></p></li><li><p>选择“在分布式版本控制系统下搁置文件的基本修订版本”选项。</p><p>如果启用此选项，文件的基本修订版本将保存到架子上，如果应用架子导致冲突，则该架子将在<a href="https://en.wikipedia.org/wiki/Merge_(version_control)#Three-way_merge">三向合并</a>期间使用。如果禁用，IntelliJ IDEA 将在项目历史记录中查找基础修订版，这可能需要一段时间；此外，冲突架所基于的修订可能会丢失（例如，如果历史记录因变基操作而更改）。</p></li></ol></blockquote><blockquote><p><strong>更改默认架子位置</strong>﻿</p><p>默认情况下，shelf 目录位于您的项目目录下。但是，您可能想要更改默认的架子位置。例如，如果您想避免在清理工作副本时意外删除架子，或者希望将它们存储在单独的存储库中，以便在团队成员之间共享架子，这可能很有用。</p><ol><li>按打开 IDE 设置，然后选择版本控制 | 架子。<code>Ctrl</code> <code>Alt</code> <code>S</code></li><li>单击更改书架位置并在打开的对话框中指定新位置。</li><li>如有必要，选择将架子移动到新位置以将现有架子移动到新目录。</li></ol></blockquote><p><strong>2、隐藏更改</strong>﻿</p><p>有时可能需要恢复工作副本以匹配 HEAD 提交，但您不想丢失已经完成的工作。如果您了解到存在可能与您正在做的事情相关的上游更改，或者您需要进行一些紧急修复，则可能会发生这种情况。</p><p>存储涉及记录 HEAD 提交和工作目录当前状态（存储）之间的差异。对索引的更改也可以被隐藏。</p><p>取消存储涉及将存储的存储应用到分支。</p><p>您可以将存储应用到现有分支或在其基础上创建新分支。</p><p>存储可以根据需要多次应用到您需要的任何分支，只需<a href="https://intellijidea.com.cn/help/idea/manage-branches.html#switch-branches">切换到所需的分支</a>即可。请记住：</p><ul><li>在一系列提交后应用存储会导致需要解决的冲突。</li><li>您不能将存储应用到“脏”工作副本，即具有未提交更改的工作副本。</li></ul><blockquote><p><strong>将更改保存到存储中</strong>﻿</p><ol><li>转到 Git | 未提交的更改 | 隐藏更改。</li><li>在打开的“存储”对话框中，选择适当的 Git 根目录并确保签出正确的分支。</li><li>在“消息”字段中描述您要存储的更改。</li><li>要存储本地更改并将索引中暂存的更改引入工作树以进行检查和测试，请选择“保留索引”选项。</li><li>单击创建存储。</li></ol></blockquote><blockquote><p><strong>应用隐藏</strong>﻿</p><ol><li><p>转到 Git | 未提交的更改 | 取消隐藏更改。</p></li><li><p>选择要应用存储的 Git 根目录，并确保签出正确的分支。</p></li><li><p>从列表中选择您想要应用的存储。</p><p>如果您想检查所选存储中哪些文件受到影响，请单击“查看”。</p></li><li><p>要在应用所选存储后将其删除，请选择“弹出存储”选项。</p></li><li><p>要同时应用隐藏的索引修改，请选择“恢复索引”选项。</p></li><li><p>如果您想基于所选存储创建新分支，而不是将其应用到当前签出的分支，请在作为新分支字段中输入该分支的名称。</p></li></ol><p>要删除存储，请在列表中选择它，然后单击“删除”。要删除所有隐藏内容，请单击“清除”。</p></blockquote><p><strong>3、将更改分组到不同的更改列表中</strong>﻿</p><p>当您正在开发多个相关功能时，您可能会发现将更改分组到不同的<a href="https://intellijidea.com.cn/help/idea/managing-changelists.html">更改列表</a>中很方便。与使用<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#feature-branches">功能分支</a>来处理多个任务相比，这种方法有其优点和缺点。</p><p>优点：</p><ul><li>您可以轻松地在不同的逻辑更改集之间切换，并分别提交它们。</li><li>与出于相同目的使用分支不同，您可以随时进行所有更改，而无需在分支之间切换，如果您的项目非常大，这可能需要一段时间。</li><li>测试不同功能如何协同工作很方便。</li><li>您可以在构建服务器上远程运行更改列表。</li></ul><p>缺点：</p><ul><li>虽然与分支相比，使用更改列表似乎是一个更轻量级的选项，但它并不安全，因为在提交并推送更改之前，没有更改的备份。如果您的本地工作副本发生问题，您的所有更改都将丢失，因为它们不属于 Git 项目历史记录。</li><li>不可能对功能进行原子测试。</li><li>不可能就同一功能进行协作。此外，除非您通过电子邮件发送包含更改的补丁，否则您无法从不同的计算机进行贡献，这可能不是很方便。</li></ul><p>所有更改列表都显示在 “提交到 <branch>”选项卡的“更改”视图中。所有修改的文件都会自动放置在活动变更列表中，即“更改”变更列表，除非您创建了不同的变更列表并将其激活。</p><p>更改列表显示在 “更改”视图中。最初，有一个名为Changes的默认更改列表。所有新更改都会自动放入更改更改列表中。还有一个未版本控制的文件更改列表，用于对尚未<a href="https://intellijidea.com.cn/help/idea/adding-files-to-version-control.html#add-files-to-vcs">添加到 VCS 中的</a>新创建的文件进行分组。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changelists_in_commit_tw.png" alt="提交工具窗口中的更改列表"></p><p>您可以根据需要<a href="https://intellijidea.com.cn/help/idea/managing-changelists.html#new_changelist">创建任意数量的更改列表</a>，并随时<a href="https://intellijidea.com.cn/help/idea/managing-changelists.html#active-changelist">使其中任何一个更改列表处于活动状态。</a>您可以<a href="https://intellijidea.com.cn/help/idea/managing-changelists.html#move-between-changelists">将</a>任何未提交的更改移至任何更改列表。</p><blockquote><p><strong>创建新的变更列表</strong>﻿</p><ol><li>在“本地更改”视图中，单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.changelist.svg" alt="更改列表图标">工具栏上的 并选择“新建更改列表”。</li><li>在“新建更改列表”对话框中，指定新更改列表的名称，并添加说明（可选）。</li></ol></blockquote><blockquote><p><strong>设置活动变更列表</strong>﻿</p><ul><li>在“本地更改”视图中，选择一个非活动更改列表，然后按或右键单击它，然后从上下文菜单中选择“设置活动更改列表” 。所有新的更改都会自动放入此更改列表中。<code>Ctrl</code> <code>Space</code></li></ul></blockquote><blockquote><h3 id="在更改列表之间移动更改"><a href="#在更改列表之间移动更改" class="headerlink" title="在更改列表之间移动更改"></a>在更改列表之间移动更改</h3><ol><li>在“本地更改”视图中，选择要移动到另一个更改列表的更改。</li><li>右键单击所选内容或单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.changelist.svg" alt="更改列表图标">工具栏上的 并选择“移动到另一个更改列表” 。<code>Alt</code> <code>Shift</code> <code>M</code></li><li>在打开的对话框中，选择现有变更列表或输入新变更列表的名称。</li><li>您可以选择使目标更改列表处于活动状态并跟踪其上下文（IntelliJ IDEA 将保存与此更改列表关联的上下文，并在该更改列表变为活动状态时恢复它）。</li></ol><blockquote><p>您还可以在更改列表之间拖动文件。</p></blockquote><blockquote><p>有关将一个文件中的更改放入 Git 中的不同更改列表的更多信息，请参阅将<a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#put_changes_into_different_changelists">更改放入不同的更改列表</a>。</p></blockquote></blockquote><blockquote><p><strong>删除变更列表</strong>﻿</p><ul><li>右键单击更改列表，然后从上下文菜单中选择“删除更改列表” 。</li></ul></blockquote><p><strong>4、使用功能分支</strong>﻿</p><p>Git 中的分支代表独立的开发线，因此，如果您正在开发一个单独的功能，并且希望在准备好共享工作结果并将其集成到 中之前完成并测试该功能，那么在功能分支中执行此操作<code>master</code>是最好的解决方案。通过这种方式，您可以确保不稳定的代码不会提交到项目的主代码库，并且如果需要，您可以轻松切换到其他任务。</p><p>优点：</p><ul><li>与使用变更列表对变更进行分组相反，使用功能分支是安全的。在您向 Git 提交更改后，它们将成为 Git 项目历史记录的一部分，因此即使您损坏了工作树，您也始终可以通过<a href="https://git-scm.com/docs/git-reflog">Git reflog</a>恢复您的提交。推送更改后，它们就会被备份。</li><li>您可以开发并行的不相关功能并以原子方式测试它们。</li><li>当您完成分支中的开发后，您可以<a href="https://intellijidea.com.cn/help/idea/edit-project-history.html#interactive-rebase">重新排序或压缩提交</a>，以便您的历史记录是线性且干净的。</li><li>可以轻松地就您的功能进行协作，或者从不同的机器上进行开发。</li></ul><p>缺点：</p><ul><li>在非常大的项目上切换分支可能需要时间。</li><li>一起测试相关功能不太方便。</li><li>您必须学习<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#feature-branches">使用功能分支</a>并将更改集成到主代码库中的工作流程。</li></ul><p>使用功能分支并将更改集成到主代码库中有两种主要方法：</p><ul><li><a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#merge-option">合并</a>选项</li><li><a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#rebase-option">变基</a>选项</li></ul><p><strong>①、使用合并来集成功能分支中的更改</strong>﻿</p><p>合并选项的主要好处是完全可追溯性，因为合并到主代码库中的提交保留了其原始哈希值和作者，并且属于一项功能的所有提交都可以分组在一起。</p><p>此工作流程适用于向主代码库提交更改涉及<a href="https://intellijidea.com.cn/help/idea/work-with-github-pull-requests.html#create-pull-request">拉取请求</a>或分层审批程序的项目，因为现有分支不会以任何方式更改。</p><p>这种方法的主要缺点是，每次需要合并更改时都会创建无关的合并提交，这会严重污染项目历史记录并使其难以阅读。</p><blockquote><ol><li>为您单独的开发线<a href="https://intellijidea.com.cn/help/idea/manage-branches.html#create-branch">创建一个分支。</a></li><li><a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#commit">在开发时提交</a>更改。</li><li><a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html">将您的分支推</a>送到远程存储库。这样做是为了备份，以便您可以在不同的计算机上进行协作或工作。</li><li>当您需要执行与您的功能无关的工作时，请切换到不同的分支。</li><li>对您的功能进行审查和测试，并进行必要的修复。</li><li>当您准备好将工作结果集成到主分支中时（例如<code>master</code>），请执行以下操作：<ol><li><a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#merge">将</a>您的功能分支合并到主代码库中。</li><li><a href="https://intellijidea.com.cn/help/idea/manage-branches.html#delete-branch">删除功能分支</a>。</li><li>推。</li></ol></li></ol></blockquote><p><strong>②、使用 rebase 集成功能分支中的更改</strong>﻿</p><p>此选项的主要好处是您可以获得清晰的项目历史记录，易于其他人阅读和理解。您的日志不包含操作产生的不必要的合并提交<code>merge</code>，并且您可以获得易于导航和搜索的线性历史记录。</p><p>然而，当决定采用此工作流程时，您应该记住，这会<code>rebase</code>重写项目历史记录，因为它会为原始功能分支中的每个提交创建新的提交，因此它们将具有不同的哈希值，这会阻碍可追溯性。</p><blockquote><ol><li><p>为您单独的开发线<a href="https://intellijidea.com.cn/help/idea/manage-branches.html#create-branch">创建一个分支。</a></p></li><li><p><a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#commit">在开发过程中经常提交</a>更改。</p></li><li><p><a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html">将您的分支推</a>送到远程存储库。这样做是为了备份，以便您可以在不同的计算机上进行协作或工作。</p></li><li><p><code>master</code>时不时地<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#rebase-branch">重新调整</a>你的功能分支。仅当您的功能分支很长时才有意义。这对于：</p><ul><li>确保你的功能分支<code>master</code>不会相距太远。</li><li>当您最终将更改集成到主代码库中时，避免解决大量冲突。当您定期进行变基时，您可以迭代地解决冲突，并且不会最终因长期差异而苦苦挣扎。</li><li>加快检查分支的速度，因为一旦分支足够分散，分支之间的切换就会变慢。</li></ul><p>变基涉及以下步骤：</p><ol><li>从远程<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html#fetch">获取</a>更改，或将更改<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html#pull">拉</a><code>master</code>入分支。</li><li>将您的分支<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#rebase-branch">重新定位</a><code>master</code>到.</li><li><a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#force-push">强制将</a>操作结果推<code>rebase</code>送到您的功能分支。</li></ol></li><li><p><code>master</code>当您需要执行与您的功能无关的工作时切换到。当您返回到功能分支时，执行Checkout 并 Rebase 到 Current。</p></li><li><p>对您的功能进行审查和测试，并进行必要的修复。</p></li><li><p>当您的功能完成后，执行交互式变基。这允许您<a href="https://intellijidea.com.cn/help/idea/edit-project-history.html#interactive-rebase">重新排序和压缩</a>提交，以使您的功能分支历史记录看起来干净整洁。</p></li><li><p>当您准备好将工作结果集成到主分支中时（例如<code>master</code>），请执行以下操作：</p><ol><li><a href="https://intellijidea.com.cn/help/idea/manage-branches.html#checkout-branch">去</a>分行看看<code>master</code>吧</li><li><a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#merge">将</a>您的分支与<code>master</code>. 由于<code>master</code>没有分歧，Git 只会将指针向前移动到功能分支的最新提交，而不是创建新的合并提交（这称为快进合并）。</li><li><a href="https://intellijidea.com.cn/help/idea/manage-branches.html#delete-branch">删除功能分支</a>。</li><li><a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html">推</a>。</li></ol></li></ol><p>使用您的姓名缩写或昵称（如果很短）作为功能分支名称的前缀是有意义的。这样，您始终可以使用“分支机构”菜单中的快速搜索轻松找到所有分支机构。</p></blockquote><h2 id="撤消-Git-存储库中的更改"><a href="#撤消-Git-存储库中的更改" class="headerlink" title="撤消 Git 存储库中的更改"></a>撤消 Git 存储库中的更改</h2><blockquote><p><strong>恢复未提交的更改</strong>﻿</p><p>在提交之前，您始终可以在本地撤消所做的更改：</p><ul><li>在 “提交”工具窗口中，选择一个或多个要还原的文件，然后从上下文菜单中选择“回滚” ，或按。<code>Alt</code> <code>0</code> <code>Ctrl</code> <code>Alt</code> <code>Z</code></li></ul><p>自上次提交以来对所选文件所做的所有更改都将被丢弃，并且它们将从活动更改列表中消失。</p></blockquote><blockquote><p><strong>取消暂存文件</strong>﻿</p><p>默认情况下，IntelliJ IDEA 使用<a href="https://intellijidea.com.cn/help/idea/managing-changelists.html">更改列表</a>概念，其中修改的文件会自动暂存。</p><ul><li>如果文件已处于版本控制之下，并且您不想提交它，您可以：<ul><li><a href="https://intellijidea.com.cn/help/idea/adding-files-to-version-control.html">从提交中删除它</a>：不要在提交工具窗口的更改区域中选择它。</li><li><a href="https://intellijidea.com.cn/help/idea/managing-changelists.html#move-between-changelists">将其移至另一个变更列表</a>。</li></ul></li><li>如果您更习惯暂存概念，请选择版本控制 |中的启用暂存区域选项。IDE 设置的 Git页面。<code>Ctrl</code> <code>Alt</code> <code>S</code></li></ul><p>此外，默认情况下 IntelliJ IDEA 建议将每个新创建的文件添加到版本控制下。您可以在“设置”|“设置”中更改此行为。版本控制 | 分别使用“创建文件时”和“删除文件时”设置进行确认。</p></blockquote><blockquote><p><strong>撤消最后一次提交</strong>﻿</p><p>IntelliJ IDEA 允许您撤消当前分支中的最后一次提交。</p><blockquote><p>如果提交被推送到受保护的分支，则无法撤消该提交，即不允许使用<a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#force-push">强制 –push</a>的分支（在IDE 设置的 版本控制 | Git页面中配置受保护的分支）请注意，如果分支被标记由于 GitHub 上受保护，当您签出时，IntelliJ IDEA 会自动将其标记为受保护。<code>Ctrl</code> <code>Alt</code> <code>S</code></p></blockquote><ol><li>打开 Git工具窗口 并切换到“日志”选项卡。<code>Alt</code> <code>9</code></li><li>选择当前分支中的最后一次提交，然后从上下文菜单中选择“撤消提交” 。</li><li>在打开的对话框中，选择一个更改列表，您要放弃的更改将移至其中。您可以从名称列表中选择现有变更列表，也可以指定新变更列表的名称（默认情况下使用提交消息）。</li><li>如果您想要使用要放弃活动更改列表的更改来创建更改列表，请选择“设置活动”选项。</li><li>如果您希望 IntelliJ IDEA 记住您的上下文并在此更改列表变为活动状态时重新加载编辑器中当前打开的文件，请选择“跟踪上下文”选项。</li></ol></blockquote><blockquote><p><strong>恢复推送的提交</strong>﻿</p><p>如果您发现已推送的特定提交中有错误，您可以恢复该提交。此操作会产生一个新的提交，该提交会逆转您要撤消的提交的效果。因此，项目历史记录被保留，因为原始提交保持不变。</p><ol><li><p>在Git工具窗口 的 “日志”选项卡中找到要还原的提交 ，右键单击它并从上下文菜单中选择“还原提交” 。也可以从文件<a href="https://intellijidea.com.cn/help/idea/version-control-tool-window-history-tab.html">历史记录</a>视图中提交的上下文菜单中使用此选项。“提交更改”对话框将打开，其中包含自动生成的提交消息。<code>Alt</code> <code>9</code></p><blockquote><p>如果将此操作应用于“日志”视图中选择的多个提交，则会创建一个单独的提交来还原每个提交。</p></blockquote></li><li><p>如果所选提交包含多个文件，并且您只需要恢复其中一些文件，请取消选择您不想触及的文件。</p></li><li><p>单击“提交”以提交更改集，该更改集将还原对此特定提交中所选文件的更改。</p></li></ol></blockquote><blockquote><p><strong>恢复选定的更改</strong>﻿</p><p>如果此提交包含多个文件并且您只需要恢复其中一些文件，则 IntelliJ IDEA 允许您撤消推送提交中选定的更改。</p><ol><li><p>在日志视图中，选择包含要放弃的更改的提交。</p></li><li><p>在<a href="https://intellijidea.com.cn/help/idea/log-tab.html#changedFiles">“更改的文件”</a>窗格中，右键单击要还原的文件，然后从上下文菜单中选择“还原选定的更改” 。</p><p>这会产生一个新的提交，该提交会撤销您想要撤消的更改。</p></li></ol></blockquote><blockquote><p><strong>删除提交</strong>﻿</p><p>与反映在分支历史记录中的<a href="https://intellijidea.com.cn/help/idea/undo-changes.html#revert-commit">恢复提交</a>不同，您可以丢弃当前分支中推送的提交，而不会留下任何操作痕迹。</p><blockquote><p><a href="https://intellijidea.com.cn/help/idea/edit-project-history.html">与任何重写分支</a>历史记录的操作一样，删除提交需要<a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#force-push">–force 推送</a>，并且不能在受保护的分支中执行（这些可以在IDE 设置的 版本控制 | Git页面中进行配置）。<code>Ctrl</code> <code>Alt</code> <code>S</code></p></blockquote><ul><li>在日志视图中选择要放弃的提交，然后从上下文菜单中选择“删除提交” 。</li></ul></blockquote><blockquote><p><strong>将分支重置为特定提交</strong>﻿</p><p>如果您发现最近的一组提交中存在错误并想要重做该部分，则可以将存储库回滚到特定状态。这是通过将当前分支 HEAD 重置为指定的提交来完成的（如果您不想在历史记录中反映撤消，则可以选择重置索引和工作树）。</p><ol><li>打开 版本控制工具窗口 并切换到日志选项卡。Alt09</li><li>选择要将 HEAD 移至的提交，然后从上下文菜单中选择将当前分支重置到此处。</li><li>在打开的Git Reset对话框中，选择您希望如何更新工作树和索引，然后单击Reset：<ul><li>Soft：所选提交之后所做的所有更改都将暂存（这意味着它们将被移动到“ 更改”视图，以便您可以查看它们并在必要时稍后提交）。</li><li>混合：将保留所选提交后所做的更改，但不会暂存提交。</li><li>Hard：所选提交后所做的所有更改都将被丢弃（暂存和提交）。</li><li>Keep：所选提交后所做的已提交更改将被丢弃，但本地更改将保持不变。</li></ul></li></ol></blockquote><blockquote><p><strong>获取文件的先前修订版本</strong>﻿</p><p>如果您需要恢复单个文件而不是丢弃包含对多个文件的更改的整个提交，您可以返回到该文件的特定版本：</p><ol><li>在任何视图（项目工具窗口、编辑器、 更改视图等）中选择必要的文件。</li><li>选择Git | 从VCS主菜单或选择的上下文菜单显示历史记录。“历史记录”选项卡已添加到 Git工具窗口，显示所选文件的历史记录，并允许您查看和比较其修订版本。</li><li>确定要回滚到的修订版本后，在列表中选择它，然后从上下文菜单中选择“获取” 。</li></ol></blockquote><h2 id="使用标签来标记特定的-Git-提交"><a href="#使用标签来标记特定的-Git-提交" class="headerlink" title="使用标签来标记特定的 Git 提交"></a>使用标签来标记特定的 Git 提交</h2><p>Git 允许您将标签附加到提交中，以标记项目历史记录中的某些点，以便您将来可以引用它们。例如，您可以标记与发布版本相对应的提交，而不是创建路径来捕获发布<a href="https://intellijidea.com.cn/help/idea/manage-branches.html#create-branch">快照</a>。</p><blockquote><p><strong>为提交分配标签</strong>﻿</p><ol><li><p>打开 Git工具窗口 并切换到“日志”选项卡。Alt09</p></li><li><p>找到所需的提交，右键单击它并从上面菜单中的“新建标签”。</p></li><li><p>输入新标签的名称并单击“确定”。该标签将显示在 Git工具窗口 的 “日志”选项卡中：Alt09</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/tagged_commit.png" alt="标记提交"></p></li></ol></blockquote><blockquote><p><strong>将带注释的标签分配给提交</strong>﻿</p><p>带注释标签的元数据包含创建用户的名称，因此允许您检查谁放置了它们。</p><ol><li>转到Git |新标签。</li><li>在打开的“标签”对话框中，在“Git Root”下，选择要在其中标记提交的本地存储库的路径，并指定新标签的名称。</li><li>在“提交”字段中，指定要标记的提交。您可以输入提交哈希值，或使用表达式，例如：<code>&lt;branch&gt;~&lt;number of commits backwards between the latest commit (HEAD) and the required commit&gt;</code>。有关更多信息，请参阅 Git<a href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html#naming-commits">提交命名约定</a>。</li><li>在消息字段中输入一些注释以创建带注释的标签（如果为空，则将创建常规标签）。</li><li>点击“创建标签”。</li></ol><blockquote><p>如果在“日志”工具栏的“快速设置”下启用“简洁引用视图”选项，则标记名称将隐藏在分支名称后面并且不可见。</p></blockquote><blockquote><p>如果您不需要指定任何其他选项，还可以右键单击版本控制工具窗口的“日志”选项卡 中的提交 ，然后从上下文菜单中选择“新建标签”。<code>Alt</code> <code>9</code></p></blockquote></blockquote><blockquote><p><strong>分配重新现有标签</strong>﻿</p><p>如果您在错误的提交上放置了标签，并且想要重新分配它（例如，指示发布版本的提交），请执行以下操作：</p><ol><li>转到Git |新标签。</li><li>在“标签”对话框的“标签名称”字段中指定要重新分配的现有标签的名称。</li><li>选择强制选项。</li><li>在提交字段中，指定标签移动到提交位置，然后单击创建标签。</li></ol></blockquote><blockquote><p><strong>跳转到标记的工作</strong>﻿</p><ol><li><p>打开 Git工具窗口 并切换到“日志”选项卡。<code>Alt</code> <code>9</code></p></li><li><p>单击工具栏上的“转到分区&#x2F;分支&#x2F;标签”图标，或按。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.find.svg" alt="应用程序操作文件夹"><code>Ctrl</code> <code>F</code></p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/go_to_hash.png" alt="转移分区/分支/标签图标"></p></li><li><p>输入标签名称（<a href="https://intellijidea.com.cn/help/idea/auto-completing-code.html">代码完成会</a>在您键入时建议标签名称）并按。<code>Enter</code></p></li></ol></blockquote><blockquote><p><strong>查看标记的提交</strong>﻿</p><p>假设您使用标签标记了与发布版本相对应的作业，现在您想要查看项目在该时间点的快照。您可以通过检查标记的作业来实现这一点。执行以下操作之一：</p><ul><li><a href="https://intellijidea.com.cn/help/idea/use-tags-to-mark-specific-commits.html#jump-to-tag">找到</a>要签出的标记提交，右键单击它并从上下文菜单中选择“签出修订”。</li><li><a href="https://intellijidea.com.cn/help/idea/manage-branches.html#invoke-branches-popup">调用分支弹出窗口</a>，单击“签出标签”或“修订版本”，然后输入标签名称（IntelliJ IDEA 在您输入时提供匹配标签和修订版本的列表）。</li></ul><p>请注意，此操作会导致<a href="https://git-scm.com/docs/git-checkout#_detached_head">分离的 HEAD</a>，这意味着您不再位于任何分支中。您可以使用此快照进行检查和实验。但是，如果您想在此快照上面提交更改，则需要<a href="https://intellijidea.com.cn/help/idea/manage-branches.html#create-branch">创建一个分支</a>。</p></blockquote><blockquote><p><strong>积极标签</strong>﻿</p><p>默认情况下，当您执行<code>push</code>操作时，标签不会发送到远程存储库。</p><ol><li><p>在“积极作业”活动中，选中左下角的“积极活动标签”。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/push_tags.png" alt="“作业活跃”对话框中的“活跃标签”选项"></p></li><li><p>在下拉菜单中，选择您要锻炼的标签：</p><ul><li>如果您想要人群的所有标签，包括不属于您想要的人群的选定主题的标签，请选择“全部”（第三方）<code>push --tags</code>。</li><li>如果您的人群属于您要人群的选定分支的标签，请选择当前<code>push --follow-tags</code>路径（路径）。</li></ul></li><li><p>单击“全民”。</p></li></ol></blockquote><blockquote><p><strong>删除标签</strong>﻿</p><ul><li><a href="https://intellijidea.com.cn/help/idea/use-tags-to-mark-specific-commits.html#jump-to-tag">找到</a>标记的提交，右键单击它并选择标记 <tag_name> |从上下文菜单中删除。</li></ul></blockquote><h2 id="编辑-Git-项目历史记录"><a href="#编辑-Git-项目历史记录" class="headerlink" title="编辑 Git 项目历史记录"></a>编辑 Git 项目历史记录</h2><p>Git 允许您编辑项目历史记录。当您正在处理功能分支并希望在与其他人<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html">共享</a>之前清理它并使其看起来像您想要的方式时，这非常有用。例如，您可以编辑提交消息，将与相同功能相关的较小提交压缩在一起，或者将包含不相关更改的提交拆分为单独的提交，将更改添加到先前的提交等。</p><blockquote><p>除非绝对必要，否则请避免修改具有多个贡献者的远程分支的历史记录，例如，如果您不小心推送了一些敏感数据。</p><p>为了防止数据丢失，将拒绝将重写分支历史记录的修改推送到远程存储库，因此您必须强制<a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#force-push">推送</a>更改。</p><p>您无法在不允许的情况下修改受保护分支的历史记录（在IDE 设置的 版本控制 | Git页面中配置受保护分支）。请注意，如果分支在 GitHub 上标记为受保护，则 IntelliJ IDEA 会在您修改时自动将其标记为受保护。一探究竟。<code>push --force``Ctrl</code> <code>Alt</code> <code>S</code></p><p>此外，您无法执行修改当前签出分支中未包含的提交的分支历史记录的操作。</p></blockquote><p><strong>1、编辑提交消息</strong>﻿</p><p>如果您唯一需要更改的是提交消息，则可以在推送此提交之前对其进行编辑。</p><blockquote><ol><li>在Git工具窗口 的“日志”选项卡 中右键单击要编辑其消息的提交 ，然后从上下文菜单中选择“编辑提交消息” ，或按。<code>Alt</code> <code>9</code> <code>F2</code></li><li>在打开的对话框中，输入新的提交消息并单击“确定”。</li></ol></blockquote><p><strong>2、修改之前的commit</strong>﻿</p><p>有时，您可能会过早提交并忘记添加一些文件，或者注意到上次提交中存在错误，您希望在不创建单独提交的情况下修复该错误。</p><p>您可以通过使用“修改提交”选项来执行此操作，该选项将分阶段更改附加到先前的提交。因此，您最终会得到一次提交，而不是两次不同的提交。</p><blockquote><ol><li>在提交工具窗口中，选择包含要添加到先前提交的更改的修改文件。<code>Alt</code> <code>0</code></li><li>选中“修改”复选框，使“提交”按钮更改为“修改提交”并单击它。</li></ol></blockquote><p><strong>3、修改任何先前的提交</strong>﻿</p><p>如果您需要向任何早期提交添加更改而不是单独提交它们，则可以使用<code>fixup</code>或<code>squash</code>操作来完成此操作。这两个命令都将分阶段更改附加到所选提交，但处理提交消息的方式不同：</p><ul><li><code>squash</code>将新的提交消息添加到原始提交中</li><li><code>fixup</code>丢弃新的提交消息，仅保留原始提交的消息</li></ul><blockquote><p>这两个命令都需要变<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#rebase-branch">基</a>，因为它们更改了提交哈希值。</p></blockquote><blockquote><ol><li>在提交工具窗口中，选择包含要附加到早期提交的更改的修改文件。<code>Alt</code> <code>0</code></li><li>在 Git工具窗口 的 “日志”选项卡中，右键单击要使用本地更改进行修改的提交，然后从上下文菜单中选择“修复”或“压缩到” 。<code>Alt</code> <code>9</code></li><li>如果您选择压缩更改，请修改提交消息。</li><li>单击Commit按钮上的箭头并选择Commit 和 Rebase。</li></ol></blockquote><p><strong>4、壁球提交</strong>﻿</p><p>如果您需要合并与相同功能相关的任何两个提交，您可以将它们压缩为一个，以便更清晰的分支历史记录。</p><blockquote><ol><li>在 Git工具窗口 的 “日志”选项卡中，选择要合并为一个的提交，然后从上下文菜单中选择“压缩提交” 。<code>Alt</code> <code>9</code></li><li>在打开的对话框中，编辑提交消息（默认情况下，它包含来自两次提交的消息），然后单击“确定”。</li><li>将更改推送到远程分支。<code>Ctrl</code> <code>Shift</code> <code>K</code></li></ol></blockquote><p><strong>5、删除提交</strong>﻿</p><p>您可以放弃当前分支中推送的提交，而无需<a href="https://intellijidea.com.cn/help/idea/undo-changes.html#revert-commit">创建恢复更改的附加提交</a>。</p><blockquote><ul><li>在日志视图中选择要放弃的提交，然后从上下文菜单中选择“删除提交” 。</li></ul></blockquote><p><strong>6、通过执行交互式变基来编辑项目历史记录</strong>﻿</p><p>通过 IntelliJ IDEA 中的 Git 集成，您可以通过执行交互式 rebase来编辑项目历史记录，使其线性且有意义。<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#feature-branches">这允许您在将更改从功能分支集成到另一个分支之前，通过更改单个提交、更改其顺序、将提交压缩为一个、跳过</a><a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html">包含</a>无关更改的提交等来清理提交历史记录。</p><blockquote><p><strong>编辑当前分支的历史记录</strong>﻿</p><p>IntelliJ IDEA 允许您在将更改应用到不同分支之前编辑当前分支中的提交历史记录。</p><ol><li><p>打开 Git工具窗口 并切换到“日志”选项卡。<code>Alt</code> <code>9</code></p></li><li><p>过滤日志，使其仅显示当前分支的提交：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/VCS_log_branch_filter.png" alt="按分支过滤日志"></p></li><li><p>选择要编辑的一系列提交中最旧的提交，右键单击它并选择Interactively Rebase from Here。</p><p>将显示“交互式变基”对话框，其中包含当前分支中在选定提交之后进行的所有提交的列表：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/VCS_interactive_rebase_dialog.png" alt="交互式变基对话框"></p><p>如果“从此处交互式变基”选项被禁用，则可能是由于以下原因之一造成的：</p><ul><li>所选提交有多个父项</li><li>所选提交不在当前分支中</li><li>选定的提交被推送到<a href="https://intellijidea.com.cn/help/idea/edit-project-history.html#protected-branch">受保护的分支</a></li></ul><p>要确定原因，请将鼠标悬停在上下文菜单中的操作上，然后在状态栏中查找消息：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/VCS_interactive_rebase_disabled.png" alt="状态栏消息"></p></li><li><p>您可以对分支历史记录执行以下更改：</p><ul><li><p>更改应应用提交的顺序<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.arrowUp.svg" alt="向上箭头">：使用和<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.arrowDown.svg" alt="向下箭头">按钮在列表中上下移动提交。</p></li><li><p>选择一个提交：这是所有提交的默认状态。如果您需要撤消已对提交执行的操作，请单击“选择” <img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.rollback.svg" alt="应用程序操作回滚">，以便按原样应用此提交。</p></li><li><p>编辑：单击“停止”进行编辑 <img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.pause.svg" alt="暂停按钮">，以便当您启动变基时，您可以在此提交处停止以便能够对其进行编辑。</p><blockquote><p>当变基在提交时停止时，IntelliJ IDEA 窗口的右下角会弹出一条通知，让您继续或中止变基：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/continue_rebase_notification.png" alt="变基状态通知"></p><p>在继续变基之前，您可以使用上下文操作（例如Revert、Undo、Amend等）修改此提交。如果您不执行任何操作，则此提交将按原样应用。</p><p>如果您已关闭通知，请从主菜单中选择Git | 继续变基以恢复它。</p></blockquote></li><li><p>重写提交消息：单击重写或双击提交并在打开的迷你编辑器中编辑文本。</p></li><li><p>将两个提交合并为一个：选择要合并到前一个提交中的提交，然后单击“Squash”或“Squash”按钮旁边的箭头，然后单击“Fixup”。</p><blockquote><p>如果您单击Squash，默认情况下，来自两个提交的消息将被合并，因此，如果您不修改生成的提交消息，此操作将反映在分支历史记录中。</p><p>如果单击Fixup，则修复提交的提交消息将被丢弃，因此此更改将在分支历史记录中不可见。</p><p>在这两种情况下，您都可以在应用这些操作之一时打开的迷你编辑器中编辑提交消息。</p></blockquote></li><li><p>忽略提交：单击“删除”，以便不应用所选提交的更改。</p></li><li><p>撤消所有更改：单击“重置”以放弃已应用于提交的所有操作。</p></li></ul><p>因此，“变基提交”对话框会显示一个图表，说明您应用于分支中提交的所有操作，以便您可以在开始变基之前查看它们：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/VCS_interactive_rebase_graph.png" alt="交互式变基图"></p></li><li><p>单击开始变基。</p></li></ol></blockquote><blockquote><p><strong>编辑分支历史并将其集成到另一个分支</strong>﻿</p><p>IntelliJ IDEA 允许您在另一个分支之上对一个分支<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#rebase-branch">进行变基，并在应用更改之前编辑源分支历史记录。</a></p><ol><li><p>从主菜单中选择 Git | 变基：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_rebase_dialog.png" alt="Git 变基对话框"></p></li><li><p>单击修改选项并选择–interactive。</p></li><li><p>从列表中，选择要将当前分支变基到的目标分支：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_rebase_choose_branch.png" alt="在 Git rebase 对话框中选择目标分支"></p></li><li><p>如果您需要从特定提交开始对源分支进行变基，而不是对整个分支进行变基，请单击修改选项并选择–onto。在源分支字段中，输入要将当前分支应用到新基础的提交的哈希值：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_rebase_specify_commit.png" alt="使用 --onto 指定提交哈希"></p><blockquote><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3><p>要复制提交哈希，请在Log中选择它，右键单击它并选择Copy Revision Number。</p></blockquote></li><li><p>如果您要变基的分支当前未签出，请单击“修改选项”，单击“选择另一个要变基的分支”，然后从显示的列表中选择一个分支：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_rebase_choose_source_branch.png" alt="选择您想要变基的分支"></p><p>IntelliJ IDEA 将在开始变基操作之前检查此分支。</p></li><li><p>如果要对分支中可访问的所有提交进行变基，请单击修改选项并选择–root（有关此选项的更多信息，请参阅<a href="https://git-scm.com/docs/git-rebase">git-rebase</a>）。</p></li><li><p>如果您需要保留空提交（即不会从其父级更改任何内容的提交），请单击修改选项并选择–keep-empty（有关此选项的更多信息，请参阅<a href="https://git-scm.com/docs/git-rebase">git-rebase</a>）。</p></li><li><p>单击变基。</p><p>将显示“交互式变基”对话框，其中包含当前分支中在选定提交之后进行的所有提交的列表。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/VCS_interactive_rebase_dialog.png" alt="交互式变基对话框"></p></li><li><p>您可以对分支历史记录执行以下更改：</p><ul><li><p>更改应应用提交的顺序<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.arrowUp.svg" alt="向上箭头">：使用和<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.arrowDown.svg" alt="向下箭头">按钮在列表中上下移动提交。</p></li><li><p>选择一个提交：这是所有提交的默认状态。如果您需要撤消已对提交执行的操作，请单击“选择” <img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.rollback.svg" alt="应用程序操作回滚">，以便按原样应用此提交。</p></li><li><p>编辑：单击“停止”进行编辑 <img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.pause.svg" alt="暂停按钮">，以便当您启动变基时，您可以在此提交处停止以便能够对其进行编辑。</p><blockquote><p>当变基在提交时停止时，IntelliJ IDEA 窗口的右下角会弹出一条通知，让您继续或中止变基：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/continue_rebase_notification.png" alt="变基状态通知"></p><p>在继续变基之前，您可以使用上下文操作（例如Revert、Undo、Amend等）修改此提交。如果您不执行任何操作，则此提交将按原样应用。</p><p>如果您已关闭通知，请从主菜单中选择Git | 继续变基以恢复它。</p></blockquote></li><li><p>重写提交消息：单击重写或双击提交并在打开的迷你编辑器中编辑文本。</p></li><li><p>将两个提交合并为一个：选择要合并到前一个提交中的提交，然后单击“Squash”或“Squash”按钮旁边的箭头，然后单击“Fixup”。</p><blockquote><p>如果您单击Squash，默认情况下，来自两个提交的消息将被合并，因此，如果您不修改生成的提交消息，此操作将反映在分支历史记录中。</p><p>如果单击Fixup，则修复提交的提交消息将被丢弃，因此此更改将在分支历史记录中不可见。</p><p>在这两种情况下，您都可以在应用这些操作之一时打开的迷你编辑器中编辑提交消息。</p></blockquote></li><li><p>忽略提交：单击“删除”，以便不应用所选提交的更改。</p></li><li><p>撤消所有更改：单击“重置”以放弃已应用于提交的所有操作。</p></li></ul><p>因此，“变基提交”对话框会显示一个图表，说明您应用于分支中提交的所有操作，以便您可以在开始变基之前查看它们：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/VCS_interactive_rebase_graph.png" alt="交互式变基图"></p></li><li><p>单击开始变基。</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 使用 Git 详解(二)</title>
      <link href="/posts/ae9ce5fc.html"/>
      <url>/posts/ae9ce5fc.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/load.gif" data-original="https://n.sinaimg.cn/sinakd10116/612/w2000h1012/20200629/34e0-ivrxcex3246619.jpg" alt=" https://n.sinaimg.cn/sinakd10116/612/w2000h1012/20200629/34e0-ivrxcex3246619.jpg"></p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>Git 设置：<strong>设置 | 版本控制 | git</strong></p><p>所需插件：Git（默认捆绑并启用）</p><h2 id="为-Git-远程设置密码"><a href="#为-Git-远程设置密码" class="headerlink" title="为 Git 远程设置密码"></a>为 Git 远程设置密码</h2><p>每次与远程 Git 存储库交互时（例如，在 pull、update 或 push 操作期间），都需要授权。你可以将 IntelliJ IDEA 配置为记住你的密码。这样你就不必再每次需要授权时指定你的凭据了。</p><p><strong>配置密码策略</strong></p><blockquote><ol><li><p>在<strong>设置</strong>对话框中，选择<strong>外观和行为 | 系统设置 | 密码</strong> 在左边。<code>Ctrl</code> <code>Alt</code> <code>S</code></p></li><li><p>选择你希望 IntelliJ IDEA 如何处理 Git 远程存储仓库的密码：</p><ul><li><p><strong>在本机钥匙串中：</strong>选择此项可使用本机钥匙串来存储你的密码。此设置仅适用于 macOS 和 Linux。</p></li><li><p><strong>在 KeePass 中：</strong>选择此选项可使用<a href="http://keepass.info/">KeePass 密码管理器</a>来存储您的密码。</p><p>当您使用KeePass 密码管理器时，将使用主密码来访问存储个人密码的文件。一旦 IntelliJ IDEA 记住您的密码，除非您需要访问密码数据库，否则它不会询问您的密码。在MasterPassword字段中输入将用于访问<strong>c.kdbx</strong>文件的密码。</p><p>您可以在“数据库”字段中更改<strong>c.kdbx</strong>文件的默认位置。</p><p>要导入<strong>c.kdbx</strong>文件，请单击并从下拉菜单中<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/icon_viewMode.png" alt="设置图标">选择“导入”<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.ellipsis.svg" alt="浏览按钮"> ，或者单击并指定包含密码的本地文件的路径。</p><p>如果您想从数据库中删除现有密码，请选择“清除”。</p></li><li><p>重新启动后不保存，忘记密码：如果您希望在关闭 IntelliJ IDEA 后重置密码，请选择此选项。</p></li></ul></li></ol></blockquote><h2 id="设置-Git-存储库"><a href="#设置-Git-存储库" class="headerlink" title="设置 Git 存储库"></a>设置 Git 存储库</h2><p>当您<a href="https://intellijidea.com.cn/help/idea/set-up-a-git-repository.html#clone-repo">克隆</a>现有的 Git 存储库或<a href="https://intellijidea.com.cn/help/idea/set-up-a-git-repository.html#put-existing-project-under-Git">将现有项目置于 Git 版本控制之下时</a>，IntelliJ IDEA 会自动检测您的计算机上是否安装了 Git。如果 IDE 找不到 Git 可执行文件，则建议下载它。</p><p>IntelliJ IDEA 支持来自 Windows Subsystem for Linux 2 (WSL2) 的 Git，该子系统在<a href="https://devblogs.microsoft.com/commandline/wsl2-will-be-generally-available-in-windows-10-version-2004/">Windows 10 版本 2004</a>中提供。</p><p>如果 Windows 上未安装 Git，IntelliJ IDEA 会在 WSL 中搜索 Git 并从那里使用它。**此外，对于使用\ \wsl$**路径打开的项目，IntelliJ IDEA 会自动从 WSL 切换到 Git 。</p><p>如果您需要手动配置 IntelliJ IDEA 以从 WSL 使用 Git，请转到<strong>版本控制</strong> | IDE 设置的 <strong>Git</strong> 页面，单击Git 可执行文件路径字段中的浏览图标，然后通过路径选择 Git from WSL，例如。<code>Ctrl</code> <code>Alt</code> <code>S</code> <code>\wsl$</code> <code>\\wsl$\debian\usr\bin\git</code></p><p><strong>1、从远程主机检出项目（git clone）</strong></p><p>IntelliJ IDEA 允许你签出（用 Git 术语来说，克隆）现有存储库并根据你下载的数据创建新项目。</p><blockquote><ol><li><p>要开始克隆 Git 存储库，请执行以下操作之一：</p><ul><li><p>如果版本控制集成已启用，请转至<strong>Git | 克隆</strong>。</p></li><li><p>如果尚未启用版本控制集成，请转至<strong>VCS | 从版本控制获取</strong>。</p><p>或者，转到<strong>文件 | 新 | 来自版本控制的项目</strong>。</p></li><li><p>如果当前没有打开的项目，请单击“<strong>欢迎</strong>”屏幕上的“<strong>从 VCS 获取</strong>”。</p></li></ul></li><li><p>在“<strong>从版本控制获取</strong>”对话框中，指定要克隆的远程存储库的 URL，或选择左侧的 VCS 托管服务之一。</p><p>如果您已经登录到所选的托管服务，完成后将建议您可以克隆的可用存储库列表。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/get-from-vc-git.png" alt="从 GitHub 获取项目"></p></li><li><p>单击“<strong>克隆</strong>”。如果要基于已克隆的源创建项目，请在确认对话框中单击“<strong>是</strong>” 。Git 根映射将自动设置为项目根目录。</p><p>如果您的项目包含<a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">子模块</a>，它们也将被克隆并自动注册为项目根。</p></li><li><p>在<strong>信任和开放项目“<project_name>”中</strong>？ <a href="https://intellijidea.com.cn/help/idea/project-security.html">在项目安全对话框中</a>，选择您想要打开项目的方式：<strong>信任项目或在安全模式下预览</strong>。</p></li><li><p>当您第一次导入或克隆项目时，IntelliJ IDEA 会对其进行分析。如果 IDE 检测到多个配置（例如 Eclipse 和 Gradle），它会提示您选择要使用的配置。</p><blockquote><p>如果您要导入的项目使用构建工具，例如<a href="https://intellijidea.com.cn/help/idea/maven-support.html">Maven</a>或<a href="https://intellijidea.com.cn/help/idea/gradle.html">Gradle</a>，我们建议您选择构建工具配置。</p></blockquote><p>选择必要的配置并单击“确定”。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/import-from-providers.png" alt="提示您选择导入项目的方式的对话框"></p><p>IDE 根据您的选择预先配置项目。例如，如果您选择Gradle，IntelliJ IDEA 将执行其构建脚本、加载依赖项等。</p></li></ol></blockquote><p><strong>2、将现有项目置于 Git 版本控制之下</strong>﻿</p><p><strong>①、将整个项目与单个 Git 存储库关联</strong>﻿</p><blockquote><ol><li><p>打开您想要放入 Git 下的项目。</p></li><li><p>按打开<strong>VCS 操作弹出窗口</strong>并选择启用版本控制集成。<code>Alt</code> <code>~</code></p><p>或者，转到 <strong>VCS | 启用版本控制集成</strong>。</p></li><li><p>选择Git作为版本控制系统，然后单击“<strong>确定</strong>”。</p><p>然后，整个项目将与单个 Git 目录关联，因此无需将每个文件单独添加到 Git 目录。</p></li><li><p>启用 VCS 集成后，IntelliJ IDEA 会询问您是否要通过 VCS 共享项目设置文件。您可以选择始终添加以与使用 IntelliJ IDEA 的其他存储库用户同步项目设置。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/sharing-project-notification.png" alt="通知提示选择如何处理配置文件"></p></li></ol><blockquote><p>如果VCS Operations 弹出窗口中没有可用的“启用版本控制集成”选项，则表示已为该项目启用了 Git 版本控制。</p></blockquote></blockquote><p><strong>②、将项目内的不同目录与不同的 Git 存储库关联</strong>﻿</p><blockquote><ol><li><p>打开您想要放入 Git 下的项目。</p></li><li><p>前往<strong>VCS | 创建 Git 存储库</strong>。</p></li><li><p>在打开的对话框中，指定将在其中创建新 Git 存储库的目录。</p><p>Git 不支持外部路径，因此如果您选择项目根目录之外的目录，请确保要创建存储库的文件夹也包含项目根目录。</p></li><li><p>如果您要在项目结构内创建多个 Git 存储库，请对每个目录重复前面的步骤。</p></li></ol></blockquote><p>为项目<a href="https://intellijidea.com.cn/help/idea/set-up-a-git-repository.html#put-existing-project-under-Git">初始化 Git 存储库</a>后，您需要将项目文件添加到存储库。</p><p><strong>3、添加文件到本地存储库</strong>﻿</p><blockquote><ol><li><p>在 “<strong>提交</strong>”工具窗口中，展开“<strong>未版本化文件</strong>”节点。<code>Alt</code> <code>0</code></p></li><li><p>选择要添加到 Git 或整个更改列表的文件，然后按或从上下文菜单中选择“<strong>添加到 VCS</strong>” 。<code>Ctrl</code> <code>Alt</code> <code>A</code></p><p>您还可以从“项目”工具窗口将文件添加到本地 Git 存储库：选择要添加的文件，然后按或选择“Git | Git”。从上下文菜单添加。<code>Ctrl</code> <code>Alt</code> <code>A</code></p></li></ol></blockquote><p>在项目中启用 Git 集成时，IntelliJ IDEA 建议在 Git 下添加每个新创建的文件，即使它是从 IntelliJ IDEA 外部添加的。您可以在版本控制 |中更改此行为。IDE 设置的 确认页面。如果您希望某些文件始终保持未版本化，则可以<a href="https://intellijidea.com.cn/help/idea/set-up-a-git-repository.html#ignore-files">忽略它们</a>。<code>Ctrl</code> <code>Alt</code> <code>s</code></p><blockquote><p><strong>如果您尝试添加.gitignore</strong>列表中的文件，IntelliJ IDEA 将建议强制添加它。在确认对话框中单击“取消”只会取消强制添加忽略的文件 - 所有其他文件都将添加到 Git 存储库。</p></blockquote><p><strong>4、从版本控制中排除文件（忽略）</strong>﻿</p><p>有时您可能需要保留某些文件未版本化。这些可以是 VCS 管理文件、实用程序工件、备份副本等。您可以通过 IntelliJ IDEA 忽略文件，IDE 不会建议将它们添加到 Git 并将它们突出显示为忽略。</p><p>您只能忽略未版本化的文件，即您在未版本化文件更改列表中看到的文件。如果文件已<a href="https://intellijidea.com.cn/help/idea/set-up-a-git-repository.html#add-new-files">添加到 Git</a>但未<a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html">提交，您可以在</a>“更改”视图中右键单击该文件 并选择“回滚”。</p><p>Git 允许您在两种配置文件中列出忽略的文件模式：</p><blockquote><ul><li><p><strong>.git &#x2F;info &#x2F;排除</strong>文件。</p><p>此文件中列出的模式仅适用于存储库的本地副本。</p><p>当您初始化或签出 Git 存储库时，会自动创建此文件。</p></li><li><p>VCS 根目录及其子目录中的一个或多个**.gitignore文件。**</p><p>这些文件被签入存储库，以便整个团队都可以使用其中的忽略模式。因此，它是存储被忽略的文件模式的最常见位置。</p><p>如果VCS根目录下没有**.gitignore<strong>文件，可以在Project工具窗口任意位置右键，选择New | 文件，然后在“新建文件”对话框中键入</strong>.gitignore**。</p><blockquote><p>要在 Windows 资源管理器中创建**.gitignore<strong>文件，请创建一个名为 .gitignore 的文件</strong>。<strong>Windows 会自动将其重命名为</strong>.gitignore**。</p></blockquote></li></ul></blockquote><p><strong>5、将文件添加到 .gitignore 或 .git&#x2F;info&#x2F;exclude</strong>﻿</p><blockquote><ol><li><p>决定要使用哪种<a href="https://intellijidea.com.cn/help/idea/set-up-a-git-repository.html#add-gitignore">类型的 Git 配置文件来忽略文件。</a>如果有疑问，请使用**.gitignore**。</p></li><li><p>在“更改”视图或“项目”工具窗口中找到要忽略的未版本控制的文件或文件夹 。<a href="https://intellijidea.com.cn/help/idea/file-status-highlights.html">这些视图中的文件颜色</a>可帮助您识别文件的状态。</p></li><li><p>右键单击所选内容并选择Git | 添加到 .gitignore或Git | 添加到 .git&#x2F;info&#x2F;exclude。</p><p><a href="https://intellijidea.com.cn/help/idea/file-status-highlights.html">这些视图中的文件颜色</a>可帮助您识别文件的状态。</p></li></ol></blockquote><p>如果需要按某种模式或类型排除文件，可以直接编辑<code>.gitignore</code>或文件。<code>.git/info/exclude</code>请参阅<a href="https://git-scm.com/docs/gitignore?origin_team=T0288D531">.gitignore 模式格式</a>。</p><blockquote><p>如果您希望<a href="https://intellijidea.com.cn/help/idea/set-up-a-git-repository.html#ignore-files">忽略的文件</a>也显示在 “更改”视图中，请单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.show.svg" alt="眼睛图标">工具栏上的 并选择“显示忽略的文件”。</p></blockquote><p><strong>6、添加远程存储库</strong>﻿</p><p>如果您基于本地源<a href="https://intellijidea.com.cn/help/idea/set-up-a-git-repository.html#put-existing-project-under-Git">创建了 Git 存储库</a>，则需要添加远程存储库以便能够在 Git 项目上进行协作，并消除在本地存储整个代码库的风险。当您需要共享您的工作并从中提取数据以将其他贡献者所做的更改集成到本地存储库版本时，您可以将更改推送到<a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#push">远程</a>存储<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html#pull">库</a>。</p><p>如果您已<a href="https://intellijidea.com.cn/help/idea/set-up-a-git-repository.html#clone-repo">克隆远程 Git 存储库</a>（例如，从<a href="https://github.com/">GitHub</a> ），则远程会自动配置，并且当您想要与其<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html">同步</a>时不必指定它。Git 为您克隆的远程服务器提供的默认名称是origin。</p><p>有关共享不同项目格式的项目设置的更多信息，请参阅 <a href="https://intellijidea.com.cn/help/idea/configure-project-settings.html#share-project-through-vcs">通过 VCS 共享项目设置</a>。</p><p><strong>7、定义一个远程</strong>﻿</p><blockquote><ol><li>在任何 Git 托管上创建一个空存储库，例如<a href="https://bitbucket.org/">Bitbucket</a>或<a href="https://github.com/">GitHub</a>。您可以在 GitHub 上创建存储库，而无需离开 IntelliJ IDEA：请参阅<a href="https://intellijidea.com.cn/help/idea/manage-projects-hosted-on-github.html#share-on-GitHub">在 GitHub 上共享项目</a>。</li><li>当您准备好通过选择 Git |推送提交时，调用“推送”对话框 从主菜单按下，或按。<code>Ctrl</code> <code>Shift</code> <code>K</code></li><li>如果您到目前为止尚未添加任何遥控器，则会显示“定义远程”链接而不是遥控器名称。单击它以添加遥控器。</li><li>在打开的对话框中，指定远程名称和托管它的 URL，然后单击“确定”。</li></ol></blockquote><p><strong>8、添加第二个遥控器</strong>﻿</p><p>在某些情况下，您还需要添加第二个远程存储库。例如，如果您克隆了一个没有写访问权限的存储库，并且要将更改推送到您自己的原始项目<a href="https://intellijidea.com.cn/help/idea/fork-github-projects.html#fork">分支，这可能会很有用。</a>另一个常见的情况是，您克隆了自己的存储库，这是其他人的项目分支，您需要与原始项目同步并从中获取更改。</p><blockquote><ol><li>转到 Git | 管理遥控器。Git远程对话框将打开。</li><li>单击工具栏上的“添加” 按钮或按。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.add.svg" alt="添加"><code>Alt</code> <code>Insert</code></li><li>在打开的对话框中，指定远程名称和 URL，然后单击“确定”。</li></ol><ul><li><p>要编辑远程（例如，更改已克隆的原始项目的名称），请右键单击<a href="https://intellijidea.com.cn/help/idea/log-tab.html#BranchesPane">Git 日志工具窗口的“分支”窗格</a>中的远程分支，然后从上下文菜单中选择“编辑远程” 。</p><p>您还可以通过单击遥控器的名称，从<a href="https://intellijidea.com.cn/help/idea/push-dialog-mercurial-git.html">推送对话框</a>中编辑遥控器。</p></li><li><p>要删除不再有效的存储库，请在<a href="https://intellijidea.com.cn/help/idea/log-tab.html#BranchesPane">Git 日志工具窗口的“分支”窗格</a>中右键单击它，然后从上下文菜单中选择“删除远程” 。</p></li></ul></blockquote><h2 id="将文件添加到-Git-并跟踪更改"><a href="#将文件添加到-Git-并跟踪更改" class="headerlink" title="将文件添加到 Git 并跟踪更改"></a>将文件添加到 Git 并跟踪更改</h2><p><strong>1、将文件添加到 Git</strong>﻿</p><blockquote><ol><li>打开 提交工具窗口。<code>Alt</code> <code>0</code></li><li>通过按或从上下文菜单中选择“添加到 VCS” ，将“无版本控制文件”更改列表中的任何文件置于版本控制之下。您可以添加整个更改列表或选择单独的文件。<code>Ctrl</code> <code>Alt</code> <code>A</code></li></ol></blockquote><p>如果您已为项目启用 Git 集成，IntelliJ IDEA 建议将每个新创建的文件添加到版本控制下。您可以在“版本控制”| “设置”对话框中更改此行为。确认。如果您希望某些文件始终保持未版本化，您可以将 Git 配置为忽略它们。<code>Ctrl</code> <code>Alt</code> <code>s</code></p><blockquote><p>您还可以从项目工具窗口将文件添加到本地存储库。选择要添加的文件，然后按或选择Git | 从上下文菜单添加。<code>Ctrl</code> <code>Alt</code> <code>A</code></p></blockquote><p><strong>2、检查项目文件状态</strong>﻿</p><p>ntelliJ IDEA 允许您检查本地工作副本与项目的存储库版本相比的状态。它可以让您查看哪些文件已被修改、哪些新文件已添加到 Git 以及哪些文件未被 Git 跟踪。</p><p>打开 提交工具窗口。<code>Alt</code> <code>0</code></p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/Git_file_status.png" alt="Git 文件状态"></p><ul><li>更改更改列表显示自上次与远程存储库同步以来已修改的所有文件（以蓝色突出显示），以及已添加到 Git 但尚未提交的所有新文件（以绿色突出显示）。</li><li>Unversioned Files更改列表显示已添加到项目中但 Git 未跟踪的所有文件。</li></ul><blockquote><p>如果您希望忽略的文件也显示在 “更改”视图中，请单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.expui.general.show.svg" alt="查看选项">工具栏上的 并选择“显示忽略的文件”。</p></blockquote><p><strong>3、在编辑器中跟踪文件的更改</strong></p><p>您还可以在编辑器中修改文件时跟踪文件的更改。所有更改均通过更改标记突出显示，这些标记出现在已修改行旁边的装订线中，并显示自上次<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html">与存储库同步</a>以来引入的更改类型。当您将更改提交到存储库时，更改标记就会消失。</p><p>您对文本所做的更改是用颜色编码的：</p><ul><li><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/lineAddedMarker.png" alt="新添加行的标记">已添加行。</li><li><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/lineChangededMarker.png" alt="修改行的标记">线路改变了。</li><li><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/lineDeletedMarker.png" alt="已删除行的标记">行已删除。</li></ul><blockquote><p>您可以在编辑器 |上自定义线路状态的默认颜色。配色方案| IDE 设置的 VCS页面。<code>Ctrl</code> <code>Alt</code> <code>s</code></p><p>要禁用装订线中的 VCS 标记，请取消选择“版本控制”| “装订线”中的“突出显示装订线中已修改的行”选项。IDE 设置的 确认页面。<code>Ctrl</code> <code>Alt</code> <code>s</code></p></blockquote><p>您可以使用将鼠标悬停在更改标记上然后单击它时出现的工具栏来管理更改。工具栏与一个框架一起显示，该框架显示修改行的先前内容：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changeMarkerToolbar.png" alt="修改后的线标记"></p><p>您可以通过单击回滚更改<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.expui.vcs.revert.svg" alt="恢复图标">，并通过单击探索当前行的当前版本和存储库版本之间的差异<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.expui.vcs.diff.svg" alt="显示差异图标">。要突出显示已更改的片段，请单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.actions.highlighting.svg" alt="突出显示按钮">。</p><p>您可以复制此弹出窗口内容的任何部分并将其粘贴到编辑器中，而不是恢复整个文件。</p><p><strong>4、从存储库中删除文件</strong></p><p>如果您删除受版本控制的文件，它仍然存在于存储库中，直到您提交更改为止。已删除的文件将放置在活动更改列表中并以灰色突出显示。</p><blockquote><ol><li><p>在“项目”工具窗口中选择一个文件，然后按或从上下文菜单中选择“删除” 。<code>Delete</code></p></li><li><p>在打开的对话框中，您可以选择是要删除该文件而不搜索用途，还是通过选中“安全删除”选项来执行安全删除（以确保删除未使用的文件）。</p><p>如果发现任何用法，将弹出“检测到用法”对话框，列出它们。您可以在删除该文件之前查看这些用法并删除对此文件的引用。</p></li><li><p>将更改提交到存储库。</p></li></ol></blockquote><h2 id="与远程-Git-存储库同步（获取、拉取、更新）"><a href="#与远程-Git-存储库同步（获取、拉取、更新）" class="headerlink" title="与远程 Git 存储库同步（获取、拉取、更新）"></a>与远程 Git 存储库同步（获取、拉取、更新）</h2><p><a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#push">在通过将更改推送到上游来</a>共享工作结果之前，您需要与远程存储库同步以确保项目的本地副本是最新的。您可以通过以下方式之一执行此操作：<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html#fetch">获取更改</a>、<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html#pull">拉取更改</a>或<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html#update">更新项目</a>。</p><p>Git分支弹出窗口指示分支是否有尚未获取的传入提交：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/Git_branches_incoming_commits_indicator.png" alt="传入提交指示器"></p><p><strong>1、获取更改</strong>﻿</p><p>当您从上游获取更改时，自上次与远程存储库同步以来提交的所有新数据都会下载到本地副本中。这些新数据不会集成到您的本地文件中，并且更改不会应用于您的代码。</p><p>获取的更改存储为远程分支，这使您有机会在将它们与文件<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#merge">合并之前查看它们。</a>由于fetch不会影响你本地的开发环境。这是获取远程存储库所有更改更新的安全方法。</p><p>有两种方法可以从上游获取更改：</p><ul><li><p>选择Git | 在主菜单中获取。</p></li><li><p>或者，打开“分支”弹出窗口并单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.expui.vcs.fetch.svg" alt="获取图标">右上角。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/VCS_fetch_from_branches_popup.png" alt="在分支弹出窗口中获取图标"></p></li></ul><p><a href="https://youtu.be/tnz2I9rxrfk">观看此视频</a>可更好地了解 IDE 中如何执行获取操作。</p><p><strong>2、更新分支</strong>﻿</p><p>如果您需要将特定分支与其远程跟踪分支同步，请使用更新。<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html#fetch">这是获取</a>并随后将更改应用到所选分支的便捷快捷方式。</p><ul><li>在“分支”弹出窗口或 版本控制工具窗口的“分支”窗格中，选择一个分支并从上下文菜单中选择“更新” 。</li></ul><p>IntelliJ IDEA 将从远程分支中<a href="https://git-scm.com/docs/git-pull">提取</a>更改，并将它们<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#rebase-branch">变基</a>或<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#merge">合并</a>到本地分支，具体取决于在设置|中选择的更新方法。版本控制 | 吉特.</p><p><strong>3、拉动变更</strong>﻿</p><p>如果您需要从另一个分支而不是其远程跟踪分支获取对当前分支的更改，请使用pull。当您拉取时，您不仅下载新数据，还将其集成到项目的本地工作副本中。</p><blockquote><ol><li><p>转到Git | 拉。“拉取更改”对话框打开：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_pull_dialog.png" alt="拉动对话框"></p></li><li><p>如果您有一个多存储库项目，则会出现一个附加下拉列表，供您选择存储库。</p></li><li><p>如果您为项目定义了多个遥控器，请从列表中选择一个遥控器（默认情况下为<code>origin</code>）。</p></li><li><p>选择要将更改拉取到当前签出的分支的分支。默认情况下，选择当前本地分支跟踪的远程分支。如果您指定不同的分支，IntelliJ IDEA 将记住您的选择并在将来默认显示该分支。</p></li><li><p>如果您需要使用选项拉取，请单击“修改选项”并从以下选项中进行选择：</p><ul><li><code>--rebase</code>：从远程分支<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html#fetch">获取</a>更改后，IntelliJ IDEA 会将本地未推送的更改<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#rebase-branch">重新设置</a>为已获取的更改。</li><li><code>--ff-only</code>：只有可以快进时，合并才会被解决。</li><li><code>--no-ff</code>：在所有情况下都会创建合并提交，即使可以将合并解析为快进。</li><li><code>--squash</code>：将在当前分支之上创建包含所有拉取更改的单个提交。</li><li><code>--no-commit</code>：将执行合并，但不会创建合并提交，以便您可以在提交之前检查合并的结果。</li></ul><p>有关<code>pull</code>选项的更多信息，请参阅<a href="https://git-scm.com/docs/git-pull%E3%80%82">https://git-scm.com/docs/git-pull。</a></p></li><li><p>单击“拉动”。</p></li></ol></blockquote><p><strong>4、更新您的项目</strong>﻿</p><p>如果您有多个项目根目录，或者希望每次与远程存储库同步时从所有分支获取更改，您可能会发现更新项目是更方便的选择。</p><p>当您执行更新操作时，IntelliJ IDEA会从所有项目根和分支中<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html#fetch">获取</a>更改，并将跟踪的远程分支<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#merge">合并</a>到本地工作副本中（相当于pull）。</p><blockquote><p>如果您的项目包含<a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">子模块</a>，并且它们位于分支上，它们也会自动更新。</p><p>如果子模块处于分离的 HEAD状态，IntelliJ IDEA 将调用<code>git submodule update</code>，这将检查根存储库中引用的提交。这意味着仅当根存储库中的子模块引用发生更改或添加新的子模块时才会执行更新。</p></blockquote><ol><li>前往VCS | 更新项目或按。“更新项目”对话框打开。<code>Ctrl</code> <code>T</code></li><li>选择更新类型（此策略将应用于 Git 版本控制下的所有根）：<ul><li>将传入的更改合并到当前分支：选择此选项可在更新期间执行<a href="http://schacon.github.io/git/git-merge.html">合并。</a>这相当于运行<code>git fetch</code>然后<code>git merge</code>, 或<code>git pull --no-rebase</code>。</li><li>在传入更改之上对当前分支进行变基：选择此选项可在更新期间执行<a href="http://schacon.github.io/git/git-rebase.html">变基。</a>这相当于运行<code>git fetch</code>然后<code>git rebase</code>，或者<code>git pull --rebase</code>（所有本地提交都将放在更新的上游头之上）。</li></ul></li></ol><p>如果您选择以后不显示“更新项目”对话框，然后想要稍后修改默认更新策略，请转到“版本控制”|“更新项目”对话框。IDE设置的 确认页面，在调用这些命令时显示选项对话框下选择更新，并在下次执行更新时修改更新策略。CtrlAlt0S</p><p>更新操作完成后，Git工具窗口 中将添加 <a href="https://intellijidea.com.cn/help/idea/version-control-tool-window-update-info-tab.html">“更新信息”</a>选项卡。<a href="https://intellijidea.com.cn/help/idea/log-tab.html">它列出了自上次与远程同步以来所做的所有提交，并允许您以与“日志”选项卡</a>中相同的方式查看更改。<code>Alt</code> <code>9</code></p><blockquote><p>如果您想查看自上次更新以来修改的所有文件的完整列表，请将插入符号放在提交列表中的任意位置，然后按。您可以禁用分组以查看平面列表：单击“更改的文件”窗格中的工具栏。<code>Ctrl</code> <code>A</code><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.groupBy.svg" alt="通过...分组"></p></blockquote><h2 id="提交更改并将其推送到-Git-存储库"><a href="#提交更改并将其推送到-Git-存储库" class="headerlink" title="提交更改并将其推送到 Git 存储库"></a>提交更改并将其推送到 Git 存储库</h2><blockquote><p>配置提交选项：设置 | 版本控制 | 犯罪</p><p>提交工具窗口 <code>Alt</code> <code>0</code></p><p>犯罪 <code>Ctrl</code> <code>K</code></p><p>提交和推送<code>Ctrl</code> <code>Alt</code> <code>K</code></p><p>推 <code>Ctrl</code> <code>shift</code> <code>K</code></p></blockquote><p>将<a href="https://intellijidea.com.cn/help/idea/set-up-a-git-repository.html#add-new-files">新文件添加到 Git 存储库</a>，或修改已在 Git 版本控制下的文件，并且您对它们的当前状态感到满意后，您可以共享您的工作结果。这涉及到在本地<a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#commit">提交</a>它们以将存储库的快照记录到项目历史记录中，然后将它们<a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#push">推</a>送到远程存储库以便其他人可以使用它们。</p><p><strong>1、设置您的 Git 用户名</strong>﻿</p><p>Git 需要知道您的用户名才能将提交与身份关联起来。如果您尚未设置用户名，IntelliJ IDEA 将在您首次尝试提交更改时提示您指定用户名。</p><ul><li>打开<a href="https://intellijidea.com.cn/help/idea/terminal-emulator.html">终端</a>并执行以下命令之一：<ul><li>要为计算机上的每个 Git 存储库设置名称，请使用<code>$ git config --global user.name &quot;John Smith&quot;</code></li><li>要为单个存储库设置名称，请使用<code>$ git config user.name &quot;John Smith&quot;</code></li></ul></li></ul><p><strong>2、在本地提交更改</strong>﻿</p><blockquote><ol><li><p>打开 位于左侧的垂直提交工具窗口：<code>Alt</code> <code>0</code></p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/ij_VCS_commit_tool_window.png" alt="提交工具窗口"></p></li><li><p>当您的更改准备好提交时，选择相应的文件或整个更改列表。</p><p>如果按，将选择整个活动更改列表。<code>Ctrl</code> <code>K</code></p><p>您还可以选择Unversioned Files节点下的文件 - IntelliJ IDEA 将一步暂存并提交这些文件。</p></li><li><p>如果要将<a href="https://intellijidea.com.cn/help/idea/edit-project-history.html#amend-commit">本地更改附加到最新提交</a>而不是创建单独的提交，请选择“修改”选项。</p></li><li><p>输入提交消息。您可以单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.history.svg" alt="提交消息历史记录按钮">以从最近提交消息的列表中进行选择。</p><p>您还可以稍后在推送提交之前<a href="https://intellijidea.com.cn/help/idea/edit-project-history.html#reword-commit">编辑提交消息。</a></p><blockquote><p>您可以在版本控制 |上自定义提交消息规则。IDE 设置的 提交页面。还有一个快速修复和重新格式化操作，可以换行长行或重新格式化消息。CtrlAlt0S</p><p>您还可以定义将用作默认提交消息的提交模板。指定要在**.txt**文件中使用的样板文本，并在终端中执行以下命令将其添加到 Git 配置中：<code>git config --local commit.template &lt;path_to_template_file&gt;</code></p></blockquote></li><li><p>如果您需要执行提交检查、提交后将文件上传到服务器或使用高级选项提交，请单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.gearPlain.svg" alt="齿轮图标">右下角的 ：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/ij_VCS_advanced_commit_options.png" alt="高级提交选项弹出窗口"></p><p>可以使用以下选项：</p><ul><li><p>作者：如果您要提交其他人所做的更改，您可以指定这些更改的作者。</p></li><li><p>签署提交：选择是否要签署提交以证明您要签入的更改是由您做出的，或者您对所提交的代码负责。</p><p>启用此选项后，将以下行自动添加到提交消息的末尾：签署人：&lt;用户名&gt;</p></li><li><p>在提交检查区域中，选择您希望 IntelliJ IDEA 在将所选文件提交到本地存储库时执行的操作。</p><p>可以使用以下选项：</p><ul><li>重新格式化代码：根据<a href="https://intellijidea.com.cn/help/idea/settings-code-style.html">项目代码样式</a>设置执行代码格式化。</li><li>重新排列代码：根据<a href="https://intellijidea.com.cn/help/idea/reformat-and-rearrange-code.html">偏好的排列规则</a>重新排列您的代码。</li><li>优化导入：删除多余的导入语句。</li><li>分析代码：在提交修改的文件时分析它们。单击选择配置文件以选择IDE 将运行检查的检查<a href="https://intellijidea.com.cn/help/idea/customizing-profiles.html">配置文件。</a></li><li>检查 TODO (&lt;过滤器名称&gt;)：查看与指定过滤器匹配的<a href="https://intellijidea.com.cn/help/idea/using-todo.html">TODO 项。</a>单击“配置”以选择<a href="https://intellijidea.com.cn/help/idea/using-todo.html">现有的 TODO 过滤器</a>，或打开<a href="https://intellijidea.com.cn/help/idea/settings-todo.html">TODO 设置页面</a>并定义要应用的新过滤器。</li><li>清理：批量应用代码清理检查中的快速修复。单击选择配置文件以选择IDE 将运行检查的<a href="https://intellijidea.com.cn/help/idea/customizing-profiles.html">配置文件。</a></li><li>运行测试：<a href="https://intellijidea.com.cn/help/idea/performing-tests.html#run-tests-after-commit">运行测试作为提交检查</a>。单击运行测试附近的选择配置，然后选择要运行的配置。</li><li>更新版权：根据所选的版权配置文件 - 范围组合添加或更新版权声明。</li></ul></li><li><p>在“提交后”区域中，您可以选择用于将提交的文件上传到本地或远程主机、已安装的磁盘或目录的<a href="https://intellijidea.com.cn/help/idea/configuring-synchronization-with-a-remote-host.html">服务器</a>访问配置或<a href="https://intellijidea.com.cn/help/idea/server-groups.html">服务器组。</a>有关更多信息，请参阅<a href="https://intellijidea.com.cn/help/idea/deploying-applications.html">部署您的应用程序</a>。</p><p>可以使用以下选项：</p><ul><li><p>运行工具：选择您希望 IntelliJ IDEA 在提交所选更改后启动的<a href="https://intellijidea.com.cn/help/idea/configuring-third-party-tools.html">外部工具。</a>您可以从列表中选择一个工具，或者单击“浏览”按钮并在打开的<a href="https://intellijidea.com.cn/help/idea/settings-tools-external-tools.html">“外部工具”</a><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.ellipsis.svg" alt="浏览按钮">对话框中配置外部工具。</p></li><li><p>将文件上传到：选择<a href="https://intellijidea.com.cn/help/idea/configuring-synchronization-with-a-remote-host.html">服务器访问配置</a>或<a href="https://intellijidea.com.cn/help/idea/server-groups.html">服务器组</a>，用于将提交的文件上传到本地或远程主机、已安装的磁盘或目录。</p><ul><li>要禁止上传，请选择None。</li><li>要将服务器配置添加到列表中，请单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.ellipsis.svg" alt="浏览按钮">并填写打开的“添加服务器”对话框中的必填字段。</li></ul><p>仅当启用FTP&#x2F;SFTP&#x2F;WebDAV 连接插件时，该列表才可用。</p></li><li><p>始终使用选定的服务器或服务器组：始终将文件上传到选定的<a href="https://intellijidea.com.cn/help/idea/configuring-synchronization-with-a-remote-host.html">服务器</a>或<a href="https://intellijidea.com.cn/help/idea/server-groups.html">服务器组</a>。</p><p>仅当启用FTP&#x2F;SFTP&#x2F;WebDAV 连接插件时，该复选框才可用。</p></li></ul></li></ul></li><li><p>准备就绪后，单击“提交”或“提交并推送”( ) 在提交后立即将更改推送到远程存储库。您将能够在将当前提交以及所有其他提交推送到远程之前查看它们。<code>Ctrl</code> <code>Alt</code> <code>K</code></p></li></ol></blockquote><p><strong>3、提交文件的一部分</strong>﻿</p><p>有时，当您进行与特定任务相关的更改时，您还会应用影响同一文件的其他不相关的代码修改。<a href="https://intellijidea.com.cn/help/idea/undo-changes.html#revert-commit">将所有此类更改包含到一次提交中可能不是一个好的选择，因为审查、恢复</a>、<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#cherry-pick">挑选</a>它们等会更加困难。</p><p>IntelliJ IDEA 允许您通过以下方式之一单独提交此类更改：</p><ul><li><p>在“提交更改”对话框中选择要包含在提交中的修改后的<a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#select_chunks_in_commit_changes_dialog">代码块和行</a>，并将其他更改保留为待处理状态，以便稍后可以提交它们。</p></li><li><p>当您编辑代码时，将不同的代码块即时<a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#put_changes_into_different_changelists">放入不同的更改列表中，然后分别提交这些更改列表。</a></p><blockquote><p>您还可以创建一个新的更改列表并<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#changelists">使其处于活动状态</a>，然后您之后所做的所有更改都将落入该更改列表中，而您之前所做的任何修改都将保留在原处。</p></blockquote></li></ul><p><strong>4、选择要提交的块和特定行</strong>﻿</p><blockquote><ol><li><p>打开 提交工具窗口。<code>Alt</code> <code>0</code></p></li><li><p>要显示所选文件的存储库版本和本地版本之间的差异，请在 提交工具窗口中单击工具栏上的 或按。<code>Alt</code> <code>0</code><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.diff.svg" alt="差异图标"><code>Ctrl</code> <code>D</code></p></li><li><p>选中要提交的每个已修改或新添加的代码块旁边的复选框，并保留其他更改未选中：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/partial_commit_dialog.png" alt="部分提交对话框"></p><blockquote><p>您还可以从已修改块的上下文菜单中选择移动到另一个更改列表，以在可以单独提交的不同更改列表之间拆分更改。</p><p>要为此操作分配自定义快捷方式，请在IDE 设置的“ 键盘映射”页面上的“版本控制系统”下查找“将行移至另一个更改列表”操作。<code>Ctrl</code> <code>Alt</code> <code>s</code></p></blockquote></li><li><p>如果您只想提交块中的特定行，请右键单击要包含的行，然后选择“ 拆分块”和“将所选行包含到提交中”。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/include_line_to_commit.png" alt="IntelliJ IDEA：在上下文菜单中的提交中包含当前行的选项"></p><p>或者，将鼠标悬停在装订线上，然后选择或清除要包含在提交中或从中排除的行旁边的复选框。</p></li><li><p>单击“提交”。未选定的更改将保留在当前更改列表中，以便您可以单独提交它们。</p></li></ol></blockquote><p><strong>5、将更改放入不同的更改列表中</strong>﻿</p><blockquote><ol><li><p>当您在编辑器中对文件进行更改时，请单击装订线中相应的<a href="https://intellijidea.com.cn/help/idea/adding-files-to-version-control.html#track_changes">更改标记。</a></p><blockquote><p>如果装订线中没有更改标记，请确保在编辑器 |装订线中启用突出显示装订线中修改的行选项。IDE 设置的 常规页面。<code>Ctrl</code> <code>Alt</code> <code>s</code></p></blockquote></li><li><p>在出现的工具栏中，选择已修改代码块的目标变更列表（或创建新的变更列表）：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/partial_commit_changelists.png" alt="部分提交变更列表"></p></li><li><p>单独提交每个变更列表。</p></li></ol></blockquote><p><strong>6、使用 Git 暂存区提交更改</strong>﻿</p><p><a href="https://git-scm.com/docs/git-add">如果您更习惯于提交</a>更改的暂存概念，而不是使用自动暂存修改文件的<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#changelists">更改列表</a>，请按 打开 IDE 设置并选择版本控制 | Git，然后选择启用暂存区域复选框。<code>Ctrl</code> <code>Alt</code> <code>s</code></p><p>提交工具窗口现在如下所示：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_staging_area.png" alt="Git暂存区"></p><p>使用暂存区域可以让您轻松地分别提交对同一文件的更改（包括重叠更改），并查看哪些更改已经暂存，而无需从编辑器切换焦点。</p><blockquote><p>当您从使用更改列表切换到 Git 暂存区域时，所有现有更改列表都会保存。您可以在两种模式之间切换，而不会丢失所做的更改。</p></blockquote><p><strong>7、提交的阶段更改</strong>﻿</p><ol><li><p>执行以下操作之一：</p><ul><li><p>要暂存整个文件，请在 “提交”工具窗口中选择该文件并单击其右侧的 或按。<code>Alt</code> <code>0</code><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.add.svg" alt="添加按钮"><code>Ctrl</code> <code>Alt</code> <code>A</code></p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_stage_from_toolwindow.png" alt="从“提交”工具窗口进入阶段"></p></li><li><p>要暂存文件中的特定块，请在编辑器中单击已修改块旁边的装订线中的<a href="https://intellijidea.com.cn/help/idea/adding-files-to-version-control.html#track_changes">更改标记，然后单击</a>暂存。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_stage_from_editor.png" alt="编辑器的阶段更改"></p><p>暂存的更改（包括从 IntelliJ IDEA 外部暂存的更改）在编辑器中用边框形状的更改标记进行标记：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_staged_marker.png" alt="用于分阶段更改的装订线标记"></p></li><li><p>要暂存粒度更改，例如单行而不是代码块，甚至是对单行的多个更改之一，请在“ 提交”工具窗口中，选择包含更改的文件，然后从上下文菜单中选择“比较 HEAD”、“暂存版本”和“本地版本”。<code>Alt</code> <code>0</code></p><p>这将打开一个三向<a href="https://intellijidea.com.cn/help/idea/differences-viewer.html">差异查看器</a>，其中左窗格显示存储库版本，右窗格显示本地版本，中央窗格是一个功能齐全的编辑器，您可以在其中进行想要暂存的更改。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_stage_interactively.png" alt="舞台交互变化"></p></li></ul></li><li><p><a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#commit_tool_window">准备就绪后，按照本地提交更改</a>中所述提交更改。</p></li></ol><p><strong>8、将更改推送到远程存储库</strong>﻿</p><p>在推送更改之前，<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html">请与远程同步</a>并确保存储库的本地副本是最新的以避免冲突。</p><p>IntelliJ IDEA 允许您将更改从任何分支上传到其<a href="https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches">跟踪分支</a>或任何其他远程分支。</p><blockquote><ol><li><p>执行以下操作之一：</p><ul><li>要从当前分支推送更改，请按或选择 Git | 从主菜单推送。CtrlShift0K</li><li>要从任何具有远程分支的本地分支推送更改，请在“分支”弹出窗口中选择该分支，然后从操作列表中选择“推送” 。</li></ul><p>“推送提交”对话框将打开，显示所有 Git 存储库（对于多存储库项目）并列出自上次推送以来在每个存储库的当前分支中进行的所有提交。</p><p>如果您的项目使用多个非同步控制的存储库，则默认情况下仅选择当前存储库（有关启用同步存储库控制的更多信息，请参阅<a href="https://intellijidea.com.cn/help/idea/settings-version-control-git.html">版本控制设置：Git</a>）。</p><blockquote><p>您可以按所选提交来显示额外信息，例如提交作者、时间、哈希值和提交消息。Ctrl0Q</p></blockquote></li><li><p>如果存储库中没有遥控器，则会显示“定义远程”链接。单击此链接并在打开的对话框中指定远程名称和 URL。它将被保存，您可以稍后通过 Git 进行编辑 | 管理远程（有关更多信息，请参阅<a href="https://intellijidea.com.cn/help/idea/set-up-a-git-repository.html#add-remote">添加远程存储库</a>）。</p></li><li><p>如果你想修改要推送的目标分支，可以点击分支名称。该标签会变成一个文本字段，您可以在其中键入现有分支名称或创建新分支。您还可以单击右下角的编辑所有目标链接来同时编辑所有分支名称。</p><p>请注意，您无法更改本地分支：将推送每个选定存储库的当前分支。</p><blockquote><p>您还可以通过按所选元素的或切换到编辑模式。EnterF2</p></blockquote></li><li><p>如果您已经进行了一些提交但还不想推送到远程分支，请在Git工具窗口的“日志”选项卡中选择要推送的最后一个提交，然后从列表中选择“将所有内容推送到此处…”选项行动。</p><p>“推送提交”对话框将打开，显示直到所选提交哈希的所有提交。</p></li><li><p>如果您想在推送更改之前预览更改，请选择所需的提交。右侧窗格显示所选提交中包含的更改。您可以使用工具栏按钮检查提交详细信息。</p><p>如果提交的作者与当前用户不同，则该提交将标有星号。</p><blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>如果您选择整个存储库，所有提交的所有文件将在右窗格中列出。</p><p>如果在多次提交中修改了同一文件，则当您选择这些提交或整个存储库时，该文件只会列出一次，并且如果您为此文件调用<a href="https://intellijidea.com.cn/help/idea/differences-viewer.html">差异查看器，则所有更改都将被压缩在一起。</a></p></blockquote></li><li><p>准备好后单击“推送”按钮，然后从下拉菜单中选择要执行的操作：“推送”或“强制推送”（相当于<code>push --force-with-lease</code>）。</p><p>仅当当前分支未在受保护的分支字段中列出时（请参阅<a href="https://intellijidea.com.cn/help/idea/settings-version-control-git.html">版本控制设置：Git</a>），这些选择选项才可用，否则，您只能执行该<code>push</code>操作。</p></li></ol></blockquote><p><strong>9、如果推送被拒绝，请更新您的工作副本</strong>﻿</p><p>如果由于工作副本已过时而拒绝推送，IntelliJ IDEA 将显示“推送被拒绝”对话框，前提是未选择“设置”对话框的<a href="https://intellijidea.com.cn/help/idea/settings-version-control-git.html">Git 设置</a>页面中的“如果当前分支的推送被拒绝则自动更新”选项。请执行下列操作：</p><blockquote><ol><li><p>如果您的项目使用多个 Git 存储库，请指定要更新其中的哪个。如果您想要更新所有存储库，无论推送是否被拒绝，请选择更新所有存储库选项。如果清除此选项，则仅更新受影响的存储库。</p></li><li><p>如果您希望 IntelliJ IDEA 在下次使用您在此对话框中选择的更新方法拒绝推送时静默应用更新过程，请选择记住更新方法选择并在将来静默更新选项。</p><p>离开此对话框后， “设置”对话框的<a href="https://intellijidea.com.cn/help/idea/settings-version-control-git.html">Git 设置</a>页面中的“如果当前分支的推送被拒绝，则自动更新”复选框将被选中，并且应用的更新方法将成为默认方法。</p><p>要更改更新策略，请取消选择此选项以在下次当前分支的推送被拒绝时调用“推送被拒绝”对话框，应用不同的更新过程，然后再次选择“记住更新方法选择”选项。</p></li><li><p>通过分别单击<a href="http://schacon.github.io/git/git-rebase.html">“变基”</a>或“合并”按钮来选择更新方法（ “变基”或“<a href="http://schacon.github.io/git/git-merge.html">合并”）。</a></p></li></ol></blockquote><p><strong>10、什么时候需要使用强制推送？</strong>﻿</p><p>当您运行push时，如果远程存储库中有您丢失的更改并且您将用存储库的本地副本覆盖，Git 将拒绝完成操作。通常，您需要执行<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html#pull">拉取</a>以与远程同步，然后再使用更改进行更新。</p><p>该<code>--force push</code>命令禁用此检查并允许您覆盖远程存储库，从而擦除其历史记录并导致数据丢失。在幕后，当您选择强制推送时，IntelliJ IDEA 会执行该<code>push --force-with-lease</code>操作，这是一个更安全的选项，可帮助您确保不会覆盖其他人的提交（有关推送选项的更多详细信息，请参阅<a href="https://git-scm.com/docs/git-push">git Push ）。</a></p><p>您可能仍需要执行的一种可能情况<code>--force push</code>是，您对推送的分支进行变基，然后想要将其推送到远程服务器。在这种情况下，当您尝试推送时，Git 将拒绝您的更改，因为远程引用不是本地引用的祖先。如果您在这种情况下执行拉取，您最终将得到分支的两个副本，然后需要合并它们。</p><h2 id="比较文件和文件夹版本"><a href="#比较文件和文件夹版本" class="headerlink" title="比较文件和文件夹版本"></a>比较文件和文件夹版本</h2><p>IntelliJ IDEA 允许您检查文件&#x2F;文件夹的两个修订版之间或其当前本地副本与存储库版本之间的差异。差异显示在差异查看器中。</p><p><strong>有关在差异查看器</strong>中过滤、导航和应用更改的更多信息，请参阅<a href="https://intellijidea.com.cn/help/idea/comparing-files-and-folders.html">比较文件、文件夹和文本源</a>。</p><p><strong>1、将修改后的文件与其 Git 存储库版本进行比较</strong>﻿</p><blockquote><ol><li><p>打开 提交工具窗口。Alt00</p></li><li><p>在更改列表中找到所需的文件并执行以下操作之一：</p><ul><li>右键单击该文件并选择Git | 显示差异。</li><li>选择文件并按。Ctrl0D</li><li>双击该文件。</li></ul></li><li><p>将打开差异视图，其中突出显示对文件的更改。</p><p>右窗格包含文件的修改版本。您可以在差异视图中对其进行编辑。</p><p>左窗格包含文件的初始版本。它是只读的。您可以单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.expui.diff.applyNotConflictsLeft.svg" alt="恢复">(恢复) 来撤消更改。</p></li></ol></blockquote><p><strong>2、将文件或文件夹的当前版本与同一 Git 分支中的版本进行比较</strong>﻿</p><blockquote><ol><li>在“项目”工具窗口中选择一个文件或文件夹，然后选择“Git | Git”。从上下文菜单中与修订版进行比较。</li><li>从打开的对话框中选择要与当前文件或文件夹版本进行比较的修订版本。</li></ol></blockquote><p><strong>3、将文件或文件夹的当前版本与另一个 Git 分支进行比较</strong>﻿</p><blockquote><ol><li>在“项目”工具窗口中选择一个文件或文件夹，然后选择“Git | Git”。从上下文菜单中与分支进行比较。</li><li>从打开的对话框中选择要与当前文件或文件夹版本进行比较的分支。</li></ol></blockquote><h2 id="调查-Git-存储库中的更改"><a href="#调查-Git-存储库中的更改" class="headerlink" title="调查 Git 存储库中的更改"></a>调查 Git 存储库中的更改</h2><p>在IntelliJ IDEA中，您可以追溯项目中的所有更改&gt;。这可以帮助您<a href="https://intellijidea.com.cn/help/idea/investigate-changes.html#annotate_blame">找到任何更改的作者，查看</a><a href="https://intellijidea.com.cn/help/idea/investigate-changes.html#file-history">文件版本</a>或提交之间的差异，并在必要时<a href="https://intellijidea.com.cn/help/idea/undo-changes.html">安全地回滚和撤消</a>更改。</p><p><strong>1、回顾项目历史</strong>﻿</p><p>您可以查看对与指定过滤器匹配的项目源所做的所有更改。要查看项目历史记录，请打开 Git工具窗口 的 “日志”选项卡。它显示了提交给所有分支和远程存储库的所有更改 <code>Alt</code> <code>9</code>：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_log_view.png" alt="日志视图"></p><p>在多存储库项目中，左侧的彩色条纹指示所选提交属于哪个根（每个根都标有自己的颜色）。将鼠标悬停在彩色条纹上可调用显示根路径的提示：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/log_root_path.png" alt="根路径"></p><p><strong>2、浏览和搜索项目历史记录</strong>﻿</p><ul><li><p>通过输入完整的提交名称或消息或其片段、修订号或正则表达式来搜索提交列表。</p></li><li><p>按分支或最喜欢的分支、用户、日期和文件夹（或多根项目的根和文件夹）过滤提交。</p></li><li><p>单击工具栏上的“转到哈希&#x2F;分支&#x2F;标签” 图标，或按并指定提交哈希、<a href="https://intellijidea.com.cn/help/idea/use-tags-to-mark-specific-commits.html">标签</a>或要跳转到的分支的名称（您将被带到该分支中的最新提交）。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.find.svg" alt="去"><code>Ctrl</code> <code>F</code></p></li><li><p>单击箭头跳转到长分支中的下一个提交：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/jumpToNextCommit.png" alt="跳转到下一个提交"></p></li><li><p>按和键跳转到父&#x2F;子提交。如果您在Git工具窗口 的“日志”选项卡 中混合了对不同存储库和多个分支的提交，这尤其有用 。<code>←</code> <code>→</code> <code>Alt</code> <code>9</code></p></li></ul><blockquote><ul><li>按 将焦点切换到搜索字段。Ctrl0L</li><li>为了避免来回设置过滤器，请单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.add.svg" alt="添加按钮">工具栏上的 来打开与您的过滤器匹配的新选项卡。</li><li>要自定义日期格式，请转至设置 | 外观和行为| 系统设置| 日期格式。</li></ul></blockquote><p>有关 Git工具窗口 的 “日志”选项卡的更多信息，请参阅<a href="https://intellijidea.com.cn/help/idea/log-tab.html">“日志”选项卡</a>。<code>Alt</code> <code>9</code></p><p><strong>3、查看特定修订版的项目快照</strong>﻿</p><p>IntelliJ IDEA 允许您在选定的修订版本中查看项目的状态。</p><blockquote><ol><li>打开 Git工具窗口 并切换到“日志”选项卡。<code>Alt</code> <code>9</code></li><li>选择一个提交，然后从上下文菜单中选择“显示修订版本的存储库” 。</li></ol></blockquote><p>将打开“存储库”工具窗口，其中包含所选版本的项目快照。</p><p><strong>4、查看两次提交之间的差异</strong>﻿</p><p>IntelliJ IDEA 允许您检查两次提交之间修改了哪些文件，而不必浏览两次提交之间的更改。</p><blockquote><ul><li><p>在Git工具窗口 的 “日志”选项卡中选择任意两个提交 ，然后从上下文菜单中选择“比较版本” 。<code>Alt</code> <code>9</code></p><p>将打开“更改”工具窗口，其中包含所选提交之间修改的文件列表。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/devkit.icons.gutter.diff.svg" alt="显示差异图标">您可以通过单击或按 来查看任何文件的差异。<code>Ctrl</code> <code>D</code></p></li></ul></blockquote><p><strong>5、查看文件历史记录</strong>﻿</p><p>您可以查看对特定文件所做的所有更改，并查找每个版本中具体修改的内容。</p><blockquote><ol><li>在任何视图（项目工具窗口、编辑器、 更改视图等）中选择必要的文件。</li><li>选择Git | 从VCS主菜单或选择的上下文菜单显示历史记录。“历史记录”选项卡已添加到 Git工具窗口，显示所选文件的历史记录，并允许您查看和比较其修订版本。</li><li>要确定特定修订版中引入了哪些更改，请在列表中选择它。在面板的右侧立即显示差异。</li><li>要在专用差异查看器中查看整个文件的差异，请在列表中选择它，然后按或单击工具栏上的按钮。<a href="https://intellijidea.com.cn/help/idea/differences-viewer.html">差异查看器</a>将打开，显示此版本中的更改。<code>Ctrl</code> <code>D</code><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.diff.svg" alt="显示差异"></li></ol></blockquote><p><strong>6、查看本地和提交的文件版本之间的差异</strong></p><p>您可以检查提交的文件修订与其本地版本有何不同：</p><blockquote><ol><li>打开 Git工具窗口 并切换到“日志”选项卡。<code>Alt</code> <code>9</code></li><li>选择您感兴趣的提交，然后在右侧窗格中选择文件。</li><li>单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.diff.svg" alt="显示差异">工具栏上的按钮。</li></ol></blockquote><p><strong>7、查看更改的合并方式</strong>﻿</p><p>IntelliJ IDEA 允许您查看如何将更改<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#merge">从一个分支合并到另一个分支</a>，以及在合并期间如何<a href="https://intellijidea.com.cn/help/idea/resolve-conflicts.html">解决冲突（如果有）：</a></p><blockquote><ul><li><p>在 Git工具窗口 的 “日志”选项卡中，选择您感兴趣的合并提交。<code>Alt</code> <code>9</code></p><ul><li><p>如果在合并过程中未检测到并解决任何冲突，IntelliJ IDEA 将在“更改的文件”窗格中显示相应的消息，并建议检查源自父级的更改：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/vcs_log_changes_from_parents.png" alt="来自父母的改变"></p><p>从节点之一选择所需的文件，然后单击工具栏上的“显示差异” 图标或按。<a href="https://intellijidea.com.cn/help/idea/differences-viewer.html">差异查看器</a>将显示两个面板的差异，允许您将当前版本与选定的父版本进行比较。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.diff.svg" alt="显示差异"><code>Ctrl</code> <code>D</code></p></li><li><p>如果合并期间发生冲突，“更改的文件”窗格将显示合并有冲突的文件列表。</p><p>选择所需的文件，然后单击工具栏上的“显示差异” 图标或按。<a href="https://intellijidea.com.cn/help/idea/differences-viewer.html">差异查看器</a>将显示一个三面板差异，允许您将当前版本与其每个父版本进行比较，并查看冲突是如何解决的。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.diff.svg" alt="显示差异"><code>Ctrl</code> <code>D</code></p></li></ul></li></ul></blockquote><p><strong>8、找到代码作者（使用 Git Blame 进行注释）</strong>﻿</p><p>您可以使用VCS 注释（对应于<a href="https://git-scm.com/docs/git-blame">git-blame</a> ）找出谁对文件引入了哪些更改。带注释的视图显示了每行代码的详细信息：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/annotate.png" alt="注释"></p><p>当前版本中修改的行的注释用粗体和星号标记。</p><p>默认情况下，不同的提交以不同的颜色突出显示（请参阅<a href="https://intellijidea.com.cn/help/idea/investigate-changes.html#configure-annotations">配置注释中显示的信息量</a>）。</p><p>从注释视图，您可以跳转到：</p><ul><li><p>Git工具窗口 的“日志”选项卡 中的相应提交 ：单击注释或将鼠标悬停在其上，然后单击弹出窗口中包含详细信息的提交哈希。<code>Alt</code> <code>9</code></p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git-blame-hover.png" alt="弹出窗口，其中包含有关提交的详细信息"></p></li><li><p>行的差异：将鼠标悬停在注释上。IDE 将突出显示该行以及相应提交的更改。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git-blame-difference-in-lines.png" alt="线路差异"></p></li><li><p><a href="https://github.com/">https://github.com</a>上的相应提交：使用Open on GitHub上下文菜单选项。</p></li><li><p>如果启用了<a href="https://intellijidea.com.cn/help/idea/handling-issues.html">问题导航</a>，则错误跟踪系统中的相关问题：将鼠标悬停在注释上，然后单击问题链接（如果提交消息中包含该链接）</p></li></ul><blockquote><p><strong>启用注释</strong>﻿</p><ul><li><p>右键单击编辑器或<a href="https://intellijidea.com.cn/help/idea/differences-viewer.html">差异查看器</a>中的装订线，然后从上下文菜单中选择使用 Git Blame 进行注释。</p><p>您可以为“注释”命令分配自定义快捷方式：转到IDE 设置的 “键盘映射”页面，然后查找“版本控制系统”|“版本控制系统”。git | git 注释。CtrlAlt0S</p><p>要关闭注释，请右键单击编辑器或<a href="https://intellijidea.com.cn/help/idea/differences-viewer.html">差异查看器</a>中的装订线，然后从上下文菜单中选择“关闭注释” 。</p></li></ul></blockquote><blockquote><p><strong>配置注释中显示的信息量</strong>﻿</p><p>您可以选择要在注释视图中查看的信息量。</p><ul><li><p>右键单击注释装订线，选择“查看”并选择要查看的信息类型，包括此更改源自的修订版、日期、不同格式的作者姓名以及提交号。</p><p>您还可以在“颜色”下设置突出显示。</p></li></ul></blockquote><blockquote><p><strong>配置注释选项</strong>﻿</p><ul><li>右键单击注释装订线并从上下文菜单中选择选项：<ul><li>忽略空格：空格将被忽略（git <code>blame -w</code>）。这意味着注释将指向先前有意义的提交。</li><li>检测文件内的移动：当提交在同一文件中移动或复制行时，此类更改将被忽略（git <code>blame -M</code>）。这意味着注释将指向先前有意义的提交。</li><li>检测跨文件的移动：当提交移动或复制在同一提交中修改的其他文件中的行时，此类更改将被忽略（git <code>blame -C</code>）。这意味着注释将指向先前有意义的提交。</li><li>显示提交时间戳：如果您希望 IntelliJ IDEA 在注释视图中显示提交时间戳而不是创作更改的时间，请选择此选项。</li></ul></li></ul></blockquote><blockquote><p><strong>自定义日期格式</strong>﻿</p><ol><li>按打开 IDE 设置，然后选择外观和行为 | 系统设置| 日期格式。<code>Ctrl</code> <code>Alt</code> <code>S</code></li><li>单击“VCS 注释”旁边的“日期时间模式”字段，并指定要用于 VCS 注释的日期格式。请参阅<a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html">模式参考</a>。</li></ol></blockquote><blockquote><p><strong>在编辑器中显示更改的作者</strong>﻿</p><p><a href="https://intellijidea.com.cn/help/idea/inlay-hints.html">您可以将编辑器配置为在嵌入提示</a>中显示对元素（方法或类）的最后更改的作者。要打开它们：</p><ol><li><p>按打开 IDE 设置，然后选择编辑器 | 镶嵌提示| 代码愿景。CtrlAlt0S</p></li><li><p>选择代码作者选项。</p></li><li><p>选择显示作者姓名的位置：</p><ul><li><p>在线顶部（默认）</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/annotate-inlay-hints-top-hl.png" alt="代码视觉镶嵌提示 置顶"></p></li><li><p>在右侧</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/annotate-inlay-hints-right-hl.png" alt="代码视觉镶嵌提示右"></p></li></ul></li></ol><p>启用此选项后，您可以单击编辑器中的作者姓名提示来打开带注释的视图。</p></blockquote><blockquote><p><strong>隐藏更改的作者</strong>﻿</p><p>要在编辑器中隐藏代码作者的姓名，请执行以下操作之一：</p><ul><li>打开编辑器 | 镶嵌提示| IDE 设置的 “代码视觉”页面并禁用“代码作者”选项。CtrlAlt0S</li><li>右键单击编辑器中的作者姓名提示，然后选择Hide <code>Code Vision: Code Author</code> Inlay Hints。</li></ul></blockquote><p><strong>9、注释以前的修订</strong>﻿</p><p>IntelliJ IDEA 不仅允许您注释当前文件修订版本，还可以注释其先前的修订版本。注释装订线的上下文菜单提供以下选项：</p><ul><li>注释修订：如果您想检查提交特定更改后文件的外观，此选项非常有用。</li><li>注释以前的修订：如果您发现自己处于特定行中的最后更改毫无意义的情况（例如，如果所有更改都是代码格式），则此选项很有用。在这种情况下，您可以检查该文件的先前版本是什么样子。</li><li>隐藏修订：此选项有助于避免看到不相关或管理更改。这些通常是由低级迁移或格式化操作引入的。当这些更改影响整个根时，它们会在“注释”对话框中造成混乱，因此可能需要从视图和“注释”列中排除更改。“隐藏修订”操作允许您从注释结果中就地排除修订，并在编辑器和装订线中显示结果。可以使用相反的操作“恢复隐藏修订”来恢复排除的修订。有关隐藏修订的信息显示在编辑器顶部的通知面板中。还可以通过单击通知面板中的相应链接来恢复隐藏的修订。</li></ul><p>您还可以从“历史记录”视图中注释特定文件。在“历史记录”选项卡中，选择要查看的文件版本，右键单击相应行并从上下文菜单中选择“注释” 。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA 使用 Git 详解(一)</title>
      <link href="/posts/7f7493d0.html"/>
      <url>/posts/7f7493d0.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/load.gif" data-original="https://n.sinaimg.cn/sinakd10116/612/w2000h1012/20200629/34e0-ivrxcex3246619.jpg" alt=" https://n.sinaimg.cn/sinakd10116/612/w2000h1012/20200629/34e0-ivrxcex3246619.jpg"></p><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>使用 <code>VSC</code> 操作弹出窗口或 <code>VSC|VSC 操作弹出窗口</code> 可快速调用任何 VSC 相关命令。<code>Alt ~</code></p><p>弹出窗口中的操作列表取决于当前启用的 VSC 。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/vcs_operations_quick_list.png" alt="vcs_operations_quick_list.png"></p><blockquote><p>VSC 操作弹出命令列表是可配置的 - 你可以在 <strong>外观和行为 | 上添加或删除它们</strong> 。IDE 设置的 <strong>菜单和工具栏页</strong> 面。<code>Ctrl</code> <code>Alt</code> <code>S</code></p></blockquote><p>你还可以使用以下快捷键方式调用全局版本控制命令：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>VCS 操作弹出窗口…</td><td><code>Alt</code> <code>~</code></td></tr><tr><td><a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html">犯罪…</a></td><td><code>Ctrl</code> <code>K</code></td></tr><tr><td><a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html">更新项目</a></td><td><code>Ctrl</code> <code>T</code></td></tr><tr><td><a href="https://intellijidea.com.cn/help/idea/undo-changes.html">回滚</a></td><td><code>Ctrl</code> <code>Alt</code> <code>Z</code></td></tr><tr><td><a href="https://intellijidea.com.cn/help/idea/using-git-integration.html">推…</a></td><td><code>Ctrl</code> <code>Shift</code> <code>K</code></td></tr><tr><td><a href="https://intellijidea.com.cn/help/idea/viewing-changes-information.html">下一个变化</a></td><td><code>Ctrl</code> <code>Alt</code> <code>Shift</code> <code>↓</code></td></tr><tr><td><a href="https://intellijidea.com.cn/help/idea/viewing-changes-information.html">之前的变更</a></td><td><code>Ctrl</code> <code>Alt</code> <code>Shift</code> <code>↑</code></td></tr><tr><td>显示版本控制窗口</td><td><code>Alt</code> <code>9</code></td></tr><tr><td><a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html">显示提交窗口</a></td><td><code>Alt</code> <code>0</code></td></tr></tbody></table><hr><h1 id="启用版本控制"><a href="#启用版本控制" class="headerlink" title="启用版本控制"></a>启用版本控制</h1><p><strong>IntelliJ IDEA</strong> 支持两个级别的版本控制集成：</p><ul><li>在 IDE 级别，VSC 集成是通过一组默认启用的捆绑插件提供的。</li><li>在项目级别，通过将项目文件夹与一个或多个版本控制系统关联来启用 VSC 集成。</li></ul><h2 id="将项目根与版本控制系统关联"><a href="#将项目根与版本控制系统关联" class="headerlink" title="将项目根与版本控制系统关联"></a>将项目根与版本控制系统关联</h2><p>IntelliJ IDEA 允许快速启用项目与版本控制系统的集成，并将其与项目根相关联。</p><p>有关将单独的项目目录与不同版本控制系统关联的更多关系，请参阅 <a href="https://intellijidea.com.cn/help/idea/enabling-version-control.html#associate_directory_with_VCS">将目录与版本控制系统关联</a> 。</p><div style="border: 2px solid rgba(106,112,119,0.56)">    <ol>        <li>按打开 <b>VSC 操作弹出窗口</b> 并选择 <b>启用版本控制集成</b> 。<code>Alt</code> <code>~</code></li>        <li>在打开的 <b>启用版本控制集成</b>对话框中，要选择要与 项目根关联的版本控制系统。</li>        <li>启用 VSC 集成后，IntelliJ IDEA 会询问你是否要通过 VSC 共享项目设置文件。你可以选择 <b>始终添加</b> 以与使用 IntelliJ IDEA 的其他存储用户同步项目设置。            <div>            <img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/sharing-project-notification.png" alt="自适应图片" style="width: 70%;height: auto;margin-left: 0">            </div>            请注意，这仅适用于 Git 和 Mercurial 。        </li>    </ol></div><h2 id="将目录与版本控制系统关联"><a href="#将目录与版本控制系统关联" class="headerlink" title="将目录与版本控制系统关联"></a>将目录与版本控制系统关联</h2><p>IntelliJ IDEA 支持基于目录的版本控制模型，这意味着每个项目目录都可以与不同的版本控制系统关联。</p><div style="border: 2px solid rgba(106,112,119,0.56)">    <ol>        <li>按打开 IDE 设置，然后选择 <b>版本控制 | 目录映射</b>。<code>Ctrl</code> <code>Alt</code> <code>S</code></li>        <li><b>目录映射</b> 页面显示项目目录和与其关联的版本控制系统的列表（如果未添加目录，则该列表仅包含项目根目录）。</li>        <li>单机右侧的 <b>添加</b> 按钮。<b>+</b></li>        <li>在打开的 <b>添加 VSC 目录映射对话框中，选择 目录</b> 选项。输入要与版本控制系统关联的目录的路径，或者单机 <b>浏览</b> 按钮 📂 并在打开的对话框中选择目录。</li>        <li>从 <b>VSC</b> 列表中，选择将用于控制此目录中的文件的版本控制系统。请注意，此列表仅包含当前启用相应插件的版本控制系统。</li>        <li>单机 <b>确定</b> 保存映射并返回 <b>目录映射</b> 页面。</li>    </ol></div><p>管理未注册的目录</p><p>对于启用了 Git 或 Mercurial 集成的项目，IntelliJ IDEA 会扫描项目目录以检查是否存在不受 IDE 控制的 Git&#x2F;Mercurial 存储库。如果检测到此类存储库，IntelliJ IDEA 会显示一条通知。</p><p>要添加未注册的根，请单击通知中的 <strong>添加根链接</strong> 。或者，打开版本控制设置页面，选择要添加的未注册根（他们标记为灰色），然后按照将目录与版本控制系统关联的过程进行操作。</p><p>如果你不想再次收到有关这些根的通知，请单机通知中的 <strong>忽略链接</strong> 。请注意，如果将新的未注册存储添加到项目中，IntelliJ IDEA 将通知你。</p><div style="border: 2px solid rgba(106,112,119,0.56)">    <div style="font-size: 1.5em; font-weight: bold;margin-left:10px;">更改 VCS 关联</div>    <ol>        <li>按打开 IDE 设置，然后选择 <b>版本控制 | 目录映射</b>。 <code>Ctrl</code> <code>Alt</code> <code>S</code></li>        <li><b>目录映射</b> 页面显示项目目录和与其关联的版本控制系统的列表（如果未添加目录，则该列表仅包含项目根目录）。</li>        <li>找到与要置于另一个版本控制系统下的目录相对应的行。</li>        <li>单机 <b>VSC</b> 列。从出现的列表中，选择新的版本控制系统。            如果你选择 <b>None</b> ，则将禁用所选目录的 VSC 集成。        </li>        <li>单机 <b>确定</b> 保存映射并返回 <b>目录映射</b> 页面。</li>    </ol></div><hr><h1 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h1><p>根据你的版本控制系统，在不同情况下可能会出现冲突。</p><p>当你在团队中工作时，你可能会遇到有人对你当前正在处理的文件提交更改的情况。如果这些更改<strong>不重叠</strong>（即，对不同的代码进行了更改），则会自动合并冲突。但是，如果相同的行受到影响，你的版本控制系统无法随机选择一侧而不是另一侧，并要求你解决冲突。</p><p>合并、变基或挑选分支时也可能会出现冲突。</p><h2 id="非分布式版本控制系统"><a href="#非分布式版本控制系统" class="headerlink" title="非分布式版本控制系统"></a>非分布式版本控制系统</h2><p>当你尝试变基服务器上具有较新版本的文件时， IntelliJ IDEA 会通知你，并在编辑器中显示一条弹出消息：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflictMessageInEditor.png" alt="冲突警告"></p><p>在这种情况下，你应该在更改文件之前更新本地版本或稍后合并更改。</p><p>如果你尝试提交具有较新存储库版本的文件，则会提交失败，并且右下角会显示一条错误，告诉你尝试提交的文件已过期。</p><blockquote><p><a href="https://intellijidea.com.cn/help/idea/settings-version-control-confirmation.html">失败的提交行为由版本控制 |中的</a>“在失败的提交列表上创建更改列表”控制。<a href="https://intellijidea.com.cn/help/idea/settings-preferences-dialog.html">设置</a>对话框的<a href="https://intellijidea.com.cn/help/idea/settings-version-control-confirmation.html">确认</a>页面。</p></blockquote><p>如果将已进行本地更改的文件与其他人提交的较新存储库版本进行同步，则会发生冲突。冲突文件将获得“已合并冲突”状态。该文件保留在“更改”视图中的同一更改列表中 ，但其名称以红色突出显示。如果文件当前在编辑器中打开，选项卡标题上的文件名也会以红色突出显示。</p><hr><h2 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h2><p>在分布式版本控制系统（例如 Git 和 Mercurial）下，当您在本地提交的文件对与最新上游版本相同的代码行进行更改时，以及当您尝试执行以下操作之一时，就会出现冲突：<a href="https://intellijidea.com.cn/help/idea/sync-with-a-remote-repository.html#pull">pull</a>、<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#merge">merge</a>、<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#rebase-branch">rebase</a>、<a href="https://intellijidea.com.cn/help/idea/apply-changes-from-one-branch-to-another.html#cherry-pick">cherry-pick</a>、<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#unstash">unstash</a>或<a href="https://intellijidea.com.cn/help/idea/using-patches.html">apply patch</a>。</p><p>如果存在冲突，这些操作将失败，并且系统将提示您接受上游版本、首选您的版本或手动合并更改：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/merge_conflicts_dialog.png" alt="IntelliJ IDEA：VCS 操作冲突对话框"></p><p>当在版本控制级别检测到冲突时，会自动触发“冲突”对话框。</p><p>如果您在此对话框中单击“关闭”或从命令行调用导致合并冲突的 Git 操作，则“本地更改”视图中将出现“合并冲突”节点，并提供用于解决这些问题的链接：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/git_merge_conflicts_node.png" alt="本地更改视图中的合并冲突节点"></p><p>IntelliJ IDEA 提供了一个在本地解决冲突的工具。该工具由三个窗格组成：</p><ul><li>左侧窗格显示只读本地副本</li><li>右窗格显示签入存储库的只读版本</li><li>中央窗格显示一个功能齐全的编辑器，其中显示合并和冲突解决的结果。最初，此窗格的内容与文件的基本修订版本相同，即派生两个冲突版本的修订版本。</li></ul><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflict_resolution_tool_legend.png" alt="冲突解决工具中的颜色编码"></p><p><strong>1、解决冲突</strong>﻿</p><ol><li><p>单击“冲突”对话框中的“合并”、“本地更改”视图中的“解决”链接，或在编辑器中选择冲突文件并选择“VCS | ”。&lt;您的VCS&gt; | 从主菜单解决冲突。</p></li><li><p>要自动合并所有不冲突的更改，请单击工具栏上的<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.diff.applyNotConflicts.svg" alt="应用不冲突的更改按钮">(应用所有不冲突的更改)。您还可以使用<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.diff.applyNotConflictsLeft.svg" alt="从左侧应用不冲突的更改按钮">（从左侧应用非冲突更改）和<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.diff.applyNotConflictsRight.svg" alt="从右侧按钮应用不冲突的更改">（从右侧应用非冲突更改）分别合并对话框左&#x2F;右部分的非冲突更改。</p></li><li><p>要解决冲突，您需要选择对左侧（本地）和右侧（存储库）版本应用哪个操作（接受<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.diff.arrow.svg" alt="接受按钮">或忽略），并在中央窗格中检查生成的代码：<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.diff.remove.svg" alt="忽略按钮"></p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/resolveConflict.png" alt="解决冲突"></p><p>您还可以右键单击中央窗格中突出显示的冲突，然后使用上下文菜单中的命令。使用左侧解决和使用右侧解决命令分别提供了从一侧接受更改并从另一侧忽略更改的快捷方式：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/resolve_using_left_right.png" alt="冲突更改的上下文菜单"></p><p>对于简单冲突（例如，如果同一行的开头和结尾已在不同的文件修订版中修改），可以使用“解决简单冲突” <img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.diff.magicResolve.svg" alt="解决简单冲突按钮">按钮，该按钮允许一键合并更改。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/simple_conflict_resolve.png" alt="解决简单冲突按钮"></p><p>此类冲突无法通过“应用所有非冲突更改”操作来解决，因为您必须确保它们得到正确解决。</p><blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>请注意，中央窗格是一个功能齐全的编辑器，因此您可以直接在此对话框中更改结果代码。</p></blockquote></li><li><p>比较不同版本以解决冲突也可能很有用。使用<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.diff.svg" alt="比较内容按钮">工具栏按钮调用选项列表。请注意，Base是指本地版本和存储库版本源自的文件版本（最初显示在中间窗格中），而Middle是指结果版本。</p></li><li><p>在中央窗格中查看合并结果，然后单击“应用”。</p></li></ol><p><strong>2、生产力技巧</strong>﻿</p><p>自动应用不冲突的更改</p><p>您可以将 IntelliJ IDEA 配置为始终自动应用不冲突的更改，而不是从“合并”对话框中告诉它这样做。为此，请选择“工具”| “自动应用不冲突的更改”选项。IDE 设置的 Diff Merge页面。<code>Ctrl</code> <code>Alt</code> <code>S</code></p><p>在中央窗格中管理更改</p><p>您可以使用将鼠标悬停在装订线中的更改标记上然后单击它时出现的工具栏来管理中央窗格中的更改。工具栏与一个框架一起显示，该框架显示修改行的先前内容：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflicts_change_toolbar.png" alt="更改工具栏"></p><p>例如，当存在多个不冲突的更改时，您只需跳过其中一两个更改，则可以更轻松地使用“应用所有不冲突的更改”操作同时应用所有更改，然后使用“还原”撤消不需要的更改。从此工具栏执行操作。</p><hr><h1 id="VCS-与问题跟踪器集成"><a href="#VCS-与问题跟踪器集成" class="headerlink" title="VCS 与问题跟踪器集成"></a>VCS 与问题跟踪器集成</h1><p>借助 IntelliJ IDEA，您可以将提交消息与错误跟踪器或问题数据库连接起来，并从 VCS 日志中的提交导航到与这些提交相关的问题。</p><p><strong>1、启用从提交消息到问题的导航</strong>﻿</p><ol><li><p>按打开 IDE 设置，然后选择版本控制 | 问题导航。<code>Ctrl</code> <code>Alt</code> <code>S</code></p></li><li><p>通过将提交消息中的问题模式与引用问题的 URL 地址进行映射来配置问题导航模式列表。</p><ul><li><p>如果您使用<a href="http://www.atlassian.com/software/jira/overview">JIRA</a>或<a href="http://www.jetbrains.com/youtrack/">YouTrack</a>，请单击工具栏上的“添加 JIRA 模式” <img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.toolbarDecorator.addJira.svg" alt="应用程序工具栏装饰器添加 jira">或“添加 YouTrack 模式” ，然后键入安装错误跟踪系统的 URL。 <img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.toolbarDecorator.addYouTrack.svg" alt="应用程序工具栏装饰器添加您的轨道"></p><p>IntelliJ IDEA 将自动添加定义导航模式的正则表达式。</p></li><li><p>对于其他问题跟踪系统，单击添加按钮<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.add.svg" alt="应用程序常规添加">创建新条目或选择现有条目并单击编辑按钮。在打开的“添加问题导航链接”对话框中，指定以下正则表达式：</p><ul><li>提交消息中<a href="https://intellijidea.com.cn/help/idea/handling-issues.html#example_issue_id_pattern">问题 ID 的</a>模式</li><li>定义用于访问相应引用问题的 URL 的<a href="https://intellijidea.com.cn/help/idea/handling-issues.html#example_issue_link_pattern">替换</a>表达式</li></ul></li></ul></li></ol><p><strong>2、例子</strong>﻿</p><table><thead><tr><th>问题ID</th><th>定义提交消息中问题引用格式的<a href="https://intellijidea.com.cn/help/idea/regular-expressions.html">正则表达式</a>。<code>[A-Z]+\-\d+</code>此正则表达式匹配由 n 破折号字符分隔的两个子字符串组成的所有字符串：子字符串 1：无限数量的大写字母字符。子字符串 2：无限数量的数字字符。</th></tr></thead><tbody><tr><td>问题链接</td><td>问题跟踪系统的 URL 地址和标识其中问题的正则表达式的组合。<code>http://&lt;mytracker&gt;/issue/$0</code>这里<code>$0</code>表示对整个比赛的反向引用。这意味着，一旦 IntelliJ IDEA 检测到提交消息中的匹配项，它就会按原样添加到跟踪器的 URL 地址中。</td></tr><tr><td>匹配问题 ID</td><td>IntelliJ IDEA 在感兴趣的提交消息中检测到以下对问题的引用：<code>MYPROJECT-110</code></td></tr><tr><td>组成的问题链接</td><td>根据上述问题导航模式，检测到的匹配引用按原样添加到跟踪器的 URL 中，因此指向引用问题的链接组成如下：<code>http://mytracker/issue/MYPROJECT-110</code></td></tr></tbody></table><hr><h1 id="管理变更列表"><a href="#管理变更列表" class="headerlink" title="管理变更列表"></a>管理变更列表</h1><p>更改列表是一组尚未提交到 VCS 存储库的本地更改。</p><p>使用变更列表，你可以对与不同任务相关的变更进行分组，并独立提交这些变更集。有关更多信息，请参阅<a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#commit">在本地提交更改</a>。</p><blockquote><p>如果您使用 Git，变更列表只是<a href="https://intellijidea.com.cn/help/idea/work-on-several-features-simultaneously.html#changelists_intro">同时处理多个功能的</a>方法之一。</p></blockquote><p>更改列表显示在<strong>更改</strong>视图中。最初，有一个名为 <strong>Changes</strong> 的默认更改列表。所有新更改都会自动放入 <strong>更改</strong> 更改列表中。还有一个 <strong>未版本控制的文件更改列表</strong>，用于对<strong>尚未</strong>添加到 VCS 中的新创建的文件进行分组。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changelists_in_commit_tw.png" alt="提交工具窗口中的更改列表"></p><p>你可以根据需要创建任意数量的更改列表，并随时使其中任何一个更改列表处于活动状态。你可以将任何未提交的更改移至任何更改列表。</p><p><strong>1、创建新的变更列表</strong>﻿</p><ol><li>在“本地更改”视图中，单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.changelist.svg" alt="更改列表图标">工具栏上的 并选择“新建更改列表”。</li><li>在“新建更改列表”对话框中，指定新更改列表的名称，并添加说明（可选）。</li></ol><p><strong>2、设置活动变更列表</strong>﻿</p><ul><li>在“本地更改”视图中，选择一个非活动更改列表，然后按或右键单击它，然后从上下文菜单中选择“设置活动更改列表” 。所有新的更改都会自动放入此更改列表中。<code>Ctrl</code> <code>Space</code></li></ul><p><strong>3、在更改列表之间移动更改</strong>﻿</p><ol><li>在“本地更改”视图中，选择要移动到另一个更改列表的更改。</li><li>右键单击所选内容或单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.changelist.svg" alt="更改列表图标">工具栏上的 并选择“移动到另一个更改列表” 。<code>Alt</code> <code>Shift</code> <code>M</code></li><li>在打开的对话框中，选择现有变更列表或输入新变更列表的名称。</li><li>您可以选择使目标更改列表处于活动状态并跟踪其上下文（IntelliJ IDEA 将保存与此更改列表关联的上下文，并在该更改列表变为活动状态时恢复它）。</li></ol><blockquote><p>您还可以在更改列表之间拖动文件。</p></blockquote><blockquote><p>有关将一个文件中的更改放入 Git 中的不同更改列表的更多信息，请参阅将<a href="https://intellijidea.com.cn/help/idea/commit-and-push-changes.html#put_changes_into_different_changelists">更改放入不同的更改列表</a>。</p></blockquote><p><strong>4、删除变更列表</strong>﻿</p><ul><li>右键单击更改列表，然后从上下文菜单中选择“删除更改列表” 。</li></ul><hr><h1 id="搁置和取消搁置更改"><a href="#搁置和取消搁置更改" class="headerlink" title="搁置和取消搁置更改"></a>搁置和取消搁置更改</h1><p>取消搁置更改：<code>Ctrl</code> <code>Shift</code> <code>U</code></p><p>搁置是暂时存储您尚未提交的待处理更改。例如，如果您需要切换到另一个任务，并且希望将更改放在一边以供稍后处理，则这非常有用。</p><p>使用 IntelliJ IDEA，您可以搁置单独的文件和整个变更列表。</p><blockquote><p>您无法搁置未版本化的文件，即尚未<a href="https://intellijidea.com.cn/help/idea/adding-files-to-version-control.html#add-files-to-vcs">添加到版本控制的</a>文件。</p></blockquote><p>搁置后，可以根据需要多次应用更改。</p><h2 id="搁置变更"><a href="#搁置变更" class="headerlink" title="搁置变更"></a>搁置变更</h2><ol><li><p>在 “提交”工具窗口中，右键单击要搁置的文件或更改列表，然后从上下文菜单中选择“搁置更改” 。<code>Alt</code> <code>0</code></p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/shelve-changes.png" alt="搁置变化"></p></li><li><p>在“搁置更改”对话框中，查看已修改文件的列表。</p></li><li><p>在“提交消息”字段中，输入要创建的架子的名称，然后单击“架子更改”按钮。</p></li></ol><p>您还可以静默搁置更改，而不显示“搁置更改”对话框。为此，请选择要搁置的文件或更改列表，然后单击工具栏上的“静默搁置”图标或按。包含要搁置的更改的更改列表的名称将用作搁置名称。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.shelveSilent.svg" alt="默默搁置"><code>Ctrl</code> <code>Shift</code> <code>H</code></p><p>为了避免出现多个同名的架子（例如Default），您可以将文件或更改列表从“提交到 <branch>”选项卡拖到“提交”工具窗口的“架子”选项卡，稍等片刻直到它被激活，释放鼠标按钮后编辑新的架子名称。</p><blockquote><p>如果您需要将更改复制到架子而不重置本地更改，请按并查找“保存到架子”操作。<code>Ctrl</code> <code>Shift</code> <code>A</code></p></blockquote><h2 id="取消搁置变更"><a href="#取消搁置变更" class="headerlink" title="取消搁置变更"></a>取消搁置变更</h2><p>取消搁置是将推迟的更改从搁架移动到待处理的更改列表。未搁置的更改可以从视图中过滤掉或从搁置中删除。</p><ol><li><p>在<a href="https://intellijidea.com.cn/help/idea/shelf-tab.html">“搁置”</a>选项卡中，选择更改列表或要取消搁置的文件。</p></li><li><p>按或从所选内容的上下文菜单中选择“取消搁置” 。<code>Ctrl</code> <code>Shift</code> <code>U</code></p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/py_unshelve_changes.png" alt="取消搁置变更"></p></li><li><p>在“取消搁置更改”对话框中，在“名称”字段中指定要将未搁置的更改恢复到的更改列表。您可以从列表中选择现有变更列表或输入要创建的新变更列表的名称。您可以在注释字段中输入新变更列表的描述（可选）。</p><p>如果您想让新的更改列表处于活动状态，请选择“设置活动”。否则，当前活动变更列表保持活动状态。</p></li><li><p>如果您希望 IntelliJ IDEA 在停用时保存与新变更列表关联的任务的上下文，并在变更列表变为活动状态时恢复上下文，请选择“跟踪上下文”选项（有关详细信息，请参阅<a href="https://intellijidea.com.cn/help/idea/managing-tasks-and-context.html">任务和上下文）。</a></p></li><li><p>如果要删除要取消搁置的更改，请选择“从搁置中删除已成功应用的文件”选项。未搁置的文件将从该搁置中删除，添加到另一个更改列表中，并标记为已应用。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.gc.svg" alt="删除图标">只有通过单击工具栏上的 或从上下文菜单中选择清理已取消搁置来明确删除它们，它们才会被完全删除。</p><blockquote><p>如果您意外删除了未搁置的文件，您可以从“最近删除”节点查看和恢复它们。</p></blockquote></li><li><p>单击“确定”。如果修补版本与当前版本发生冲突，请按照<a href="https://intellijidea.com.cn/help/idea/resolving-conflicts.html">解决冲突</a>中的说明进行解决。</p></li></ol><p>您还可以静默取消搁置更改，而不显示“取消搁置更改”对话框。为此，请选择要取消搁置的文件或更改列表，然后单击工具栏上的“静默取消搁置”图标或按。未搁置的文件将移至活动的挂起更改列表。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.unshelveSilent.svg" alt="默默取消搁置图标"><code>Ctrl</code> <code>Alt</code> <code>U</code></p><p>您还可以将文件或更改列表从“搁置”选项卡拖到“提交到 <branch>”选项卡以静默取消搁置。如果按住键拖动它，它将被复制到“提交到分支”选项卡，但也会保留在架子中。<code>Ctrl</code></p><h2 id="放弃搁置的更改"><a href="#放弃搁置的更改" class="headerlink" title="放弃搁置的更改"></a>放弃搁置的更改</h2><ol><li>在“书架”视图中，选择包含您不想再保留的更改的更改列表。</li><li>右键单击更改列表，然后从上下文菜单中选择“删除”或按。<code>Delete</code></li></ol><h2 id="恢复未搁置的更改"><a href="#恢复未搁置的更改" class="headerlink" title="恢复未搁置的更改"></a>恢复未搁置的更改</h2><p>IntelliJ IDEA 允许您在必要时重新应用未搁置的更改。所有未搁置的更改都可以重复使用，直到通过单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.gc.svg" alt="删除未搁置的更改">工具栏上的图标或从上下文菜单中选择“清理已未搁置”来明确删除它们为止。</p><ol><li>确保已启用显示已取消搁置的工具栏选项。 <img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.patch_applied.svg" alt="显示已下架按钮"></li><li>选择要恢复的文件或架子。</li><li>从所选内容的上下文菜单中，选择“恢复”。</li></ol><h2 id="应用外部补丁"><a href="#应用外部补丁" class="headerlink" title="应用外部补丁"></a>应用外部补丁</h2><p>您可以导入在 IntelliJ IDEA 内部或外部创建的补丁，并将它们作为搁置的更改应用。</p><ol><li>在 Shelf 视图中，从上下文菜单中选择Import Patches 。</li><li>在打开的对话框中，选择要应用的补丁文件。选定的补丁将在“Shelf”选项卡中显示为“shelf”。</li><li>选择新添加的带有补丁的架子，然后从所选内容的上下文菜单中选择“取消搁置更改” 。</li></ol><h2 id="自动搁置基础修订"><a href="#自动搁置基础修订" class="headerlink" title="自动搁置基础修订"></a>自动搁置基础修订</h2><p>将 IntelliJ IDEA 配置为始终搁置受 Git 版本控制的文件的基本修订版本可能很有用。</p><ol><li><p>按打开 IDE 设置，然后选择<strong>版本控制 | 架子</strong>。<code>Ctrl</code> <code>Alt</code> <code>S</code></p></li><li><p>选择“在分布式版本控制系统下搁置文件的基本修订版本”选项。</p><p>如果启用此选项，文件的基本修订版本将保存到架子上，如果应用架子导致冲突，则该架子将在<a href="https://en.wikipedia.org/wiki/Merge_(version_control)#Three-way_merge">三向合并</a>期间使用。如果禁用，IntelliJ IDEA 将在项目历史记录中查找基础修订版，这可能需要一段时间；此外，冲突架所基于的修订可能会丢失（例如，如果历史记录因变基操作而更改）。</p></li></ol><h2 id="更改默认架子位置"><a href="#更改默认架子位置" class="headerlink" title="更改默认架子位置"></a>更改默认架子位置</h2><p>默认情况下，shelf 目录位于您的项目目录下。但是，您可能想要更改默认的架子位置。例如，如果您想避免在清理工作副本时意外删除架子，或者希望将它们存储在单独的存储库中，以便在团队成员之间共享架子，这可能很有用。</p><ol><li>按打开 IDE 设置，然后选择<strong>版本控制 | 架子</strong>。<code>Ctrl</code> <code>Alt</code> <code>S</code></li><li>单击更改书架位置并在打开的对话框中指定新位置。</li><li>如有必要，选择将架子移动到新位置以将现有架子移动到新目录。</li></ol><hr><h1 id="使用补丁"><a href="#使用补丁" class="headerlink" title="使用补丁"></a>使用补丁</h1><p>您可以将其放入 <strong>.patch</strong> 文件中，而不是提交本地更改，您可以稍后将其应用到源、通过电子邮件发送等。使用补丁是一种共享更改的便捷机制，无需在 VCS 存储库中检查它们。</p><h2 id="从未提交的更改创建补丁"><a href="#从未提交的更改创建补丁" class="headerlink" title="从未提交的更改创建补丁"></a>从未提交的更改创建补丁</h2><ol><li><p>在“本地更改”视图中，选择要包含在补丁中的文件或更改列表，然后从上下文菜单中选择“从本地更改创建补丁” 。</p><p>您还可以选择提交更改：单击“提交”按钮旁边的箭头，然后选择“创建补丁”。</p></li><li><p>在打开的对话框中，确保选择要包含在补丁中的所有更改，输入提交注释（可选），然后单击“创建补丁”。</p></li><li><p>在“修补程序文件设置”对话框中，根据需要修改默认修补程序文件位置，然后单击“确定”。</p></li></ol><p>如果您不需要将补丁保存到文件中（例如，您想通过电子邮件发送补丁），请在“更改”视图中右键单击必要的文件，然后从上下文菜单中选择“复制为 补丁到剪贴板”。</p><h2 id="从整个提交创建补丁"><a href="#从整个提交创建补丁" class="headerlink" title="从整个提交创建补丁"></a>从整个提交创建补丁</h2><ol><li>在 版本控制工具窗口 的 “日志”选项卡中，找到包含要包含在补丁中的更改的提交，然后从上下文菜单中选择“创建补丁” 。<code>Alt</code> <code>9</code></li><li>在“修补程序文件设置”对话框中，根据需要修改默认修补程序文件位置，然后单击“确定”。</li></ol><h2 id="从文件创建补丁"><a href="#从文件创建补丁" class="headerlink" title="从文件创建补丁"></a>从文件创建补丁</h2><ol><li>在任何视图（项目工具窗口、编辑器、 更改视图等）中选择必要的文件。</li><li>选择Git | 从VCS主菜单或选择的上下文菜单显示历史记录。“历史记录”选项卡已添加到 Git工具窗口，显示所选文件的历史记录，并允许您查看和比较其修订版本。</li><li>右键单击修订版本并从上下文菜单中选择“创建补丁”或单击工具栏上的“创建补丁”图标。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.patch.svg" alt="应用补丁图标"></li></ol><h2 id="应用补丁"><a href="#应用补丁" class="headerlink" title="应用补丁"></a>应用补丁</h2><ol><li><p>选择VCS | 补丁| 从主菜单应用补丁。</p></li><li><p>在打开的“应用补丁”对话框中，指定要应用的.patch文件的路径。</p><blockquote><p>您可以将文件或电子邮件附件拖到编辑器中的任何位置。</p></blockquote></li><li><p>如有必要，单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.folders.svg" alt="文件夹图标">并选择“映射基本目录”以指定相对于补丁文件中的文件名进行解释的目录。您可以将基本目录映射到单个文件、目录或选择。</p></li><li><p>如果在创建补丁后编辑源代码，可能会出现冲突。要检查您的补丁是否可以在不发生冲突的情况下应用，请单击“显示差异” 。如果存在冲突，相应的行将以红色突出显示。<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.diff.svg" alt="显示差异图标"> <code>Ctrl</code> <code>D</code></p></li><li><p>如果您想要将更改应用于存储在补丁中指定位置以外的位置的文件，您可以通过单击 并<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.folders.svg" alt="文件夹图标">选择“删除所有前导目录”来去除前导目录。</p></li><li><p>选择要应用补丁的变更列表，或在“名称”字段中指定新变更列表的名称，然后为此变更列表输入注释（可选）。</p></li><li><p>如果您想让此更改列表处于活动状态，请选择“设置为活动”选项。</p></li><li><p>如果您希望 IntelliJ IDEA 在停用时保存与新变更列表关联的任务的上下文，并在变更列表变为活动状态时恢复上下文，请选择“跟踪上下文”选项（有关详细信息，请参阅<a href="https://intellijidea.com.cn/help/idea/managing-tasks-and-context.html">任务和上下文）。</a></p></li><li><p>如果您想在应用补丁之前将其移动到临时存储（搁架），请单击导入到搁架（有关详细信息，请参阅<a href="https://intellijidea.com.cn/help/idea/shelving-and-unshelving-changes.html">搁置和取消搁置更改</a>）。否则，请单击“确定”。</p></li></ol><p>您还可以通过选择VCS |复制补丁文件的内容并应用它。从主菜单应用剪贴板补丁。例如，当您通过电子邮件收到补丁但不想保存它时，这会很方便。对于<a href="https://git-scm.com/docs/git-format-patch">Git 格式的</a>补丁，IntelliJ IDEA 会提取提交消息和作者，并自动填充 Commit工具窗口中的相应字段。<code>Alt</code> <code>0</code></p><hr><h1 id="审查变更"><a href="#审查变更" class="headerlink" title="审查变更"></a>审查变更</h1><p>本主题说明如何跟踪您和您的团队成员对源代码所做的更改。</p><h2 id="回顾项目历史"><a href="#回顾项目历史" class="headerlink" title="回顾项目历史"></a>回顾项目历史</h2><p>IntelliJ IDEA 允许您查看对与指定过滤器匹配的项目源所做的所有更改。</p><p>对于分布式版本控制系统，例如 Git 和 Mercurial，您可以在 版本控制工具窗口 的日志选项卡 中查看项目历史记录（请参阅<a href="https://intellijidea.com.cn/help/idea/investigate-changes.html">调查 Git 存储库中的更改</a>）。<code>Alt</code> <code>9</code></p><p>对于集中式版本控制系统，例如 Subversion、Perforce 和 ClearCase，项目历史记录可在版本控制工具窗口 的 <a href="https://intellijidea.com.cn/help/idea/version-control-tool-window-repository-and-incoming-tabs.html">存储库选项卡</a>中找到。<code>Alt</code> <code>9</code></p><h2 id="在编辑器中跟踪文件的更改"><a href="#在编辑器中跟踪文件的更改" class="headerlink" title="在编辑器中跟踪文件的更改"></a>在编辑器中跟踪文件的更改</h2><p>当您修改受版本控制的文件时，所有更改都会在编辑器中突出显示，并带有更改标记，这些标记出现在修改行旁边的装订线中，并显示自上次与存储库同步以来引入的更改类型。当您将修改后的文件提交到存储库时，更改标记就会消失。</p><p>您对文本所做的更改是用颜色编码的：</p><ul><li><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/lineAddedMarker.png" alt="新添加行的标记">已添加行。</li><li><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/lineChangededMarker.png" alt="修改行的标记">线路改变了。</li><li><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/lineDeletedMarker.png" alt="已删除行的标记">行已删除。</li></ul><blockquote><p>您可以在编辑器 |上自定义线路状态的默认颜色。配色方案| IDE 设置的 VCS页面。<code>Ctrl</code> <code>Alt</code> <code>S</code></p><p>要禁用装订线中的 VCS 标记，请取消选择“版本控制”| “装订线”中的“突出显示装订线中已修改的行”选项。IDE 设置的 确认页面。<code>Ctrl</code> <code>Alt</code> <code>S</code></p></blockquote><p>您可以使用专用工具栏管理更改。要调用它，请将鼠标悬停在更改标记上，然后单击它。工具栏与一个框架一起显示，该框架显示修改行的先前内容：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changeMarkerToolbar.png" alt="更改标记工具栏"></p><p>工具栏中的操作可让您导航到下一个或上一个更改、回滚更改、查看当前版本与存储库版本之间的差异、将修改行的先前版本复制到剪贴板，或者打开突出显示代码中的差异。</p><p>如果要关闭突出显示更改，请取消选中版本控制 |上的突出显示装订线中修改的行选项。IDE 设置的 确认页面。<code>Ctrl</code> <code>Alt</code> <code>S</code></p><h2 id="将本地更改与存储库版本进行比较"><a href="#将本地更改与存储库版本进行比较" class="headerlink" title="将本地更改与存储库版本进行比较"></a>将本地更改与存储库版本进行比较</h2><p>除了在编辑器中<a href="https://intellijidea.com.cn/help/idea/viewing-changes-information.html#local_changes">浏览</a>文件中的本地更改之外，您还可以将这些更改与文件的基本修订版进行比较。</p><p>要预览差异，请在“提交”工具窗口中选择修改后的文件，然后单击<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.diff.svg" alt="应用程序操作差异">工具栏上的 。</p><p>左侧窗格显示基本修订版中受影响的代码，右侧页面显示您在本地进行更改后受影响的代码。</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/ij_diff_in_editor.jpg" alt="编辑器中的差异预览"></p><p>使用工具栏按钮和控件在更改之间导航并配置更改详细信息窗格或差异查看器的外观：</p><table><thead><tr><th>物品</th><th>工具提示和快捷方式</th><th>描述</th></tr></thead><tbody><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.expui.general.up.svg" alt="上一个差异按钮">&#x2F;<img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.expui.general.down.svg" alt="下一个差异按钮"></td><td>上一个差异&#x2F;下一个差异 <code>Shift</code> <code>F7</code> <code>F7</code></td><td>跳转到下一个或上一个差异。当达到最后一个或第一个差异时，IntelliJ IDEA 建议单击箭头按钮或再次按&#x2F;并比较本地修改的其他文件。此行为取决于<a href="https://intellijidea.com.cn/help/idea/settings-tools-diff-and-merge.html">“差异查看器”设置中的</a><a href="https://intellijidea.com.cn/help/idea/settings-tools-diff-and-merge.html#last_diff">“到达最后一次更改后转到下一个文件”</a>选项。<code>F7</code> <code>Shift</code> <code>F7</code></td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.expui.general.edit.svg" alt="跳转到源按钮"></td><td>跳转至源代码 <code>F4</code></td><td>在编辑器中打开选定的文件。插入符号的位置与差异查看器中的位置相同。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.expui.general.left.svg" alt="比较上一个文件图标"><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.expui.general.right.svg" alt="比较下一个文件图标"></td><td>比较上一个&#x2F;下一个文件<code>Alt</code> <code>←</code>  <code>Alt</code> <code>→</code></td><td>将上一个或下一个文件的本地副本与其来自服务器的更新进行比较。仅当本地修改了多个文件时，这些控件才可用。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.expui.general.listFiles.svg" alt="转到已更改的文件图标"></td><td>转到已更改的文件 <code>Ctrl</code> <code>0N</code></td><td>显示当前更改集中所有已更改的文件并导航到它们。仅当您查看对多个文件的更改时，此操作才可用。</td></tr><tr><td>观众</td><td>选择查看器模式：并排或统一。并排模式有两个面板，统一模式有一个面板。您可以在两个查看器中编辑代码并执行Accept、Append、Revert操作。您只能更改并排查看器的右侧部分或统一查看器的下一行中的文本。您只能编辑文件的本地版本。您无法编辑具有只读状态的文件。</td><td></td></tr><tr><td>空白</td><td>定义差异查看器应如何处理空格。不要忽视：空白很重要，并且所有差异都会突出显示。默认情况下选择此选项。修剪空白：修剪出现在行尾和行首的空白 ( <code>(&quot;\t&quot;, &quot; &quot;)</code>)。如果两行仅尾随空格不同，则这些行被视为相等。如果两行不同，则在<a href="https://intellijidea.com.cn/help/idea/viewing-changes-information.html#highlight">按字</a>模式下不会突出显示尾随空格。忽略空格：空格并不重要，无论它们在源代码中的位置如何。忽略空格和空行：忽略空格和空行。以下实体将被忽略：所有空格（如“忽略空格”选项中所示）所有添加或删除的行仅由空格组成所有由分割或连接行组成的更改，而不更改非空白部分。例如，在此模式下不会突出显示<code>a b c</code>和之间的差异。<code>a \n b c</code>忽略导入和格式设置：导入语句中的更改和空格将被忽略（但会考虑字符串文字中的空格）。</td><td></td></tr><tr><td>突出显示模式</td><td>选择突出显示差异粒度的方式。可用的选项有：高亮单词：修改后的单词高亮显示高亮行：修改的行高亮显示突出显示拆分更改：如果选择此选项，则大更改将拆分为较小的更改。例如，<code>A \n B</code>和<code>A X \n B X</code>被视为两项更改而不是一项。高亮字符：修改后的符号高亮显示不突出显示：如果选择此选项，则根本不突出显示差异。当您处理经过重大修改的文件时，请使用“不突出显示”选项。在这种情况下，突出显示可能会在审核过程中带来额外的困难。</td><td></td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.expui.general.collapseAll.svg" alt="折叠未更改的片段图标"></td><td>折叠未更改的片段</td><td>折叠两个文件中所有未更改的片段。不可折叠的未更改行的数量可在“差异和合并”设置页面上进行配置。要打开“差异和合并”页面，请按打开设置，然后导航到“工具”|“ 差异与合并。CtrlAlt0S</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.expui.actions.synchronizeScrolling.svg" alt="同步按钮"></td><td>同步滚动</td><td>单击此按钮可同时滚动两个差异窗格。如果释放此按钮，每个窗格都可以独立滚动。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app-client.expui.general.settings.svg" alt="设置按钮"></td><td>设置</td><td>打开可用设置的列表。也可以从差异查看器装订线的上下文菜单中使用这些命令。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.general.externalTools.svg" alt="外部工具图标"></td><td>在外部工具中显示差异</td><td>调用外部差异<a href="https://intellijidea.com.cn/help/idea/settings-tools-external-diff-tools.html">工具</a>设置页面上指定的外部差异查看器。仅当在外部比较工具设置页面上启用使用外部<a href="https://intellijidea.com.cn/help/idea/settings-tools-external-diff-tools.html">比较</a>工具选项时，此按钮才在工具栏上可用。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.help.svg" alt="帮助图标"></td><td>帮助 <code>F1</code></td><td>打开浏览器并显示相应的帮助页面。</td></tr><tr><td></td><td>使用 GitBlame 进行注释</td><td>此选项只能从装订线的上下文菜单中使用。使用此选项可以探索谁对文件的存储库版本进行了哪些更改以及何时进行。通过注释视图，您可以查看每行代码的详细信息，例如该行源自的版本、提交该行的用户的 ID 以及提交日期。有关注释的更多信息，请参阅<a href="https://intellijidea.com.cn/help/idea/viewing-changes-information.html#annotations">VCS 注释</a>。</td></tr></tbody></table><p>最有用的快捷键如下：</p><table><thead><tr><th>捷径</th><th>描述</th></tr></thead><tbody><tr><td><code>Ctrl</code> <code>Shift</code> <code>D</code></td><td>使用此键盘快捷键可显示最常用的 diff 命令的弹出菜单。</td></tr><tr><td><code>Ctrl</code> <code>Shift</code> <code>Tab</code></td><td>使用此键盘快捷键可在左窗格和右窗格之间切换。</td></tr><tr><td><code>Ctrl</code> <code>Z</code> &#x2F; <code>Ctrl</code> <code>Shift</code> <code>Z</code></td><td>使用此键盘快捷键可撤消&#x2F;重做合并操作。冲突将与文本保持同步。</td></tr></tbody></table><h2 id="查看文件或选择的更改历史记录"><a href="#查看文件或选择的更改历史记录" class="headerlink" title="查看文件或选择的更改历史记录"></a>查看文件或选择的更改历史记录</h2><p>IntelliJ IDEA 允许您查看对文件甚至源代码片段所做的更改。“显示历史记录”和“显示选择历史记录”命令可从VCS主菜单和文件的上下文菜单中使用。</p><p>文件的更改历史记录显示在版本控制工具窗口 的 专用<a href="https://intellijidea.com.cn/help/idea/version-control-tool-window-history-tab.html">历史记录选项卡</a>中。<code>Alt</code> <code>9</code></p><p><a href="https://intellijidea.com.cn/help/idea/differences-viewer.html">所选代码的更改历史记录以差异查看器</a>的形式显示在单独的窗口中。</p><p><strong>1、查看文件历史记录</strong>﻿</p><ul><li>在编辑器中打开文件或在项目工具窗口中选择它并选择<VCS> | 从上下文菜单中显示历史记录。</li></ul><p>所选文件的 <a href="https://intellijidea.com.cn/help/idea/version-control-tool-window-history-tab.html">“历史记录”</a>选项卡出现在版本控制工具窗口 中，文件名显示在选项卡的标题栏上。<code>Alt</code> <code>9</code></p><p>您可以使用<a href="https://intellijidea.com.cn/help/idea/version-control-tool-window-history-tab.html">工具栏</a>按钮将所选版本与本地版本进行比较、比较所选版本中的类、从 VCS 中检出所选版本、注释所选版本等：</p><table><thead><tr><th>物品</th><th>工具提示和快捷方式</th><th>描述</th></tr></thead><tbody><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.refresh.svg" alt="刷新按钮"></td><td>刷新</td><td>单击此按钮可刷新当前信息。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.diff.svg" alt="显示差异图标"></td><td>显示差异 <code>Ctrl</code> <code>D</code></td><td>单击此按钮可将文件的选定版本与<a href="https://intellijidea.com.cn/help/idea/differences-viewer.html">差异查看器</a>中的先前版本进行比较。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.listChanges.svg" alt="显示所有受影响的文件按钮"></td><td>显示所有受影响的文件<code>Alt</code> <code>Shift</code> <code>A</code></td><td>单击此按钮可打开“修订版中受影响的路径”对话框，您可以在其中查看在选定修订版中修改的所有文件。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.branch.svg" alt="显示所有分支按钮"></td><td>显示所有分行</td><td>单击此按钮可显示当前分支以外的分支的更改。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.actions.show.svg" alt="眼睛图标"></td><td>演示设置</td><td>单击以选择您想要在“历史记录”视图中查看的信息量。如果您希望 IntelliJ IDEA 显示提交时间戳而不是创作更改的时间，您还可以选择“显示提交时间戳”选项。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.debugger.restoreLayout.svg" alt="配置布局图标"></td><td>配置布局</td><td>单击以选择您要查看的信息类型：显示详细信息以显示所选修订的提交消息。显示差异预览以打开所选版本的差异预览。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/app.vcs.vendors.github.svg" alt="在 GitHub 上打开按钮"></td><td>在 GitHub 中打开</td><td><a href="https://github.com/">单击此按钮可打开与GitHub</a>上所选提交对应的页面。</td></tr></tbody></table><p><strong>2、查看选择的历史记录</strong>﻿</p><ol><li>在编辑器中，选择必要的源代码片段或将插入符号放在相应的行上。</li><li>选择<VCS> | 从主VCS菜单或选择的上下文菜单显示选择的历史记录。</li></ol><p>所选片段的历史记录将在单独的窗口中打开。如果未选择任何内容，将显示当前行的历史记录。</p><h2 id="检查文件状态"><a href="#检查文件状态" class="headerlink" title="检查文件状态"></a>检查文件状态</h2><p>IntelliJ IDEA 允许您检查项目文件相对于存储库的状态。文件状态显示自上次与存储库同步以来已对文件执行了哪些操作。</p><p>您可以通过用于突出显示文件名的颜色在任何界面元素（例如编辑器或工具窗口）中检查文件的状态。</p><p><a href="https://intellijidea.com.cn/help/idea/settings-colors-and-fonts.html">您可以在“颜色和字体”</a>设置页面中自定义文件状态的默认颜色。</p><p>您可以在版本控制 |配置 VCS 文件状态颜色 IDE 设置的 文件状态颜色页面。<code>Ctrl</code> <code>Alt</code> <code>S</code></p><blockquote><p>要同时突出显示包含已修改内容的文件夹和包，请在版本控制 |项目树中选择突出显示包含已修改文件的目录。IDE 设置的 确认页面。CtrlAlt0S</p></blockquote><p>下表列出了默认文件状态颜色及其在某些<a href="https://intellijidea.com.cn/help/idea/configuring-colors-and-fonts.html">配色方案</a>中的含义。</p><p><strong>浅色主题</strong></p><table><thead><tr><th>颜色</th><th>文件状态</th><th>描述</th></tr></thead><tbody><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/added-light.png" alt="颜色样本： 深绿色"> #0A7700</td><td>添加</td><td><a href="https://intellijidea.com.cn/help/idea/managing-changelists.html">活动变更列表</a>中的文件计划添加到存储库中。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/added-inactive-changelist-light.png" alt="颜色样本： 绿色"> #0EAA00</td><td>添加到非活动变更列表中</td><td>非活动更改列表中的文件计划添加到存储库中。如果在“设置”| “突出显示非活动更改列表中的文件”选项已启用，则此文件状态可用。版本控制 | 变更列表。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflicts-light.png" alt="颜色样本： 红色"> #FF0000</td><td>变更列表冲突</td><td>非活动变更列表中的文件已在活动变更列表中被修改。在这种情况下，将打开一个新对话框，提示您解决<a href="https://intellijidea.com.cn/help/idea/resolving-conflicts.html">更改列表冲突</a>。如果在“设置”|“设置”中启用了所有选项，则此文件状态可用。版本控制 | 变更列表。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/added-light.png" alt="颜色样本： 深绿色"> #0A7700</td><td>已复制</td><td>如果一个文件是另一个文件的副本，则会跟踪其元数据，并将此类文件标记为已复制。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/deleted-light.png" alt="颜色样本：灰色"> #616161</td><td>已删除</td><td>该文件计划从存储库中删除。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/deleted-from-filesystem-light.png" alt="颜色样本：暗紫色"> #773895</td><td>从文件系统中删除</td><td>该文件已在本地删除，但尚未计划删除，并且仍然存在于存储库中。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changed-descendants-light.png" alt="颜色样本：浅灰蓝色"> #8AA4C8</td><td>改变了后代</td><td>如果文件被修改，IDE 将递归突出显示包含该文件的所有目录。如果在“设置”| “项目树”中启用“突出显示项目树中包含已修改文件的目录”选项，则此状态可用。版本控制 | 确认。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changed-children-light.png" alt="颜色样本：亮蓝色"> #3264B4</td><td>立即改变孩子</td><td>如果文件被修改，IDE 将突出显示其父目录。如果在“设置”| “项目树”中启用“突出显示项目树中包含已修改文件的目录”选项，则此状态可用。版本控制 | 确认。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/hijacked-light.png" alt="颜色样本： 浅棕色"> #B28C00</td><td>被劫持</td><td>[Perforce、ClearCase、VSS] 文件被<a href="https://intellijidea.com.cn/help/idea/handling-modified-without-checkout-files.html">修改但未签出。</a></td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/ignored-light.png" alt="色样：深橄榄色"> #727238</td><td>被忽略</td><td>VCS 故意取消跟踪文件。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/merged-light.png" alt="颜色样本：紫色"> 第7503章 DC</td><td>合并</td><td>作为更新的结果，该文件由您的 VCS 合并。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflicts-light.png" alt="颜色样本： 红色"> #FF0000</td><td>与冲突合并</td><td>在上次更新期间，该文件已合并并存在冲突。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflicts-light.png" alt="颜色样本： 红色"> #FF0000</td><td>合并财产冲突</td><td>在上次更新期间，IDE 检测到本地文件的属性与其服务器版本之间存在差异。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflicts-light.png" alt="颜色样本： 红色"> #FF0000</td><td>合并文本和属性冲突</td><td>当两个或多个开发人员修改文件的相同行和相同的文件属性时，就会发生文本和属性冲突。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/modified-light.png" alt="颜色样本: 亮海军蓝"> #0032A0</td><td>修改的</td><td>自上次同步以来该文件已更改。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/modified-inactive-changelist-light.png" alt="颜色样本：蓝色"> #0047E4</td><td>在非活动变更列表中修改</td><td>非活动更改列表中的文件已被修改。如果在“设置”| “突出显示非活动更改列表中的文件”选项已启用，则此文件状态可用。版本控制 | 变更列表。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/obsolete-light.png" alt="色样: 橄榄色"> #7C7C00</td><td>过时的</td><td>该文件不应再位于存储库的工作副本中。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/renamed-light.png" alt="颜色样本： 青色"> #007C7C</td><td>更名</td><td>自上次更新以来，该文件已被重命名。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/switched-light.png" alt="颜色样本：深青色"> #08978F</td><td>已切换</td><td>[SVN] 该文件取自与整个项目不同的分支。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/unversioned-light.png" alt="颜色样本： 棕色"> #993300</td><td>（未知）未版本化</td><td>该文件存在于本地，但不在存储库中，并且未计划添加。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/up-to-date-light.png" alt="颜色样本： 黑色">无（默认颜色）</td><td>最新</td><td>该文件尚未更改。</td></tr></tbody></table><p><strong>达库拉主题</strong></p><table><thead><tr><th>颜色</th><th>文件状态</th><th>描述</th></tr></thead><tbody><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/added-darcula.png" alt="Color sample: dull green"> #629755</td><td>添加</td><td><a href="https://intellijidea.com.cn/help/idea/managing-changelists.html">活动变更列表</a>中的文件计划添加到存储库中。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/added-darcula.png" alt="Color sample: dull green"> #629755</td><td>添加到非活动变更列表中</td><td>非活动更改列表中的文件计划添加到存储库中。如果在“设置”| “突出显示非活动更改列表中的文件”选项已启用，则此文件状态可用。版本控制 | 变更列表。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflicts-darcula.png" alt="Color sample: dull red"> #D5756C</td><td>变更列表冲突</td><td>非活动变更列表中的文件已在活动变更列表中被修改。在这种情况下，将打开一个新对话框，提示您解决<a href="https://intellijidea.com.cn/help/idea/resolving-conflicts.html">更改列表冲突</a>。如果在“设置”|“设置”中启用了所有选项，则此文件状态可用。版本控制 | 变更列表。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/copied-darcula.png" alt="Color sample: green"> #0A7700</td><td>已复制</td><td>如果一个文件是另一个文件的副本，则会跟踪其元数据，并将此类文件标记为已复制。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/deleted-darcula.png" alt="Color sample: grey"> #6C6C6C</td><td>已删除</td><td>该文件计划从存储库中删除。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/deleted-darcula.png" alt="Color sample: dull purple"> #6C6C6C</td><td>从文件系统中删除</td><td>该文件已在本地删除，但尚未计划删除，并且仍然存在于存储库中。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changed-descendants-darcula.png" alt="Color sample: light blue"> #6897BB</td><td>改变了后代</td><td>如果文件被修改，IDE 将递归突出显示包含该文件的所有目录。如果在“设置”| “项目树”中启用“突出显示项目树中包含已修改文件的目录”选项，则此状态可用。版本控制 | 确认。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changed-descendants-darcula.png" alt="Color sample: light blue"> #6897BB</td><td>立即改变孩子</td><td>如果文件被修改，IDE 将突出显示其父目录。如果在“设置”| “项目树”中启用“突出显示项目树中包含已修改文件的目录”选项，则此状态可用。版本控制 | 确认。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/hijacked-darcula.png" alt="Color sample: white">无（默认颜色）</td><td>被劫持</td><td>[Perforce、ClearCase、VSS] 文件被<a href="https://intellijidea.com.cn/help/idea/handling-modified-without-checkout-files.html">修改但未签出。</a></td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/ignored-darcula.png" alt="Color sample: light olive"> #848504</td><td>被忽略</td><td>VCS 故意取消跟踪文件。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/merged-darcula.png" alt="Color sample: light purple"> #9876AA</td><td>合并</td><td>作为更新的结果，该文件由您的 VCS 合并。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflicts-darcula.png" alt="Color sample: dull red"> #D5756C</td><td>与冲突合并</td><td>在上次更新期间，该文件已合并并存在冲突。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflicts-darcula.png" alt="Color sample: dull red"> #D5756C</td><td>合并财产冲突</td><td>在上次更新期间，IDE 检测到本地文件的属性与其服务器版本之间存在差异。</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflicts-darcula.png" alt="Color sample: dull red"> #D5756C</td><td>合并文本和属性冲突</td><td>Text and property conflicts happen when two or more developers modify the same lines of a file and the same file properties.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changed-descendants-darcula.png" alt="Color sample: light blue"> #6897BB</td><td>Modified</td><td>The file has changed since the last synchronization.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changed-descendants-darcula.png" alt="Color sample: light blue"> #6897BB</td><td>Modified in not active changelist</td><td>The file in an inactive changelist has been modified. This file status is available if the Highlight files from non-active changelists option is enabled in Settings | Version Control | Changelists.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/hijacked-darcula.png" alt="Color sample: white"> None (default color)</td><td>Obsolete</td><td>The file should no longer be in your working copy of the repository.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/renamed-darcula.png" alt="Color sample: strong cyan"> #3A8484</td><td>Renamed</td><td>Since the last update, the file has been renamed.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/hijacked-darcula.png" alt="Color sample: white"> None (default color)</td><td>Switched</td><td>[SVN] The file is taken from a different branch than the whole project.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/unversioned-darcula.png" alt="Color sample: soft red"> #D1675A</td><td>(Unknown) Unversioned</td><td>The file exists locally but is not in the repository and is not scheduled for addition.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/hijacked-darcula.png" alt="Color sample: white"> None (default color)</td><td>Up to date</td><td>The file hasn’t been changed.</td></tr></tbody></table><p><strong>高对比度主题</strong></p><table><thead><tr><th>Color</th><th>File Status</th><th>Description</th></tr></thead><tbody><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/added-hcontrast.png" alt="Color sample: green"> #62CC47</td><td>Added</td><td>The file in the active <a href="https://intellijidea.com.cn/help/idea/managing-changelists.html">changelist</a> is scheduled for addition to the repository.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/added-hcontrast.png" alt="Color sample: green"> #62CC47</td><td>Added in not active changelist</td><td>The file in an inactive changelist is scheduled for addition to the repository. This file status is available if the Highlight files from non-active changelists option is enabled in Settings | Version Control | Changelists.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflicts-hcontrast.png" alt="Color sample: dull red"> #FF6666</td><td>Changelist conflict</td><td>The file in an inactive changelist has been modified in the active changelist. In this case, a new dialog will open, prompting you to resolve the <a href="https://intellijidea.com.cn/help/idea/resolving-conflicts.html">changelist conflict</a>. This file status is available if all options are enabled in Settings | Version Control | Changelists.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/added-hcontrast.png" alt="Color sample: green"> #62CC47</td><td>Copied</td><td>If a file is a copy of another file, its metadata is tracked, and such a file is marked as copied.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/deleted-hcontrast.png" alt="Color sample: orange"> #ED864A</td><td>Deleted</td><td>The file is scheduled for deletion from the repository.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/deleted-hcontrast.png" alt="Color sample: orange"> #ED864A</td><td>Deleted from file system</td><td>The file has been deleted locally but hasn’t been scheduled for deletion, and it still exists in the repository.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changed-descendants-hcontrast.png" alt="Color sample: vivid cyan"> #4FF0FF</td><td>Have changed descendants</td><td>If a file is modified, the IDE will recursively highlight all directories containing that file. This status is available if the Highlight directories that contain modified files in the Project tree option is enabled in Settings | Version Control | Confirmation.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changed-descendants-hcontrast.png" alt="Color sample: vivid cyan"> #4FF0FF</td><td>Have immediate changed children</td><td>If a file is modified, the IDE will highlight its parent directory. This status is available if the Highlight directories that contain modified files in the Project tree option is enabled in Settings | Version Control | Confirmation.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/hijacked-darcula.png" alt="Color sample: white"> None (default color)</td><td>Hijacked</td><td>[Perforce, ClearCase, VSS] The file is <a href="https://intellijidea.com.cn/help/idea/handling-modified-without-checkout-files.html">modified without checkout.</a></td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/ignored-hcontrast.png" alt="Color sample: light olive"> #A9B837</td><td>Ignored</td><td>A file is intentionally untracked by VCS.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/merged-hcontrast.png" alt="Color sample: light purple"> #ED94FF</td><td>Merged</td><td>The file is merged by your VCS as a result of an update.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflicts-hcontrast.png" alt="Color sample: dull red"> #FF6666</td><td>Merged with conflicts</td><td>During the last update, the file has been merged with conflicts.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflicts-hcontrast.png" alt="Color sample: dull red"> #FF6666</td><td>Merged with property conflicts</td><td>During the last update, the IDE has detected differences between the properties of the local file and its server version.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/conflicts-hcontrast.png" alt="Color sample: dull red"> #FF6666</td><td>Merged with text and property conflicts</td><td>Text and property conflicts happen when two or more developers modify the same lines of a file and the same file properties.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changed-descendants-hcontrast.png" alt="Color sample: vivid cyan"> #4FF0FF</td><td>Modified</td><td>The file has changed since the last synchronization.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changed-descendants-hcontrast.png" alt="Color sample: vivid cyan"> #4FF0FF</td><td>Modified in not active changelist</td><td>The file in an inactive changelist has been modified. This file status is available if the Highlight files from non-active changelists option is enabled in Settings | Version Control | Changelists.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/hijacked-darcula.png" alt="Color sample: white"> None (default color)</td><td>Obsolete</td><td>The file should no longer be in your working copy of the repository.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/changed-descendants-hcontrast.png" alt="Color sample: vivid cyan"> #4FF0FF</td><td>Renamed</td><td>Since the last update, the file has been renamed.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/hijacked-darcula.png" alt="Color sample: white"> None (default color)</td><td>Switched</td><td>[SVN] The file is taken from a different branch than the whole project.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/unversioned-darcula.png" alt="Color sample: soft red"> D1675A</td><td>(Unknown) Unversioned</td><td>The file exists locally but is not in the repository and is not scheduled for addition.</td></tr><tr><td><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/hijacked-darcula.png" alt="Color sample: white"> None (default color)</td><td>Up to date</td><td>The file hasn’t been changed.</td></tr></tbody></table><blockquote><p>本章介绍 VCS 文件状态颜色。如果您需要设置颜色来区分特定范围的项目文件，请参考<a href="https://intellijidea.com.cn/help/idea/settings-file-colors.html">此页面</a>。</p></blockquote><h2 id="版本控制系统注释"><a href="#版本控制系统注释" class="headerlink" title="版本控制系统注释"></a>版本控制系统注释</h2><p><strong>1、什么是 VCS 注释？</strong>﻿</p><p>注释是一种文件表示形式，显示每行代码的详细信息。特别是，对于每一行，您可以查看该行的起源版本、提交该行的人员的用户 ID 以及提交日期。带注释的视图可帮助您找出谁在何时做了什么，并追溯更改。</p><p>注释代码行可用于 ClearCase、Mercurial、Git、Perforce 和 Subversion。</p><p>“注释”命令可从版本控制菜单的 VCS 特定节点、编辑器装订线的上下文菜单、文件上下文菜单和文件<a href="https://intellijidea.com.cn/help/idea/viewing-changes-information.html#changes_history">历史记录</a>视图中使用。</p><p>启用注释后，装订线看起来类似于以下示例：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/annotate.png" alt="注释"></p><p>当前版本中修改的行的注释用粗体和星号标记。</p><p><strong>2、启用注释</strong>﻿</p><ul><li><p>右键单击编辑器或<a href="https://intellijidea.com.cn/help/idea/differences-viewer.html">差异查看器</a>中的装订线，然后从上下文菜单中选择使用 Git Blame 进行注释。</p><p>您可以为“注释”命令分配自定义快捷方式：转到IDE 设置的 “键盘映射”页面，然后查找“版本控制系统”|“版本控制系统”。git | git 注释。<code>Ctrl</code> <code>Alt</code> <code>S</code></p><p>要关闭注释，请右键单击编辑器或<a href="https://intellijidea.com.cn/help/idea/differences-viewer.html">差异查看器</a>中的装订线，然后从上下文菜单中选择“关闭注释” 。</p></li></ul><p><strong>3、配置注释中显示的信息量</strong>﻿</p><p>您可以选择要在注释视图中查看的信息量。</p><ul><li><p>右键单击注释装订线，选择“查看”并选择要查看的信息类型，包括此更改源自的修订版、日期、不同格式的作者姓名以及提交号。</p><p>您还可以在“颜色”下设置突出显示。</p></li></ul><p><strong>4、配置注释选项</strong>﻿</p><ul><li>右键单击注释装订线并从上下文菜单中选择选项：<ul><li>忽略空格：空格将被忽略（git <code>blame -w</code>）。这意味着注释将指向先前有意义的提交。</li><li>检测文件内的移动：当提交在同一文件中移动或复制行时，此类更改将被忽略（git <code>blame -M</code>）。这意味着注释将指向先前有意义的提交。</li><li>检测跨文件的移动：当提交移动或复制在同一提交中修改的其他文件中的行时，此类更改将被忽略（git <code>blame -C</code>）。这意味着注释将指向先前有意义的提交。</li><li>显示提交时间戳：如果您希望 IntelliJ IDEA 在注释视图中显示提交时间戳而不是创作更改的时间，请选择此选项。</li></ul></li></ul><p><strong>5、自定义日期格式</strong>﻿</p><ol><li>按打开 IDE 设置，然后选择外观和行为 | 系统设置| 日期格式。<code>Ctrl</code> <code>Alt</code> <code>S</code></li><li>单击“VCS 注释”旁边的“日期时间模式”字段，并指定要用于 VCS 注释的日期格式。请参阅<a href="https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html">模式参考</a>。</li></ol><p><strong>6、注释以前的修订</strong>﻿</p><p>IntelliJ IDEA 不仅允许您注释当前文件修订版本，还可以注释其先前的修订版本。注释装订线的上下文菜单提供以下选项：</p><ul><li>注释修订：如果您想检查提交特定更改后文件的外观，此选项非常有用。为此，请右键单击此更改并从上下文菜单中选择注释修订。</li><li>注释以前的修订：如果您发现自己处于特定行中的最后更改毫无意义的情况（例如，如果所有更改都是代码格式），则此选项很有用。在这种情况下，您可以检查该文件的先前版本是什么样子。为此，请右键单击更改并从上下文菜单中选择“注释先前修订版” 。</li></ul><p><a href="https://intellijidea.com.cn/help/idea/viewing-changes-information.html#changes_history">您还可以从文件历史</a>记录视图中注释特定文件。在“历史记录”选项卡中，选择要查看的文件版本，右键单击相应行并从上下文菜单中选择“注释” 。</p><p><strong>7、查看修订版本之间的差异</strong>﻿</p><p>要查看文件的带注释版本与其先前版本之间的差异，请将脱字符号放在注释处，右键单击它，然后选择“显示差异”。IntelliJ IDEA 打开<a href="https://intellijidea.com.cn/help/idea/differences-viewer.html">文件的差异查看器</a>：</p><p><img src="/img/load.gif" data-original="https://intellijidea.com.cn/help/img/idea/2023.2/annotations_show_diff.png" alt="IntelliJ IDEA：差异查看器"></p><p>您还可以调用 VCS Operations 弹出窗口并选择Annotated Line | 显示差异。<code>Alt</code></p><p><strong>8、导航至日志</strong>﻿</p><p>如果您使用Git进行版本控制，还可以在 版本控制工具窗口 的 Log选项卡中从注释视图跳转到相应的提交。<code>Alt</code> <code>9</code></p><p>为此，请将插入符号放在注释处，右键单击它，然后从上下文菜单中选择“在 Git 日志中选择” 。您还可以使用复制修订版本号命令在日志中查找修订版本。</p><p><a href="https://github.com/">对于https://github.com/</a>上托管的项目，还可以使用“在 GitHub 上打开”命令，将您带到相应的提交。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos 安装与使用</title>
      <link href="/posts/95afb97c.html"/>
      <url>/posts/95afb97c.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/load.gif" data-original="https://pic2.zhimg.com/v2-71daae9a4aef25ce7a01606571b2365a_r.jpg" alt=" https://pic2.zhimg.com/v2-71daae9a4aef25ce7a01606571b2365a_r.jpg"></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><p>微服务与传统单体式应用架构最大区别就是强调软件模块的拆分。在单体架构下，一个应用系统的多个功能模块由于组织在一起在同一个应用进程内部署与运行，因此，模块之间直接通过方法调用即可完成对一次请求得响应。但在微服务系统中需要对一个应用系统根据其功能特点，按照一定粒度进行拆分后单独部署，以便实现模块内的高内聚，模块间的低耦合，实现整个微服务系统的高可扩展性。原来一次在一个应用内即可完成的请求处理，会出现跨进程跨主机的微服务调用，如何让这个服务之间能够互相发现像单体式应用一样提供统一对外的服务调用能力式微服务框架层面需要重点解决的核心问题之一。</p><p>在 Spring Cloud 生态中，采用了如下服务注册与发现模型，来实现微服务之间的相互发现与调用。</p><p><img src="/img/load.gif" data-original="https://sca.aliyun.com/img/user/quickstart/nacos/service-discovery.png" alt="服务注册与发现模型"></p><p>如上图所示，通过在微服务系统中引入一个叫做注册中心的组件，来作为协调者。其最简化的过程是，所有的微服务应用在启动过程中会将自身包含服务名称、主机 IP 地址和端口号等信息发送到注册中心中，然后上游的微服务在处理请求过程中，根据服务名称到注册中心查找对应服务的所有实例 IP 地址和端口号来进行服务调用，整个过程中如图中虚线所示。从而让分散的微服务系统之间能够像一个整体一样对外提供请求处理能力。</p><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>在正式介绍分布式配置内容之前，还是先简单介绍一下配置的概念。</p><p>软件系统中的配置是指在软件运行过程中所需要的各种设定和参数，包括系统配置、应用配置和用户配置等。</p><ul><li>系统配置包括操作系统、硬件和网络等基本环境参数的设定</li><li>应用配置包括应用程序的各种参数和选项的设定，如数据库连接字符串、日志级别等</li><li>用户配置则是指用户自定义的各种选项和参数，如快捷键、界面布局、语言等</li></ul><p>配置在软件系统中是对软件源代码的一种重要补充，通过其可以便捷的调整软件系统的执行行为，让软件系统更加灵活。</p><p>除了单体应用，在分布式系统中，配置信息应用非常广泛，可以通过配置来实现不同的功能。这些配置信息如数据库连接信息、日志级别、业务配置等等。</p><p>在传统的开发中，这些配置西南西通常硬编码到应用程序的代码中，与程序代码一起打包和部署。然而，这种方式有很多缺点，比如配置不易维护，只要修改配置就得重新构建和部署等。</p><p><img src="/img/load.gif" data-original="https://sca.aliyun.com/img/user/quickstart/nacos/spring-cloud-config.png" alt="service-config"></p><p>采用分布式配置中心的软件架构如上图所示，其可以在分布式场景中帮助解决以下问题：</p><ol><li>管理应用程序配置：当有大量应用程序需要管理时，手动维护配置文件会变得非常困难。分布式配置中心提供了一个集中管理和分发配置信息的解决方案。</li><li>环境隔离：在开发、测试和生产等不同环境中，应用程序的配置信息往往都会有不同。使用分布式配置中心，可以轻松管理和分发不同环境下的配置信息。</li><li>提高程序安全性：将配置信息存储在代码库或应用程序文件中可能会导致安全风险，因为这些信息可能会被意外地泄露或被恶意攻击者利用。使用分布式配置，可以将配置信息加密和保护，并且可以进行访问权限控制。</li><li>动态更新配置：在应用程序运行时，可能需要动态地更新配置信息，以便应用程序可以及时响应变化。使用分布式配置中心，可以在运行时动态更新配置信息，而无需重新启动应用程序。</li></ol><h2 id="Nacos-概述"><a href="#Nacos-概述" class="headerlink" title="Nacos 概述"></a>Nacos 概述</h2><p><a href="https://nacos.io/zh-cn/">Nacos</a> &#x2F;nɑ:k əʊs&#x2F; 是 Dynamic Naming and Configuration Service 的首字母简称，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p><p>Nacos 致力于帮助发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助你快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>Nacos 可以更敏捷和更容易地构建、交付和管理微服务平台。Nacos 是构建以 <strong>服务</strong> 为中心的现代应用架构（例如微服务范式、云原生范式）的服务基础设施。</p><hr><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>使用 <code>spring-cloud-starter-alibaba-nacos-config</code> 和 <code>spring-cloud-starter-alibaba-nacos-discovery</code> 完成 Spring Cloud 应用的配置管理和服务发现。</p><h2 id="安装-Nacos-Server"><a href="#安装-Nacos-Server" class="headerlink" title="安装 Nacos Server"></a>安装 Nacos Server</h2><h3 id="接入云上免费版本"><a href="#接入云上免费版本" class="headerlink" title="接入云上免费版本"></a>接入云上免费版本</h3><p>体验 Spring Cloud Alibaba 注册配置中心的最简单方式就是接入阿里云上的托管 Nacos Server ，这样可以免去本地安装下载的繁琐步骤。具体参考 <a href="https://free.aliyun.com/?searchKey=nacos&spm=sca-quickstart-free.topbar.0.0.0">如何体验和接入阿里云托管免费 Nacos Server</a>。</p><blockquote><p>如果是用的云上托管版本 Nacos Server ，在接下来的文档使用 云上 <code>Nacos Server</code> 地址 替换 <code>127.0.0.1:8848</code> 即可。</p></blockquote><h3 id="本地安装方式"><a href="#本地安装方式" class="headerlink" title="本地安装方式"></a>本地安装方式</h3><p>具体启动方式参考 <a href="https://nacos.io/zh-cn/docs/quick-start.html">Nacos</a> 官网。</p><p>Nacos Server 启动成功之后，浏览器地址栏输入 <code>http://ip:8848/nacos</code> 查看 Nacos 控制台（默认账号名称和密码为 nacos&#x2F;nacos）：</p><p><img src="/img/load.gif" data-original="https://sca.aliyun.com/img/user/quickstart/nacos/nacos-config-dashboard.png" alt="nacos-server-start"></p><p>关于更多的 Nacos Server 版本，可以从 Nacos 官方 <a href="https://github.com/alibaba/nacos/releases">release</a> 页面查看。</p><h2 id="接入-Nacos-配置中心"><a href="#接入-Nacos-配置中心" class="headerlink" title="接入 Nacos 配置中心"></a>接入 Nacos 配置中心</h2><h3 id="接入-Nacos-Config"><a href="#接入-Nacos-Config" class="headerlink" title="接入 Nacos Config"></a>接入 Nacos Config</h3><p>如果在你的项目中使用 Nacos 来实现配置管理，需要进行以下操作（确保 Nacos Server 已启动）：</p><ol><li><p>需要在 pom.xml 文件中引入 group ID 为 com.alibaba.cloud 和 atrfact ID 为 spring-cloud-starter-alibaba-nacos-config 的 starter:</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在应用的 &#x2F;src&#x2F;main&#x2F;resources&#x2F;application.yaml 配置文件中配置 Nacos Config 地址并引入服务配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">serverAddr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span> <span class="comment">#如果用的云上托管版本，输入可访问的Nacos Server地址即可</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">import:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nacos:nacos-config-example.properties?refreshEnabled=true</span></span><br></pre></td></tr></table></figure></li><li><p>完成上述两步后，应用会从 Nacos Server 中获取相应的配置，并添加在 Spring Environment 的 PropertySources 中。假设我们通过 Nacos 作为配置中心保存应用服务的部分配置，有以下几种方式实现：</p><ul><li>BeanAutoRefreshConfigExample：通过将配置信息配置给 bean ，支持配置变自动刷新；</li><li>ConfigListenerExample：监听配置信息；</li><li>DockingInterfaceExample：对接 Nacos 接口，通过接口完成对配置信息增删改查；</li><li>ValueAnnotationExample：通过 @Value 注解进行配置信息获取。</li></ul></li></ol><h3 id="添加-Nacos-配置"><a href="#添加-Nacos-配置" class="headerlink" title="添加 Nacos 配置"></a>添加 Nacos 配置</h3><ol><li><p>命令方式：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl -X POST <span class="string">&quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos-config-example.properties&amp;group=DEFAULT_GROUP&amp;content=spring.cloud.nacos.config.serverAddr=127.0.0.1:8848%0Aspring.cloud.nacos.config.prefix=PREFIX%0Aspring.cloud.nacos.config.group=GROUP%0Aspring.cloud.nacos.config.namespace=NAMESPACE&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>控制台方式（推荐使用）</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">dataId</span> <span class="string">为：nacos-config-example.properties</span></span><br><span class="line"><span class="attr">group</span> <span class="string">为：DEFAULT_GROUP</span></span><br></pre></td></tr></table></figure><p>配置内容如下：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.config.serveraddr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.prefix</span>=<span class="string">PREFIX</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.group</span>=<span class="string">GROUP</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string">NAMESPACE</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="启动应用并验证"><a href="#启动应用并验证" class="headerlink" title="启动应用并验证"></a>启动应用并验证</h3><p><strong>应用启动</strong></p><ol><li><p>添加其他配置：在应用的 src&#x2F;main&#x2F;resources&#x2F;application.yaml 中添加基本配置信息：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">18084</span></span><br><span class="line"><span class="attr">management:</span></span><br><span class="line">  <span class="attr">endpoints:</span></span><br><span class="line">    <span class="attr">web:</span></span><br><span class="line">      <span class="attr">exposure:</span></span><br><span class="line">        <span class="attr">include:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>启动应用，支持 IDE 直接启动和编译打包后启动。</p><ul><li>IDE 直接启动：找到主类 NacosConfigApplication ，执行 main 方法启动应用。</li><li>打包编译后启动：首先执行 mvn clean package 将工程编译打包，然后执行 java-jar nacos-config-example.jar 启动应用。</li></ul></li></ol><p><strong>功能验证</strong></p><ol><li><p>验证自动注入</p><p>请求 <a href="http://127.0.0.1:18084/nacos/bean">http://127.0.0.1:18084/nacos/bean</a> 地址，可以看到成功从 Nacos 配置中心中获取了数据。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:18084/nacos/bean</span><br></pre></td></tr></table></figure><p>响应结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;serverAddr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:8848&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PREFIX&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NAMESPACE&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;GROUP&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>验证动态刷新</p><p>在命令行终端执行以下命令刷新 Nacos 的配置信息：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl -X POST <span class="string">&quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos-config-example.properties&amp;group=DEFAULT_GROUP&amp;content=spring.cloud.nacos.config.serveraddr=127.0.0.1:8848%0Aspring.cloud.nacos.config.prefix=PREFIX%0Aspring.cloud.nacos.config.group=DEFAULT_GROUP%0Aspring.cloud.nacos.config.namespace=NAMESPACE&quot;</span></span><br></pre></td></tr></table></figure><p>再次请求 <a href="http://127.0.0.1:18084/nacos/bean">http://127.0.0.1:18084/nacos/bean</a> 地址，可以看到应用已经从 Nacos 中获取到了最新的数据。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:18084/nacos/bean</span><br></pre></td></tr></table></figure><p>响应结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;serverAddr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:8848&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PREFIX&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NAMESPACE&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEFAULT_GROUP&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>Nacos 配置管理示例源码参考：<a href="https://github.com/alibaba/spring-cloud-alibaba/tree/2022.x/spring-cloud-alibaba-examples/nacos-example/nacos-config-example">Nacos 配置管理示例</a></p></li></ol><h2 id="接入-Nacos-服务注册与发现"><a href="#接入-Nacos-服务注册与发现" class="headerlink" title="接入 Nacos 服务注册与发现"></a>接入 Nacos 服务注册与发现</h2><h3 id="接入-Nacos-Discovery"><a href="#接入-Nacos-Discovery" class="headerlink" title="接入 Nacos Discovery"></a>接入 Nacos Discovery</h3><p>如果要在你的项目中使用 Nacos 来作为服务发现的组件。需要进行以下操作（确保 Nacos Server 已启动）：</p><ol><li><p>需要在 pom.xml 文件中引入 group ID 为 com.alibaba.cloud 和 artifact ID 为 spring-cloud-stater-alibaba-nacos-discovery 的 stater：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加应用配置：在应用的 &#x2F;src&#x2F;main&#x2F;resources&#x2F;application.properties 配置文件中配置 Nacos Server 地址：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.discovery.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br></pre></td></tr></table></figure></li><li><p>使用 @EnableDiscoveryClient 注解开启服务注册与发现功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ProviderApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">EchoController</span> &#123;</span><br><span class="line">        <span class="meta">@GetMapping(value = &quot;/echo/&#123;string&#125;&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">echo</span><span class="params">(<span class="meta">@PathVariable</span> String string)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> string;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="启动应用并验证-1"><a href="#启动应用并验证-1" class="headerlink" title="启动应用并验证"></a>启动应用并验证</h3><p><strong>应用启动</strong></p><ol><li><p>添加配置：在 <a href="https://github.com/alibaba/spring-cloud-alibaba/tree/2022.x/spring-cloud-alibaba-examples/nacos-example/nacos-discovery-example/nacos-discovery-provider-example">nacos-discovery-provider-example</a> 项目的 &#x2F;src&#x2F;main&#x2F;resources&#x2F;application.properties 中添加基本配置信息:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.application.name=service-provider</span><br><span class="line"></span><br><span class="line">server.port=18082</span><br></pre></td></tr></table></figure></li><li><p>启动应用，支持 IDE 直接启动和编译打包后启动。</p><ul><li>IDE 直接启动：找到 <a href="https://github.com/alibaba/spring-cloud-alibaba/tree/2022.x/spring-cloud-alibaba-examples/nacos-example/nacos-discovery-example/nacos-discovery-provider-example">nacos-discovery-provider-example</a> 项目的主类 ProviderApplication，执行 main 方法启动应用。</li><li>打包编译后启动：在 <a href="https://github.com/alibaba/spring-cloud-alibaba/tree/2022.x/spring-cloud-alibaba-examples/nacos-example/nacos-discovery-example/nacos-discovery-provider-example">nacos-discovery-provider-example</a> 项目中执行 mvn clean package 将工程编译打包，然后执行 java - jar nacos-discovery-provider-example.jar 启动应用。</li></ul></li></ol><p><strong>验证</strong></p><ol><li><p>查询服务</p><p>使用 Shell 终端输入如下命令查询，可以看到服务节点已经成功注册到 Nacos Server。</p><p>Terminal window</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:8848/nacos/v1/ns/catalog/instances?serviceName=service-provider&amp;clusterName=DEFAULT&amp;pageSize=10&amp;pageNo=1&amp;namespaceId=</span><br></pre></td></tr></table></figure><p>响应结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.3.19&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;healthy&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;ephemeral&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;clusterName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEFAULT&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;serviceName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEFAULT_GROUP@@service-provider&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="attr">&quot;preserved.register.source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SPRING_CLOUD&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;instanceHeartBeatInterval&quot;</span><span class="punctuation">:</span> <span class="number">5000</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;instanceHeartBeatTimeOut&quot;</span><span class="punctuation">:</span> <span class="number">15000</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;ipDeleteTimeout&quot;</span><span class="punctuation">:</span> <span class="number">30000</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>服务发现</p><p>在 pom.xml 中加入以下依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-loadbalancer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在配置文件中加入以下配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.loadbalancer.ribbon.enabled</span>=<span class="string">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.cloud.loadbalancer.nacos.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="服务消费"><a href="#服务消费" class="headerlink" title="服务消费"></a>服务消费</h3><h4 id="应用配置"><a href="#应用配置" class="headerlink" title="应用配置"></a>应用配置</h4><p>本章节只是为了便于您理解接入方式，此处只涉及 Ribbon、RestTemplate、FeignClient 相关内容，如果已经使用了其他服务发现组件，可以通过直接替换依赖来接入 spring-cloud-starter-alibaba-nacos-config。</p><ol><li><p>添加 @LoadBlanced 注解，使得 RestTemplate 接入 Ribbon：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>FeignClient 已经默认集成了 Ribbon ，此处演示如何配置一个 FeignClient：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(name = &quot;service-provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EchoService</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/echo/&#123;str&#125;&quot;)</span></span><br><span class="line">    String <span class="title function_">echo</span><span class="params">(<span class="meta">@PathVariable(&quot;str&quot;)</span> String str)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 @FeignClient 注解将 EchoService 这个接口包装成一个 FeignClient，属性 name 对应服务名 service-provider。</p><p>echo 方法上的 @GetMapping 注解将 echo 方法与 URL “&#x2F;echo&#x2F;{str}” 相对应，@PathVariable 注解将 URL 路径中的 {str} 对应成 echo 方法的参数 str。</p></li><li><p>将两者注入到 Controller 中：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;    </span><br><span class="line">    <span class="meta">@Autowired</span>    </span><br><span class="line">    <span class="keyword">private</span> EchoService echoService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/echo-rest/&#123;str&#125;&quot;)</span>    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">rest</span><span class="params">(<span class="meta">@PathVariable</span> String str)</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">&quot;http://service-provider/echo/&quot;</span> + str, String.class);    </span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/echo-feign/&#123;str&#125;&quot;)</span>    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">feign</span><span class="params">(<span class="meta">@PathVariable</span> String str)</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span> echoService.echo(str);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加必要的配置：</p><p>在 <a href="https://github.com/alibaba/spring-cloud-alibaba/tree/2022.x/spring-cloud-alibaba-examples/nacos-example/nacos-discovery-example/nacos-discovery-consumer-example">nacos-discovery-consumer-example</a> 项目的 &#x2F;src&#x2F;main&#x2F;resources&#x2F;application.properties 中添加基本配置信息：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">service-consumer</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">18083</span></span><br></pre></td></tr></table></figure></li><li><p>启动应用</p><ul><li>IDE 直接启动：找到 <a href="https://github.com/alibaba/spring-cloud-alibaba/tree/2022.x/spring-cloud-alibaba-examples/nacos-example/nacos-discovery-example/nacos-discovery-consumer-example">nacos-discovery-consumer-example</a> 项目的主类 ConsumerApplication，执行 main 方法启动应用。</li><li>打包编译后启动：在 <a href="https://github.com/alibaba/spring-cloud-alibaba/tree/2022.x/spring-cloud-alibaba-examples/nacos-example/nacos-discovery-example/nacos-discovery-consumer-example">nacos-discovery-consumer-example</a> 项目中执行 mvn clean package 将工程编译打包，然后执行 java -jar nacos-discovery-consumer-example.jar 启动应用。</li></ul></li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><ol><li><p>请求 <a href="http://127.0.0.1:18083/echo-rest/1234">http://127.0.0.1:18083/echo-rest/1234</a> 地址，可以看到响应显示了 nacos-discovery-provider-example 返回的消息 “hello Nacos Discovery 1234”，证明服务发现生效。</p><p>Terminal window</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:18083/echo-rest/1234</span><br></pre></td></tr></table></figure><p>响应结果：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hello Nacos Discovery 1234</span><br></pre></td></tr></table></figure></li><li><p>请求 <a href="http://127.0.0.1:18083/echo-feign/12345">http://127.0.0.1:18083/echo-feign/12345</a> 地址，可以看到响应显示了 nacos-discovery-provider-example 返回的消息 “hello Nacos Discovery 12345”，证明服务发现生效。</p><p>Terminal window</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:18083/echo-feign/12345</span><br></pre></td></tr></table></figure><p>响应结果：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hello Nacos Discovery 12345</span><br></pre></td></tr></table></figure></li></ol><p>Nacos 服务注册与发现示例源码参考：<a href="https://github.com/alibaba/spring-cloud-alibaba/tree/2022.x/spring-cloud-alibaba-examples/nacos-example/nacos-discovery-example">Nacos 服务注册与发现示例</a></p><hr><h1 id="进阶指南"><a href="#进阶指南" class="headerlink" title="进阶指南"></a>进阶指南</h1><p>本章节展示 spring-cloud-starter-alibaba-nacos-config 和 spring-cloud-starter-nacos-discovery 的高级特性和进阶用法。</p><h2 id="Nacos-配置中心进阶指南"><a href="#Nacos-配置中心进阶指南" class="headerlink" title="Nacos 配置中心进阶指南"></a>Nacos 配置中心进阶指南</h2><h3 id="profile-粒度配置"><a href="#profile-粒度配置" class="headerlink" title="profile 粒度配置"></a>profile 粒度配置</h3><p>spring-cloud-starter-alibaba-nacos-congig 在加载服务配置时：</p><p>不仅仅加载了以  dataId 为 ${spring.application.name}.${file-extension:properties} 为前缀的基础配置，还加载了 dataId 为 ${spring.application.name}-${profile}.${file-extension:properties } 的基础配置。</p><p>在日常开发中如果遇到多套环境下的不同配置，可以通过 Spring 提供的 ${spring.profiles.active} 这个配置项选择不同情况下的配置。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">develop</span></span><br></pre></td></tr></table></figure><p>Nacos 上新增一个 dataId 为：nacos-config-develop.yaml 的基础配置，如下所示：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Data ID:</span> <span class="string">nacos-config-develop.yaml</span></span><br><span class="line"><span class="attr">Group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="string">配置格式:</span> <span class="string">YAML</span></span><br><span class="line"><span class="string">配置内容:</span> <span class="attr">current.env:</span> <span class="string">develop-env</span></span><br></pre></td></tr></table></figure><p>启动 Spring Boot 应用测试的代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> SpringApplication.run(ProviderApplication.class, args);</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> applicationContext.getEnvironment().getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">userAge</span> <span class="operator">=</span> applicationContext.getEnvironment().getProperty(<span class="string">&quot;user.age&quot;</span>);</span><br><span class="line">            <span class="comment">//获取当前部署的环境</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">currentEnv</span> <span class="operator">=</span> applicationContext.getEnvironment().getProperty(<span class="string">&quot;current.env&quot;</span>);</span><br><span class="line">            System.err.println(<span class="string">&quot;in &quot;</span>+currentEnv+<span class="string">&quot; enviroment; &quot;</span>+<span class="string">&quot;user name :&quot;</span> + userName + <span class="string">&quot;; age: &quot;</span> + userAge);</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出结果如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> develop-env enviroment; user name :nacos-config-yaml-update; age: 68</span><br><span class="line"></span><br><span class="line">2018-11-02 15:34:25.013 INFO 33014 --- [ Thread-11] ConfigServletWebServerApplicationContext : Closing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6f1c29b7: startup <span class="built_in">date</span> [Fri Nov 02 15:33:57 CST 2018]; parent: org.springframework.context.annotation.AnnotationConfigApplicationContext@63355449</span><br></pre></td></tr></table></figure><p>如果需要切换到生产环境，只需要更改 ${spring.profiles.active} 参数配置即可。如下所示：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.profiles.active</span>=<span class="string">product</span></span><br></pre></td></tr></table></figure><p>同时生产环境上 Nacos 需要添加对应 dataId 的基础配置。例如，在生成环境下的 Nacos 添加了 dataId 为：nacos-config-product.yaml 的配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">Data ID:</span> <span class="string">nacos-config-product.yaml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line"></span><br><span class="line"><span class="string">配置格式:</span> <span class="string">YAML</span></span><br><span class="line"></span><br><span class="line"><span class="string">配置内容:</span> <span class="attr">current.env:</span> <span class="string">product-env</span></span><br></pre></td></tr></table></figure><p>启动测试程序，输出结果如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> product-env enviroment; user name :nacos-config-yaml-update; age: 68</span><br><span class="line"></span><br><span class="line">2018-11-02 15:42:14.628 INFO 33024 --- [Thread-11] ConfigServletWebServerApplicationContext : Closing org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext@6aa8e115: startup <span class="built_in">date</span> [Fri Nov 02 15:42:03 CST 2018]; parent: org.springframework.context.annotation.AnnotationConfigApplicationContext@19bb07ed</span><br></pre></td></tr></table></figure><blockquote><p>Note：</p><p>此案例中我们通过 <code>spring.profiles.active=&lt;profilename&gt;</code> 的方式写死在配置文件中，而在真正的项目实施过程中这个变量的值是需要不同环境而有不同的值。这个时候通常的做法是通过 <code>-Dspring.profiles.active=&lt;profile&gt;</code> 参数指定其配置来达到环境间灵活的切换。</p></blockquote><h3 id="自定义-Namespace-的配置"><a href="#自定义-Namespace-的配置" class="headerlink" title="自定义 Namespace 的配置"></a>自定义 Namespace 的配置</h3><p>Nacos 内部有 <a href="https://nacos.io/zh-cn/docs/concepts.html">Namespace</a> 的概念:</p><blockquote><p>用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离， 例如开发测试环境和生产环境的资源（如配置、服务）隔离等。 在没有明确指定 ${spring.cloud.nacos.config.namespace} 配置的情况下， 默认使用的是 Nacos 中 public 命名空间即默认的命名空间。如果需要使用自定义的命名空间，可以通过以下配置来实现：</p></blockquote><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string">YOUR_NAMESPACE_ID</span></span><br></pre></td></tr></table></figure><blockquote><p>NOTE:</p><p><strong>该配置必须放在 bootstrap.properties 文件中</strong>。此外 spring.cloud.nacos.config.namespace 的值是 namespace 对应的 id，id 值可以在 Nacos 的控制台获取。并且在添加配置时注意不要选择其他的 namespace，否则将会导致读取不到正确的配置。</p></blockquote><h3 id="自定义-Group-的配置"><a href="#自定义-Group-的配置" class="headerlink" title="自定义 Group 的配置"></a>自定义 Group 的配置</h3><p>在没有明确指定 ${spring.cloud.nacos.config.group} 配置的情况下， 默认使用的是组 DEFAULT_GROUP 。如果需要自定义 Group，可以通过以下配置来实现：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.config.group</span>=<span class="string">YOUR_GROUP_NAME</span></span><br></pre></td></tr></table></figure><blockquote><p>NOTE:</p><p><strong>该配置必须放在 bootstrap.properties 文件中。</strong>并且在添加配置时 Group 的值一定要和 spring.cloud.nacos.config.group 的配置值一致。</p></blockquote><h3 id="配置的优先级"><a href="#配置的优先级" class="headerlink" title="配置的优先级"></a>配置的优先级</h3><p>Nacos Config 目前提供了三种配置能力从 Nacos 拉取相关的配置：</p><ul><li>A: 通过 spring.cloud.nacos.config.shared-dataids 支持多个共享 Data Id 的配置</li><li>B: 通过 spring.cloud.nacos.config.ext-config[n].data-id 的方式支持多个扩展 Data Id 的配置</li><li>C: 通过内部相关规则(应用名、应用名+ Profile )自动生成相关的 Data Id 配置</li></ul><p>当三种方式共同使用时，他们的一个优先级关系是: *<strong>A &lt; B &lt; C*</strong></p><h3 id="springc-config-import-引入"><a href="#springc-config-import-引入" class="headerlink" title="springc.config.import 引入"></a>springc.config.import 引入</h3><p>这里假设有一个配置文件 bootstrap.yml，升级到 2021.0.1.0 以上的版本应该怎么配置呢？</p><p>bootstrap.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">test.yml</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">extension-configs:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">test01.yml</span></span><br><span class="line">            <span class="attr">group:</span> <span class="string">group_01</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">dataId:</span> <span class="string">test02.yml</span></span><br><span class="line">            <span class="attr">group:</span> <span class="string">group_02</span></span><br><span class="line">            <span class="attr">refresh:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p><strong>注意：上面的配置和下面的配置是等价的！</strong></p><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">import:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">optional:nacos:test.yml</span> <span class="comment"># 监听 DEFAULT_GROUP:test.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">optional:nacos:test01.yml?group=group_01</span> <span class="comment"># 覆盖默认 group，监听 group_01:test01.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">optional:nacos:test02.yml?group=group_02&amp;refreshEnabled=false</span> <span class="comment"># 不开启动态刷新</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">nacos:test03.yml</span> <span class="comment"># 在拉取nacos配置异常时会快速失败，会导致 spring 容器启动失败</span></span><br></pre></td></tr></table></figure><p>使用 spring.config.import 引入配置时的注意事项如下：</p><ol><li>如果使用 spring.config.import 就不能使用 bootstrap.yml&#x2F;properties 引入配置的方式了；</li><li>如果引入了 spring-cloud-starter-alibaba-nacos-config，并且使用 import 方式导入配置, 项目启动时会自动检测是否引入了 nacos 条目，如果没有 import nacos 条目，会出现如下错误：</li></ol><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">The spring.config.import property is missing a nacos: entry</span><br><span class="line">Action:</span><br><span class="line">Add a spring.config.import=nacos: property to your configuration.If configuration is not required add spring.config.import=optional:nacos: instead.To <span class="built_in">disable</span> this check, <span class="built_in">set</span> spring.cloud.nacos.config.import-check.enabled=<span class="literal">false</span>.</span><br></pre></td></tr></table></figure><p>可以通过手动设置 spring.cloud.nacos.config.import-check.enabled&#x3D;false 关闭它，但是不建议这么做，这个功能可以帮助你检查是否引入多余依赖</p><p>假如想保留以前的使用方式 ( bootstrap 引入配置)，你只需要添加依赖 spring-cloud-starter-bootstrap 依赖，不需要修改一行代码即可完成配置方式的切换！</p><h3 id="配置项参考"><a href="#配置项参考" class="headerlink" title="配置项参考"></a>配置项参考</h3><p>更多关于 spring-cloud-starter-alibaba-nacos-config 的 starter 配置项如下所示:</p><table><thead><tr><th>配置项</th><th>key</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>服务端地址</td><td>spring.cloud.nacos.config.server-addr</td><td></td><td>服务器 ip 和端口</td></tr><tr><td>DataId 前缀</td><td>spring.cloud.nacos.config.prefix</td><td>${spring.application.name}</td><td>DataId 的前缀，默认值为应用名称</td></tr><tr><td>Group</td><td>spring.cloud.nacos.config.group</td><td>DEFAULT_GROUP</td><td></td></tr><tr><td>DataId 后缀及内容文件格式</td><td>spring.cloud.nacos.config.file-extension</td><td>properties</td><td>DataId 的后缀，同时也是配置内容的文件格式，目前只支持 properties</td></tr><tr><td>配置内容的编码方式</td><td>spring.cloud.nacos.config.encode</td><td>UTF-8</td><td>配置的编码</td></tr><tr><td>获取配置的超时时间</td><td>spring.cloud.nacos.config.timeout</td><td>3000</td><td>单位为 ms</td></tr><tr><td>配置的命名空间</td><td>spring.cloud.nacos.config.namespace</td><td></td><td>常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源隔离等。</td></tr><tr><td>AccessKey</td><td>spring.cloud.nacos.config.access-key</td><td></td><td></td></tr><tr><td>SecretKey</td><td>spring.cloud.nacos.config.secret-key</td><td></td><td></td></tr><tr><td>相对路径</td><td>spring.cloud.nacos.config.context-path</td><td></td><td>服务端 API 的相对路径</td></tr><tr><td>接入点</td><td>spring.cloud.nacos.config.endpoint</td><td></td><td>地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址</td></tr><tr><td>是否开启监听和自动刷新</td><td>spring.cloud.nacos.config.refresh-enabled</td><td>true</td><td></td></tr><tr><td>集群服务名</td><td>spring.cloud.nacos.config.cluster-name</td><td></td><td></td></tr></tbody></table><h3 id="Endpoint-信息"><a href="#Endpoint-信息" class="headerlink" title="Endpoint 信息"></a>Endpoint 信息</h3><p>请求 <a href="http://127.0.0.1:18083/actuator/nacosconfig">http://127.0.0.1:18083/actuator/nacosconfig</a> 地址，可以看到相关的 EndPoint 节点信息。</p><p>Terminal window</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:18083/actuator/nacosconfig</span><br></pre></td></tr></table></figure><p>响应结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;NacosConfigProperties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;serverAddr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:8848&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;encode&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEFAULT_GROUP&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PREFIX&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;fileExtension&quot;</span><span class="punctuation">:</span> <span class="string">&quot;properties&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;timeout&quot;</span><span class="punctuation">:</span> <span class="number">3000</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;maxRetry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;configLongPollTimeout&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;configRetryTime&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;enableRemoteSyncConfig&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;endpoint&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NAMESPACE&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;accessKey&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;secretKey&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;ramRoleName&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;contextPath&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;clusterName&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;sharedConfigs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;extensionConfigs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;refreshEnabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;configServiceProperties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;encode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;secretKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;serveraddr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:8848&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;prefix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PREFIX&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;configLongPollTimeout&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;maxRetry&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;configRetryTime&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;endpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;serverAddr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:8848&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;accessKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;enableRemoteSyncConfig&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;clusterName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NAMESPACE&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;ramRoleName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEFAULT_GROUP&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;refreshableDataids&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;extConfig&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;sharedDataids&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;RefreshHistory&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;Sources&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;lastSynced&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-05-10 09:35:50&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;dataId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nacos-config-example.properties&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Nacos-服务注册与发现进阶指南"><a href="#Nacos-服务注册与发现进阶指南" class="headerlink" title="Nacos 服务注册与发现进阶指南"></a>Nacos 服务注册与发现进阶指南</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>spring-cloud-starter-alibaba-nacos-discovery 遵循了 Spring Cloud Common 标准，实现了 AutoServiceRegistration、ServiceRegistry、Registration 这三个接口。</p><p>在 Spring Cloud 应用的启动阶段，监听了 WebServerInitializedEvent 事件，当 Web 容器初始化完成后，即收到 WebServerInitializedEvent 事件后，会触发注册的动作，调用 ServiceRegistry 的 register 方法，将服务注册到 Nacos Server。</p><h3 id="IPv4-至-IPv6-地址迁移方案"><a href="#IPv4-至-IPv6-地址迁移方案" class="headerlink" title="IPv4 至 IPv6 地址迁移方案"></a>IPv4 至 IPv6 地址迁移方案</h3><p><strong>IPv4 和 IPv6 地址双注册</strong></p><p>在配置完成 Spring Cloud Loadbalancer 作为负载均衡策略后，应用启动后会默认将微服务的 IPv4 地址和 IPv6 地址注册到注册中心中，其中 IPv4 地址会存放在 Nacos 服务列表中的 IP 字段下， IPv6 地址在 Nacos 的 metadata 字段中，其对应的 Key 为 IPv6 。当服务消费者调用服务提供者时，会根据自身的 IP 地址栈支持情况，选择合适的 IP 地址类型发起服务调用。</p><p>具体规则：</p><ol><li>服务消费者本身支持 IPv4 和 IPv6 双地址栈或仅支持 IPv6 地址栈的情况下，服务消费者会使用服务提供的 IPv6 地址发起服务调用，IPv6 地址调用失败且服务本身同时支持 IPv4 地址栈时，暂不支持切换到 IPv4 地址发起重试调用；</li><li>服务消费者本身仅支持 IPv4 单地址栈的情况下，服务消费者会使用服务提供的 IPv4 地址发起服务调用。</li></ol><p><strong>仅注册 IPv4</strong></p><p>如果您只想使用 IPv4 地址进行注册，可以在 application.properties 使用如下配置项进行配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.discovery.ip-type</span>=<span class="string">IPv4</span></span><br></pre></td></tr></table></figure><p><strong>仅注册 IPv6</strong></p><p>如果您只想使用 IPv6 地址，可以在 application.properties 使用如下配置项进行配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.discovery.ip-type</span>=<span class="string">IPv6</span></span><br></pre></td></tr></table></figure><h3 id="配置项参考-1"><a href="#配置项参考-1" class="headerlink" title="配置项参考"></a>配置项参考</h3><p>更多关于 spring-cloud-starter-alibaba-nacos-discovery 的 starter 配置项如下所示:</p><table><thead><tr><th>配置项</th><th>key</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>服务端地址</td><td>spring.cloud.nacos.discovery.server-addr</td><td></td><td></td></tr><tr><td>服务名</td><td>spring.cloud.nacos.discovery.service</td><td>应用名</td><td>注册到 Nacos 上的服务名称，默认值为应用名称</td></tr><tr><td>权重</td><td>spring.cloud.nacos.discovery.weight</td><td>1</td><td>取值范围 1 到 100，数值越大，权重越大</td></tr><tr><td>网卡名</td><td>spring.cloud.nacos.discovery.network-interface</td><td></td><td>当 IP 未配置时，注册的 IP 为此网卡所对应的 IP 地址，如果此项也未配置，则默认取第一块网卡的地址</td></tr><tr><td>注册的 IP 地址</td><td>spring.cloud.nacos.discovery.ip</td><td></td><td>优先级最高</td></tr><tr><td>注册的 IP 地址类型</td><td>spring.cloud.nacos.discovery.ip-type</td><td>双栈地址</td><td>可以配置 IPv4 和 IPv6 两种类型，如果网卡同类型 IP 地址存在多个，希望制定特定网段地址，可使用<code>spring.cloud.inetutils.preferred-networks</code>配置筛选地址</td></tr><tr><td>注册的端口</td><td>spring.cloud.nacos.discovery.port</td><td>-1</td><td>默认情况下不用配置，会自动探测</td></tr><tr><td>命名空间</td><td>spring.cloud.nacos.discovery.namespace</td><td></td><td>常用场景之一是不同环境的注册的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</td></tr><tr><td>AccessKey</td><td>spring.cloud.nacos.discovery.access-key</td><td></td><td></td></tr><tr><td>SecretKey</td><td>spring.cloud.nacos.discovery.secret-key</td><td></td><td></td></tr><tr><td>Metadata</td><td>spring.cloud.nacos.discovery.metadata</td><td></td><td>使用 Map 格式配置</td></tr><tr><td>日志文件名</td><td>spring.cloud.nacos.discovery.log-name</td><td></td><td></td></tr><tr><td>集群</td><td>spring.cloud.nacos.discovery.cluster-name</td><td>DEFAULT</td><td>Nacos 集群名称</td></tr><tr><td>接入点</td><td>spring.cloud.nacos.discovery.endpoint</td><td></td><td>地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址</td></tr><tr><td>是否集成 LoadBalancer</td><td>spring.cloud.loadbalancer.nacos.enabled</td><td>false</td><td></td></tr><tr><td>是否开启 Nacos Watch</td><td>spring.cloud.nacos.discovery.watch.enabled</td><td>false</td><td>可以设置成 true 来开启 watch</td></tr><tr><td>是否启用 Nacos</td><td>spring.cloud.nacos.discovery.register-enabled</td><td>true</td><td>默认启动，设置为 false 时会关闭自动向 Nacos 注册的功能</td></tr><tr><td>是否启用容错配置</td><td><code>spring.cloud.nacos.discovery.failure-tolerance-enabled</code></td><td>false</td><td>开启 nacos 服务发现失败容错能力，该功能会在 nacos 获取实例失败时返回上一次获取的实例，可以在 nacos server 网络不稳定时提供容错能力，不会导致请求全部挂掉</td></tr></tbody></table><h3 id="Endpoint-信息-1"><a href="#Endpoint-信息-1" class="headerlink" title="Endpoint 信息"></a>Endpoint 信息</h3><p>请求 <a href="http://127.0.0.1:18083/actuator/nacosdiscovery">http://127.0.0.1:18083/actuator/nacosdiscovery</a> 地址，可以看到相关的 EndPoint 节点信息。</p><p>Terminal window</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ curl http://127.0.0.1:18083/actuator/nacosdiscovery</span><br></pre></td></tr></table></figure><p>响应结果：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;subscribe&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;NacosDiscoveryProperties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;serverAddr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:8848&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nacos&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nacos&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;endpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;watchDelay&quot;</span><span class="punctuation">:</span> <span class="number">30000</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;logName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;service&quot;</span><span class="punctuation">:</span> <span class="string">&quot;service-consumer&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;weight&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;clusterName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEFAULT&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEFAULT_GROUP&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;namingLoadCacheAtStart&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;IPv6&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;preserved.register.source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SPRING_CLOUD&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;registerEnabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;ip&quot;</span><span class="punctuation">:</span> <span class="string">&quot;192.168.3.19&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;networkInterface&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;ipType&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;port&quot;</span><span class="punctuation">:</span> <span class="number">18083</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;secure&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;accessKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;secretKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;heartBeatInterval&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;heartBeatTimeout&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;ipDeleteTimeout&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;instanceEnabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;ephemeral&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;failureToleranceEnabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;failFast&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;nacosProperties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nacos&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;endpoint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;secretKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;serverAddr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:8848&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;accessKey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;clusterName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;DEFAULT&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;com.alibaba.nacos.naming.log.filename&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;namingLoadCacheAtStart&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;failFast&quot;</span><span class="punctuation">:</span> <span class="string">&quot;true&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">      <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;nacos&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 安装与使用</title>
      <link href="/posts/386349fe.html"/>
      <url>/posts/386349fe.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/load.gif" data-original="https://pic3.zhimg.com/v2-e34d3ad1878fd02e1b7d7f3052b04171_1440w.jpg?source=172ae18b" alt=" https://pic3.zhimg.com/v2-e34d3ad1878fd02e1b7d7f3052b04171_1440w.jpg?source=172ae18b"></p><h1 id="Git-教程"><a href="#Git-教程" class="headerlink" title="Git 教程"></a>Git 教程</h1><ul><li>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目</li><li>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件</li><li>Git 与常用的版本控制工具 CVS ，Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持</li></ul><h2 id="Git-与-SVN-区别"><a href="#Git-与-SVN-区别" class="headerlink" title="Git 与 SVN 区别"></a>Git 与 SVN 区别</h2><p>Git 不仅仅是个版本控制系统，它也是个内容管理系统，工作管理系统等</p><p>如果你是一个具有使用 SVN 背景的人，你需要做一定的思想转换，来适应 Git 提供的一些概念和特征</p><p><code>Git 与 SVN 区别点：</code></p><ul><li><strong>Git 是分布式的，SVN 不是：</strong>这是 Git 和其他非分布式的版本控制系统，例如 SVN ，CVS 等，最核心的区别</li><li><strong>Git 把内容按元数据方式存储，而 SVN 是按文件：</strong>所有的资源控制系统都是把文件的元信息隐藏在一个类似 SVN ，CVS 等的文件夹里</li><li><strong>Git 分支和 SVN 的分支不同：</strong>分支在 SVN 中一点都不特别，其实它就是版本库中的另一个目录</li><li><strong>Git 没有一个全局的版本号，而 SVN 有：</strong>目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征</li><li><strong>Git 的内容完整性要由于 SVN：</strong>Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏</li></ul><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2015/02/0D32F290-80B0-4EA4-9836-CA58E22569B3.jpg" alt=" https://www.runoob.com/wp-content/uploads/2015/02/0D32F290-80B0-4EA4-9836-CA58E22569B3.jpg"></p><hr><h1 id="Git-安装配置"><a href="#Git-安装配置" class="headerlink" title="Git 安装配置"></a>Git 安装配置</h1><p>在使用 Git 前我们需要先安装 Git</p><p>Git 目前支持 Linux &#x2F; Unix、Solaris、Mac 和 Windows 平台运行</p><p>Git 各平台安装包下载地址为：<a href="http://git-scm.com/downloads">http://git-scm.com/downloads</a></p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2015/02/git-download.png" alt=" https://www.runoob.com/wp-content/uploads/2015/02/git-download.png"></p><h2 id="Linux-平台上安装"><a href="#Linux-平台上安装" class="headerlink" title="Linux 平台上安装"></a>Linux 平台上安装</h2><p>各大 Linux 平台可以使用包管理器（apt-get 、yum 等）进行安装</p><p>Debian &#x2F; Ubuntu Git 安装最新稳定版本命令为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install git</span><br></pre></td></tr></table></figure><p>Centos &#x2F; RedHat 安装命令为：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install git-core</span><br></pre></td></tr></table></figure><p>Fedora 安装命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum install git (Fedora 21 及之前的版本)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">dnf install git (Fedora 22 及更高新版本)</span></span><br></pre></td></tr></table></figure><p>FreeBSD 安装命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkg install git</span><br></pre></td></tr></table></figure><p>OpenBSD 安装命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pkg_add git</span><br></pre></td></tr></table></figure><p>Alpine 安装命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apk add git</span><br></pre></td></tr></table></figure><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><p>我们也可以在官网下载源码包来安装，最新源码包下载地址：<a href="https://mirrors.edge.kernel.org/pub/software/scm/git/%E3%80%82">https://mirrors.edge.kernel.org/pub/software/scm/git/。</a></p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2015/02/git-source.png" alt="img"></p><p>也可以在 GitHub 上克隆源码包：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/git/git</span><br></pre></td></tr></table></figure><p>解压安装下载的源码包：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tar -zxf git-1.7.2.2.tar.gz</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> git-1.7.2.2</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make prefix=/usr/local all</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> make prefix=/usr/local install</span></span><br></pre></td></tr></table></figure><h2 id="Windows-平台安装"><a href="#Windows-平台安装" class="headerlink" title="Windows 平台安装"></a>Windows 平台安装</h2><p>在 Windows 平台上安装 Git 同样轻松，有个叫做 msysGit 的项目提供了安装包，可以到 GitHub 的页面上下载 exe 安装文件并运行：</p><p>安装包下载地址：<a href="https://gitforwindows.org/">https://gitforwindows.org/</a></p><p>直接官网下载也可以：<a href="https://git-scm.com/download/win%E3%80%82">https://git-scm.com/download/win。</a></p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2015/02/git-win.png" alt="img"></p><p>下载后，双击安装包，打开界面如下所示，点击 “next” 按钮开始安装：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2015/02/20140127131250906" alt="img"></p><p>完成安装之后，就可以使用命令行的 git 工具（已经自带了 ssh 客户端）了，另外还有一个图形界面的 Git 项目管理工具。</p><p>在开始菜单里找到 **”Git”-&gt;”Git Bash”**，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。</p><p><strong>使用 winget 工具</strong></p><p>如果你已经安装了 winget，可以使用以下命令来安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">winget install --id Git.Git -e --source winget</span><br></pre></td></tr></table></figure><h2 id="Mac-平台上安装"><a href="#Mac-平台上安装" class="headerlink" title="Mac 平台上安装"></a>Mac 平台上安装</h2><p>通过 Homebrew 安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install git</span><br></pre></td></tr></table></figure><p>如果您想要安装 git-gui 和 gitk（git 的提交 GUI 和交互式历史记录浏览器），您可以使用 homebrew 进行安装：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install git-gui</span><br></pre></td></tr></table></figure><p>也可以使用图形化的 Git 安装工具，下载地址为：</p><p><a href="https://sourceforge.net/projects/git-osx-installer/">https://sourceforge.net/projects/git-osx-installer/</a></p><p>安装界面如下所示：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2015/02/18333fig0107-tn.png" alt="img"></p><h2 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h2><p>Git 提供了一个叫 <code>git config</code> 的命令，用来配置或读取相应的工作环境变量。</p><p>这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。</p><p>这些变量可以存放在一下三个不同的地方：</p><ul><li><code>/etc/gitconfig</code> 文件：系统中对所有用户都普遍适用的配置。若使用 <code>git config</code> 时用 <code>--system</code> 选项，读写的就是这个文件。</li><li><code>~/.gitconfig</code> 文件：用户目录下的配置文件只适用于该用户。若使用 <code>git config</code> 时用 <code>--global</code> 选项，读写的就是这个文件。</li><li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 <code>.git/config</code> 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 <code>.git/config</code> 里的配置会覆盖 <code>/etc/gitconfig</code> 中的同名变量。</li></ul><p>在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Documents and Settings$USER。</p><p>此外，Git 还会尝试找寻 &#x2F;etc&#x2F;gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。</p><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>配置个人的用户名称和电子邮件地址，这是为了在每次提交代码时记录提交者的信息：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;runoob&quot;</span><br><span class="line">git config --global user.email test@runoob.com</span><br></pre></td></tr></table></figure><p>如果用了 <strong>–global</strong> 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。</p><p>如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git&#x2F;config 文件里。</p><h3 id="文本编辑器"><a href="#文本编辑器" class="headerlink" title="文本编辑器"></a>文本编辑器</h3><p>设置 Git 默认使用的文本编辑器,一般可能会是 Vi 或者 Vim，如果你有其他偏好，比如 VS Code 的话，可以重新设置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global core.editor &quot;code --wait&quot;</span><br></pre></td></tr></table></figure><h3 id="差异分析工具"><a href="#差异分析工具" class="headerlink" title="差异分析工具"></a>差异分析工具</h3><p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global merge.tool vimdiff</span><br></pre></td></tr></table></figure><p>Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。</p><p>当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。</p><h3 id="查看配置信息"><a href="#查看配置信息" class="headerlink" title="查看配置信息"></a>查看配置信息</h3><p>要检查已有的配置信息，可以使用 <strong>git config –list</strong> 命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --list</span></span><br><span class="line">http.postbuffer=2M</span><br><span class="line">user.name=runoob</span><br><span class="line">user.email=test@runoob.com</span><br></pre></td></tr></table></figure><p>有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 &#x2F;etc&#x2F;gitconfig 和 ~&#x2F;.gitconfig），不过最终 Git 实际采用的是最后一个。</p><p>这些配置我们也可以在 <strong>~&#x2F;.gitconfig</strong> 或 <strong>&#x2F;etc&#x2F;gitconfig</strong> 看到，如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.gitconfig </span><br></pre></td></tr></table></figure><p>显示内容如下所示：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[http]</span><br><span class="line">    postBuffer = 2M</span><br><span class="line">[user]</span><br><span class="line">    name = runoob</span><br><span class="line">    email = test@runoob.com</span><br></pre></td></tr></table></figure><p>也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config user.name</span></span><br><span class="line">runoob</span><br></pre></td></tr></table></figure><h3 id="成-SSH-密钥（可选）"><a href="#成-SSH-密钥（可选）" class="headerlink" title="成 SSH 密钥（可选）"></a>成 SSH 密钥（可选）</h3><p>如果你需要通过 SSH 进行 Git 操作，可以生成 SSH 密钥并添加到你的 Git 托管服务（如 GitHub、GitLab 等）上。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C &quot;your.email@example.com&quot;</span><br></pre></td></tr></table></figure><p>按提示完成生成过程，然后将生成的公钥添加到相应的平台。</p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>在终端或命令行中运行以下命令，确保 Git 已正确安装并配置：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git --version</span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure><hr><h1 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h1><p>下图展示了 Git 的工作流程：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2015/02/git-process.png" alt="img"></p><h2 id="1-克隆仓库"><a href="#1-克隆仓库" class="headerlink" title="1.克隆仓库"></a>1.克隆仓库</h2><p>如果你要参与一个已有的项目，首先需要将远程仓库克隆到本地：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/username/repo.git</span><br><span class="line"><span class="built_in">cd</span> repo</span><br></pre></td></tr></table></figure><h2 id="2-创建分支"><a href="#2-创建分支" class="headerlink" title="2.创建分支"></a>2.创建分支</h2><p>为了避免直接在 main 或 master 分支上进行开发，通常会创建一个新的分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b new-feature</span><br></pre></td></tr></table></figure><h2 id="3-工作目录"><a href="#3-工作目录" class="headerlink" title="3.工作目录"></a>3.工作目录</h2><p>在工作目录中进行代码编辑、添加新文件或删除不需要的文件。</p><h2 id="4-暂存文件"><a href="#4-暂存文件" class="headerlink" title="4.暂存文件"></a>4.暂存文件</h2><p>将修改过的文件添加到暂存区，以便进行下一步的提交操作：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add filename</span><br><span class="line"><span class="comment"># 或者添加所有修改的文件</span></span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><h2 id="5-提交更改"><a href="#5-提交更改" class="headerlink" title="5.提交更改"></a>5.提交更改</h2><p>将暂存区的更改提交到本地仓库，并添加提交信息：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Add new feature&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6-拉取最新更改"><a href="#6-拉取最新更改" class="headerlink" title="6.拉取最新更改"></a>6.拉取最新更改</h2><p>在推送本地更改之前，最好从远程仓库拉取最新的更改，以避免冲突：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull origin main</span><br><span class="line"><span class="comment"># 或者如果在新的分支上工作</span></span><br><span class="line">git pull origin new-feature</span><br></pre></td></tr></table></figure><h2 id="7-推送更改"><a href="#7-推送更改" class="headerlink" title="7.推送更改"></a>7.推送更改</h2><p>将本地的提交推送到远程仓库：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin new-feature</span><br></pre></td></tr></table></figure><h2 id="8-创建-Pull-Request-PR"><a href="#8-创建-Pull-Request-PR" class="headerlink" title="8.创建 Pull Request (PR)"></a>8.创建 Pull Request (PR)</h2><p>在 GitHub 或其他托管平台上创建 Pull Request，邀请团队成员进行代码审查，PR 合并后，你的更改就会合并到主分支。</p><h2 id="9-合并更改"><a href="#9-合并更改" class="headerlink" title="9.合并更改"></a>9.合并更改</h2><p>在 PR 审核通过合并后，可以将远程仓库的主分支合并到本地分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git pull origin main</span><br><span class="line">git merge new-feature</span><br></pre></td></tr></table></figure><h2 id="10-删除分支"><a href="#10-删除分支" class="headerlink" title="10.删除分支"></a>10.删除分支</h2><p>如果不再需要新功能分支，可以将其删除：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -d new-feature</span><br></pre></td></tr></table></figure><p>或者从远程仓库删除分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin --delete new-feature</span><br></pre></td></tr></table></figure><hr><h1 id="Git-工作区、暂存区和版本库"><a href="#Git-工作区、暂存区和版本库" class="headerlink" title="Git 工作区、暂存区和版本库"></a>Git 工作区、暂存区和版本库</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>我们先来了解一下 Git 工作区、暂存区和版本库概念：</p><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index 。一般存放到 <code>.git</code> 目录下的 index 文件 <code>(.git / index)</code> 中，所以我们把暂存区有时也叫索引 <code>(index)</code>。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <code>.git</code> ，这个不算工作区，而是 Git 的版本库。</li></ul><p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt="Git 工作区、暂存区和版本库"></p><ul><li>图中左侧为工作区，右侧为版本库。在版本库中标记为 <strong>index</strong> 的区域是暂存区（stage &#x2F; index），标记为 <strong>master</strong> 的是 master 分支所代表的目录树。</li><li>图中我们可以看出此时的 <strong>HEAD</strong> 实际是指向 master 分支的一个 <strong>游标</strong>，所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li><li>图中的 objects 标识的区域为 Git 的对象库，实际位于 <code>git/objects</code> 目录下，里面包含了创建的各种对象及内容。</li><li>当对工作区修改（或新增）的文件执行 <code>git add</code>命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的 ID 被记录在暂存区的文件索引中。</li><li>当执行提交操作 <code>(git commit)</code>时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li><li>当执行 <code>git rest HEAD</code> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行 <code>git rm --cached &lt;file&gt;</code> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行 <code>git checkout</code> ，或者 <code>git checkout -- &lt;file&gt;</code> 命令时，会用暂存区全部或指定的文件替换工作区的文件，这个操作很危险，会清除工作区中未添加到暂存区中的改动。</li><li>当执行 <code>git checkout HEAD .</code> 或者 <code>git checkout HEAD &lt;file&gt;</code> 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区的文件。这个命令也是极其危险的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li></ul><h3 id="1-工作区（Working-Directory）"><a href="#1-工作区（Working-Directory）" class="headerlink" title="1.工作区（Working Directory）"></a>1.工作区（Working Directory）</h3><p>工作区是你在本地计算机上的项目目录，你在这里进行文件的创建、修改和删除操作。工作区包含了当前项目的所有文件和子目录。</p><p>特点：</p><ul><li>显示项目的当前状态</li><li>文件的修改</li></ul><h3 id="2-暂存区（Staging-Area）"><a href="#2-暂存区（Staging-Area）" class="headerlink" title="2.暂存区（Staging Area）"></a>2.暂存区（Staging Area）</h3><p>暂存区是一个临时存储区域，它包含了即将被提交到版本库中的文件快照，在提交之前，你可以选择性地将工作区中的修改添加到暂存区。</p><p>特点：</p><ul><li>暂存区保存了将被包括在下一个提交的更改</li><li>你可以多次使用 git add 命令来讲文件添加到暂存区，直到你准备好提交所有更改</li></ul><p>常用命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add filename      <span class="comment"># 将单个文件添加到暂存区</span></span><br><span class="line">git add .             <span class="comment"># 将工作区中的所有修改添加到暂存区</span></span><br><span class="line">git status            <span class="comment"># 查看哪些文件在暂存区</span></span><br></pre></td></tr></table></figure><h3 id="3-版本库（Repository）"><a href="#3-版本库（Repository）" class="headerlink" title="3.版本库（Repository）"></a>3.版本库（Repository）</h3><p>版本库包含项目的所有版本历史记录。</p><p>每次提交都会在版本库中创建一个新的快照，这些快照是不可变的，确保了项目的完整历史记录。</p><p>特点：</p><ul><li>版本库分为本地版本库和远程版本库。这里主要指本地版本库。</li><li>本地版本库存储在 .git 目录中，它包含了所有提交的对象和引用。</li></ul><p>常用命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Commit message&quot;</span>   <span class="comment"># 将暂存区的更改提交到本地版本库</span></span><br><span class="line">git <span class="built_in">log</span>                          <span class="comment"># 查看提交历史</span></span><br><span class="line">git diff                         <span class="comment"># 查看工作区和暂存区之间的差异</span></span><br><span class="line">git diff --cached                <span class="comment"># 查看暂存区和最后一次提交之间的差异</span></span><br></pre></td></tr></table></figure><h2 id="工作区、暂存区和版本库之间的关系"><a href="#工作区、暂存区和版本库之间的关系" class="headerlink" title="工作区、暂存区和版本库之间的关系"></a>工作区、暂存区和版本库之间的关系</h2><h3 id="1-工作区-暂存区"><a href="#1-工作区-暂存区" class="headerlink" title="1.工作区 -&gt; 暂存区"></a>1.工作区 -&gt; 暂存区</h3><p>使用 <code>git add</code> 命令将工作区中的修改添加到暂存区。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add filename</span><br></pre></td></tr></table></figure><h3 id="2-暂存区-版本库"><a href="#2-暂存区-版本库" class="headerlink" title="2.暂存区 -&gt; 版本库"></a>2.暂存区 -&gt; 版本库</h3><p>使用 <code>git commit</code> 命令将暂存区中的修改提交到版本库。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Commit message&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-版本库-远程仓库"><a href="#3-版本库-远程仓库" class="headerlink" title="3.版本库 -&gt; 远程仓库"></a>3.版本库 -&gt; 远程仓库</h3><p>使用 <code>git push</code> 命令将本地版本库的提交推送到远程仓库。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin branch-name</span><br></pre></td></tr></table></figure><h3 id="4-远程仓库-本地版本库"><a href="#4-远程仓库-本地版本库" class="headerlink" title="4.远程仓库 -&gt; 本地版本库"></a>4.远程仓库 -&gt; 本地版本库</h3><p>使用 <code>git pull</code> 或 <code>git fetch</code> 从远程仓库获取更新。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git pull origin branch-name</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">git fetch origin branch-name</span><br><span class="line">git merge origin/branch-name</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>假设你在工作目录中修改了 file.txt ：</p><h3 id="1-工作区"><a href="#1-工作区" class="headerlink" title="1.工作区"></a>1.工作区</h3><p>修改 file.txt 并保存。</p><h3 id="2-暂存区"><a href="#2-暂存区" class="headerlink" title="2.暂存区"></a>2.暂存区</h3><p>将修改添加到暂存区：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add file.txt</span><br></pre></td></tr></table></figure><h3 id="3-版本库"><a href="#3-版本库" class="headerlink" title="3.版本库"></a>3.版本库</h3><p>将暂存区的修改提交到本地版本库：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Update file.txt&quot;</span></span><br></pre></td></tr></table></figure><h3 id="4-远程仓库"><a href="#4-远程仓库" class="headerlink" title="4.远程仓库"></a>4.远程仓库</h3><p>将本地提交推送到远程仓库：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin main</span><br></pre></td></tr></table></figure><p>通过理解工作区、暂存区和版本库的作用及其相互关系，你可以更加高效地使用 Git 进行版本控制和协同开发。</p><hr><h1 id="Git-创建仓库"><a href="#Git-创建仓库" class="headerlink" title="Git 创建仓库"></a>Git 创建仓库</h1><p>可以使用一个已经存在的目录作为 Git 仓库。</p><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。</p><p>在执行完 git init 命令后，Git 仓库会生成一个 git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。</p><p>使用方法：</p><p>进入你想要创建仓库的目录，或者先创建一个新的目录：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my-project</span><br><span class="line"><span class="built_in">cd</span> my-project</span><br></pre></td></tr></table></figure><p>使用当前目录作为 Git 仓库，我们只需要使它初始化：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>该命令执行完后会在当前目录生成一个 .git 目录。</p><p>使用我们指定目录作为 Git 仓库。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git init newrepo</span><br></pre></td></tr></table></figure><p>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m <span class="string">&#x27;初始化项目版本&#x27;</span></span><br></pre></td></tr></table></figure><p>以上命令将目录下 .c 结尾及 README 文件提交到仓库中。</p><blockquote><p>注：在 Linux 系统中，commit 信息使用单引号 <code>&#39; &#39;</code> , Windows 系统中，commit 信息使用双引号 <code>&quot; &quot;</code> 。</p><p>所以在 git bash 中 <code>git commit -m &#39;提交说明&#39;</code> 这样是可以的，在 Windows 命令行中就要使用双引号 <code>git commit -m &quot;提交说明&quot;</code></p></blockquote><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>我们使用 git clone 从现有 Git 仓库中拷贝项目 （类似 svn checkout）</p><p>克隆仓库的命令格式为：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo&gt;</span><br></pre></td></tr></table></figure><p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>repo ：Git 仓库</li><li>directory ：本地目录</li></ul><p>比如，要克隆 Ruby 语言的 Git 代码仓库 Grit ,可以使用下面的命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://github.com/schacon/grit.git</span><br></pre></td></tr></table></figure><p>执行该命令后，会在当前目录下创建一个名为 grit 的目录，其中包含一个 .git 目录，用于保存下载下来的所有版本记录。</p><p>如果自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure><p><strong>配置</strong></p><p>git 的设置使用 git config 命令。</p><p>显示当前的 git 配置信息：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">credential.helper=osxkeychain</span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line">core.ignorecase=<span class="literal">true</span></span><br><span class="line">core.precomposeunicode=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>编辑 git 配置文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git config -e        <span class="comment"># 针对当前仓库</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git config -e --global     <span class="comment"># 针对系统上所有仓库</span></span><br></pre></td></tr></table></figure><p>设置提交代码时的用户信息：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;runoob&quot;</span></span><br><span class="line">$ git config --global user.email <span class="built_in">test</span>@runoob.com</span><br></pre></td></tr></table></figure><p>如果去掉 –global 参数则只对当前仓库有效。</p><hr><h1 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h1><p>Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。</p><p>Git 常用的是以下 6 个命令：<strong>git clone</strong> 、<strong>git push</strong> 、<strong>git add</strong> 、<strong>git commit</strong> 、<strong>git checkout</strong> 、<strong>git pull</strong> </p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2015/02/git-command.jpg" alt="Git 基本操作"></p><p>说明：</p><ul><li>workspace：工作区</li><li>staging area：暂存区 &#x2F; 缓存区</li><li>local repository：版本库或本地仓库</li><li>remote repository：远程仓库</li></ul><p>一个简单的操作步骤：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit</span><br></pre></td></tr></table></figure><ul><li>git init - 初始化仓库</li><li>git add . - 添加文件到暂存区</li><li>git commit - 将暂存区内容添加到仓库中</li></ul><h2 id="创建仓库命令"><a href="#创建仓库命令" class="headerlink" title="创建仓库命令"></a>创建仓库命令</h2><p>下表列出了 git 创建仓库的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git init</code></td><td align="left">初始化仓库</td></tr><tr><td align="left"><code>git clone</code></td><td align="left">拷贝一份远程仓库，也就是下载一个项目。</td></tr></tbody></table><h2 id="提交与修改"><a href="#提交与修改" class="headerlink" title="提交与修改"></a>提交与修改</h2><p>Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。</p><p>下表列出了有关创建与提交你的项目的快照的命令：</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git add</code></td><td align="left">添加文件到暂存区</td></tr><tr><td align="left"><code>git status</code></td><td align="left">查看仓库当前的状态，显示有变更的文件。</td></tr><tr><td align="left"><code>git diff</code></td><td align="left">比较文件的不同，即暂存区和工作区的差异。</td></tr><tr><td align="left"><code>git difftool</code></td><td align="left">使用外部差异工具查看和比较文件的更改。</td></tr><tr><td align="left"><code>git range-diff</code></td><td align="left">比较两个提交范围之间的差异。</td></tr><tr><td align="left"><code>git commit</code></td><td align="left">提交暂存区到本地仓库。</td></tr><tr><td align="left"><code>git reset</code></td><td align="left">回退版本。</td></tr><tr><td align="left"><code>git rm</code></td><td align="left">将文件从暂存区和工作区中删除。</td></tr><tr><td align="left"><code>git mv</code></td><td align="left">移动或重命名工作区文件。</td></tr><tr><td align="left"><code>git notes</code></td><td align="left">添加注释。</td></tr><tr><td align="left"><code>git checkout</code></td><td align="left">分支切换。</td></tr><tr><td align="left"><code>git switch （Git 2.23 版本引入）</code></td><td align="left">更清晰地切换分支。</td></tr><tr><td align="left"><code>git restore （Git 2.23 版本引入）</code></td><td align="left">恢复或撤销文件的更改。</td></tr><tr><td align="left"><code>git show</code></td><td align="left">显示 Git 对象的详细信息。</td></tr></tbody></table><h2 id="提交日志"><a href="#提交日志" class="headerlink" title="提交日志"></a>提交日志</h2><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git log</code></td><td align="left">查看历史提交记录</td></tr><tr><td align="left"><code>git blame &lt;file&gt;</code></td><td align="left">以列表形式查看指定文件的历史修改记录</td></tr><tr><td align="left"><code>git shortlog</code></td><td align="left">生成简洁的提交日志摘要</td></tr><tr><td align="left"><code>git describe</code></td><td align="left">生成一个可读的字符串，该字符串基于 Git 的标签系统来描述当前的提交</td></tr></tbody></table><h2 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h2><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>git remote</code></td><td align="left">远程仓库操作</td></tr><tr><td align="left"><code>git fetch</code></td><td align="left">从远程获取代码库</td></tr><tr><td align="left"><code>git pull</code></td><td align="left">下载远程代码并合并</td></tr><tr><td align="left"><code>git push</code></td><td align="left">上传远程代码并合并</td></tr><tr><td align="left"><code>git submodule</code></td><td align="left">管理包含其他 Git 仓库的项目</td></tr></tbody></table><h2 id="Git-文件状态"><a href="#Git-文件状态" class="headerlink" title="Git 文件状态"></a>Git 文件状态</h2><p>Git 的文件状态分为三种：工作目录 （Working Directory）、暂存区（Staging Area）、本地仓库（Local Repository）。了解这些概念及其交互方式是掌握 Git 的关键。</p><h3 id="工作目录（Working-Directory）"><a href="#工作目录（Working-Directory）" class="headerlink" title="工作目录（Working Directory）"></a>工作目录（Working Directory）</h3><p>工作目录是你在本地计算机上看到的项目文件。它是你实际操作文件的地方，包括查看、编辑、删除和创建文件。所有对文件的更改首先发生在工作目录中。</p><p>在工作目录中的文件可能有以下几种状态：</p><ul><li><strong>未跟踪（Untracked）：</strong>新创建的文件，未被 Git 记录。</li><li><strong>已修改（Modified）：</strong>已被 Git 跟踪的文件发生了更改，但这些更改还没有被提交到 Git 记录中。</li></ul><h3 id="暂存区（Staging-Area）"><a href="#暂存区（Staging-Area）" class="headerlink" title="暂存区（Staging Area）"></a>暂存区（Staging Area）</h3><p>暂存区，也称索引（index），是一个临时存储区域，用于保存即将提交到本地仓库的更改。你可以选择性地将工作目录中的更改添加到暂存区中，这样你可以一次提交多个文件的更改，而不必提交所有文件的更改。</p><ul><li>使用 <code>git add &lt;filename&gt;</code> 命令将文件从工作目录添加到暂存区。</li><li>使用 <code>git add .</code> 命令将当前目录下的所有更改添加到暂存区。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add &lt;filename&gt;  <span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">git add .           <span class="comment"># 添加所有更改到暂存区</span></span><br></pre></td></tr></table></figure><h3 id="本地仓库（Local-Repository）"><a href="#本地仓库（Local-Repository）" class="headerlink" title="本地仓库（Local Repository）"></a>本地仓库（Local Repository）</h3><p>本地仓库是一个隐藏在 .git 目录中的数据库，用于存储项目中的所有提交历史记录，每次你提交更改时，Git 会将暂存区中的内容保存到本地仓库中。</p><p>使用 <code>git commit -m &quot;commit message&quot;</code> 命令将暂存区中的更改提交到本地仓库。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;commit message&quot;</span>  <span class="comment"># 提交暂存区的更改到本地仓库</span></span><br></pre></td></tr></table></figure><h3 id="文件状态转换流程"><a href="#文件状态转换流程" class="headerlink" title="文件状态转换流程"></a>文件状态转换流程</h3><p><strong>未跟踪（Untracked）</strong>：新创建的文件最初是未跟踪的。它们存在与工作目录中，但没有被 Git 跟踪。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">touch</span> newfile.txt         <span class="comment"># 创建一个新文件</span></span><br><span class="line">git status                <span class="comment"># 查看状态，显示 newfile.txt 未跟踪</span></span><br></pre></td></tr></table></figure><p><strong>已跟踪（Tracked）：</strong>通过 <code>git add</code> 命令将未跟踪的文件添加到暂存区后，文件变为已跟踪状态。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add newfile.txt       <span class="comment"># 添加文件到暂存区</span></span><br><span class="line">git status                <span class="comment"># 查看状态，显示 newfile.txt 在暂存区</span></span><br></pre></td></tr></table></figure><p><strong>已修改（Modified）：</strong>对已跟踪的文件进行更改后，这些更改会显示为已修改状态，但这些更改还未添加到暂存区。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, World!&quot;</span> &gt; newfile.txt  <span class="comment"># 修改文件</span></span><br><span class="line">git status                          <span class="comment"># 查看状态，显示 newfile.txt 已修改</span></span><br></pre></td></tr></table></figure><p><strong>已暂存（Staged）：</strong>使用 <code>git add</code> 命令将修改过的文件添加到暂存区后，文件进入已暂存状态，等待提交。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add newfile.txt     <span class="comment"># 添加文件到暂存区</span></span><br><span class="line">git status              <span class="comment"># 显示状态，显示 newfile.txt 已暂存</span></span><br></pre></td></tr></table></figure><p><strong>已提交（Commited）：</strong>使用 <code>git commit</code> 命令将暂存区的更改提交到本地仓库后，这些更改被记录下来，文件状态返回为已跟踪状态。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Added newfile.txt&quot;</span>   <span class="comment"># 提交更改</span></span><br><span class="line">git status                          <span class="comment"># 查看状态，工作目录干净</span></span><br></pre></td></tr></table></figure><hr><h1 id="Git-分支管理"><a href="#Git-分支管理" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h1><p>Git 分支管理是 Git 强大功能之一，能够让多个开发人员并行工作，开发新功能，修复 bug 或进行试验，而不影响主代码效率。</p><p>几乎每一种版本控制系统都以某种形式支持分支，一个分支代表一条独立的开发线。</p><p>使用分支意味着你可以从开发主线分离开来，然后再不影响主线的同时继续工作。</p><p><img src="/img/load.gif" data-original="https://static.jyshare.com/images/svg/git-brance.svg" alt="img"></p><p>Git 分支实际上是指向更改快照的指针。</p><p>有人把 Git 的分支模型成为 <strong>必杀技特性</strong> ，而正式因为它，将 Git 从版本控制系统家族里区分出来。</p><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>创建新分支并切换到该分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b &lt;branchname&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout -b feature-xyz</span><br></pre></td></tr></table></figure><p>切换分支命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout (branchname)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br></pre></td></tr></table></figure><p>当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容，所以多个分支不需要多个目录。</p><h2 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h2><p>查看所有分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>查看远程分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><p>查看所有本地和远程分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><p>将其他分支合并到当前分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git merge &lt;branchname&gt;</span><br></pre></td></tr></table></figure><p>例如，切换到 main 分支合并 feature-xyz 分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge feature-xyz</span><br></pre></td></tr></table></figure><h2 id="解决合并冲突"><a href="#解决合并冲突" class="headerlink" title="解决合并冲突"></a>解决合并冲突</h2><p>当合并过程中出现冲突时，Git 会标记冲突文件，你需要手动解决冲突。</p><p>打开冲突文件，按照标记解决冲突。</p><p>标记冲突解决完成：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add &lt;conflict-flie&gt;</span><br></pre></td></tr></table></figure><p>提交合并结果：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure><h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p>删除本地分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -d &lt;branchname&gt;</span><br></pre></td></tr></table></figure><p>强制删除未合并的分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -D &lt;branchname&gt;</span><br></pre></td></tr></table></figure><p>删除远程分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin --delete &lt;branchname&gt;</span><br></pre></td></tr></table></figure><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>开始前我们先创建一个测试目录：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> gitdemo</span><br><span class="line">$ <span class="built_in">cd</span> gitdemo/</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository...</span><br><span class="line">$ <span class="built_in">touch</span> README</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m <span class="string">&#x27;第一次版本提交&#x27;</span></span><br><span class="line">[master (root-commit) 3b58100] 第一次版本提交</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 README</span><br></pre></td></tr></table></figure><h2 id="Git-分支管理-1"><a href="#Git-分支管理-1" class="headerlink" title="Git 分支管理"></a>Git 分支管理</h2><h3 id="列出分支"><a href="#列出分支" class="headerlink" title="列出分支"></a>列出分支</h3><p>列出分支基本命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>没有参数时，git branch 会列出你在本地的分支。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>此例的意思就是，我们有一个叫做 master 的分支，并且该分支是当前分支。</p><p>当你执行 git init 的时候，默认情况下 Git 就会为你创建 master 分支。</p><p>如果我们要手动创建一个分支，执行 <code>git branch (branchname)</code> 即可。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git branch testing</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br></pre></td></tr></table></figure><p>现在我们可以看到，有了一个新分支 testing。</p><p>当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交，然后又切换到了 testing 分支，Git 将还原你的工作目录到你创建分支的时候的样子。</p><p>接下来我们将演示如何切换分支，我们用 <code>git checkout (branch)</code>切换到我们要修改的分支。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;runoob.com&#x27;</span> &gt; test.txt</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&#x27;add test.txt&#x27;</span></span><br><span class="line">[master 3e92c19] add test.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 test.txt</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README        test.txt</span><br><span class="line">$ git checkout testing</span><br><span class="line">Switched to branch <span class="string">&#x27;testing&#x27;</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README</span><br></pre></td></tr></table></figure><p>当我们切换到 testing 分支的时候，我们添加的新文件 test.txt 被移除了。切换回 master 分支的时候，它们又重新出现了。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure><p>我们也可以使用 <code>git checkout -b (branchname)</code> 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git checkout -b newtest</span><br><span class="line">Switched to a new branch <span class="string">&#x27;newtest&#x27;</span></span><br><span class="line">$ git <span class="built_in">rm</span> test.txt </span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;test.txt&#x27;</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README</span><br><span class="line">$ <span class="built_in">touch</span> runoob.php</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -am <span class="string">&#x27;removed test.txt、add runoob.php&#x27;</span></span><br><span class="line">[newtest c1501a2] removed test.txt、add runoob.php</span><br><span class="line"> 2 files changed, 1 deletion(-)</span><br><span class="line"> create mode 100644 runoob.php</span><br><span class="line"> delete mode 100644 test.txt</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README        runoob.php</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README        test.txt</span><br></pre></td></tr></table></figure><p>如你所见，我们创建了一个新分支，在该分支上移除了一些文件 text.txt ，并添加了 runoob.php 文件，然后切换回我们的主分支，删除的 test.txt 问及那又回来了，且新增加的 runoob.php 不存在主分支中。</p><p>使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。</p><h3 id="删除分支-1"><a href="#删除分支-1" class="headerlink" title="删除分支"></a>删除分支</h3><p>删除分支命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git branch -d (branchname)</span><br></pre></td></tr></table></figure><p>例如我们要删除 testing 分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  testing</span><br><span class="line">$ git branch -d testing</span><br><span class="line">Deleted branch testing (was 85fc7e7).</span><br><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><p>一旦某分支有了独立内容，你终究会希望将他合并回到你的主分支，你也可以使用以下命令将任何分支合并到当前分支中去：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">  newtest</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README        test.txt</span><br><span class="line">$ git merge newtest</span><br><span class="line">Updating 3e92c19..c1501a2</span><br><span class="line">Fast-forward</span><br><span class="line"> runoob.php | 0</span><br><span class="line"> test.txt   | 1 -</span><br><span class="line"> 2 files changed, 1 deletion(-)</span><br><span class="line"> create mode 100644 runoob.php</span><br><span class="line"> delete mode 100644 test.txt</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">README        runoob.php</span><br></pre></td></tr></table></figure><p>以上实例中我们将 newtest 分支合并到主分支区，test.txt 文件被删除。</p><p>合并完后就可以删除分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git branch -d newtest</span><br><span class="line">Deleted branch newtest (was c1501a2)</span><br></pre></td></tr></table></figure><p>删除后，就只剩下 master 分支了：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h2 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h2><p>合并并不仅仅是简单的文件添加和移除操作，Git 也会合并修改。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br><span class="line">$ <span class="built_in">cat</span> runoob.php</span><br></pre></td></tr></table></figure><p>首先，我们创建一个叫做 change_site 的分支，切换过去，我们将 runoob.php 内容改为：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;runoob&#x27;</span>;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>创建 change_site 分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git checkout -b change_site</span><br><span class="line">Switched to a new branch <span class="string">&#x27;change_site&#x27;</span></span><br><span class="line">$ vim runoob.php</span><br><span class="line">$ <span class="built_in">head</span> -3 runoob.php</span><br><span class="line">&lt;?php</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;runoob&#x27;</span>;</span><br><span class="line">?&gt;</span><br><span class="line">$ git commit -am <span class="string">&#x27;changed the runoob.php&#x27;</span></span><br><span class="line">[change_site 7774248] changed the runoob.php</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure><p>将修改的内容提交到 change_site 分支中。现在，加入切换回 master 分支我们可以看内容恢复到我们修改前的（空文件，没有代码），我们再次修改 runoob.php 文件。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">$ <span class="built_in">cat</span> runoob.php</span><br><span class="line">$ vim runoob.php    <span class="comment"># 修改内容如下</span></span><br><span class="line">$ <span class="built_in">cat</span> runoob.php</span><br><span class="line">&lt;?php</span><br><span class="line"><span class="built_in">echo</span> 1;</span><br><span class="line">?&gt;</span><br><span class="line">$ git diff</span><br><span class="line">diff --git a/runoob.php b/runoob.php</span><br><span class="line">index e69de29..ac60739 100644</span><br><span class="line">--- a/runoob.php</span><br><span class="line">+++ b/runoob.php</span><br><span class="line">@@ -0,0 +1,3 @@</span><br><span class="line">+&lt;?php</span><br><span class="line">+<span class="built_in">echo</span> 1;</span><br><span class="line">+?&gt;</span><br><span class="line">$ git commit -am <span class="string">&#x27;修改代码&#x27;</span></span><br><span class="line">[master c68142b] 修改代码</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure><p>现在这些改变已经记录到我的 “master” 分支了。接下来我们将 “change_site” 分支合并过来。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git merge change_site</span><br><span class="line">Auto-merging runoob.php</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> runoob.php</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> runoob.php     <span class="comment"># 打开文件，看到冲突内容</span></span><br><span class="line">&lt;?php</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">echo 1;</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">echo &#x27;runoob&#x27;;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; change_site</span></span><br><span class="line"><span class="string">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们将前一个分支合并到 master 分支，一个合并冲突就出现了，接下来我们需要手动去修改它。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ vim runoob.php </span><br><span class="line">$ <span class="built_in">cat</span> runoob.php</span><br><span class="line">&lt;?php</span><br><span class="line"><span class="built_in">echo</span> 1;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;runoob&#x27;</span>;</span><br><span class="line">?&gt;</span><br><span class="line">$ git diff</span><br><span class="line">diff --cc runoob.php</span><br><span class="line">index ac60739,b63d7d7..0000000</span><br><span class="line">--- a/runoob.php</span><br><span class="line">+++ b/runoob.php</span><br><span class="line">@@@ -1,3 -1,3 +1,4 @@@</span><br><span class="line">  &lt;?php</span><br><span class="line"> +<span class="built_in">echo</span> 1;</span><br><span class="line">+ <span class="built_in">echo</span> <span class="string">&#x27;runoob&#x27;</span>;</span><br><span class="line">  ?&gt;</span><br></pre></td></tr></table></figure><p>在 Git 中，我们可以用 <code>git add</code> 要告诉 Git 文件冲突已经解决</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">UU runoob.php</span><br><span class="line">$ git add runoob.php</span><br><span class="line">$ git status -s</span><br><span class="line">M  runoob.php</span><br><span class="line">$ git commit</span><br><span class="line">[master 88afe0e] Merge branch <span class="string">&#x27;change_site&#x27;</span></span><br></pre></td></tr></table></figure><p>现在我们成功解决了合并中的冲突，并提交了结果。</p><h2 id="命令手册"><a href="#命令手册" class="headerlink" title="命令手册"></a>命令手册</h2><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>用法示例</strong></th></tr></thead><tbody><tr><td align="left"><code>git branch</code></td><td align="left">列出、创建或删除分支。它不切换分支，只是用于管理分支的存在。</td><td align="left"><code>git branch</code>：列出所有分支 <code>git branch new-branch</code>：创建新分支 <code>git branch -d old-branch</code>：删除分支</td></tr><tr><td align="left"><code>git checkout</code></td><td align="left">切换到指定的分支或恢复工作目录中的文件。也可以用来检出特定的提交。</td><td align="left"><code>git checkout branch-name</code>：切换分支 <code>git checkout file.txt</code>：恢复文件到工作区 <code>git checkout &lt;commit-hash&gt;</code>：检出特定提交</td></tr><tr><td align="left"><code>git switch</code></td><td align="left">专门用于切换分支，相比 <code>git checkout</code> 更加简洁和直观，主要用于分支操作。</td><td align="left"><code>git switch branch-name</code>：切换到指定分支 <code>git switch -c new-branch</code>：创建并切换到新分支</td></tr><tr><td align="left"><code>git merge</code></td><td align="left">合并指定分支的更改到当前分支。</td><td align="left"><code>git merge branch-name</code>：将指定分支的更改合并到当前分支</td></tr><tr><td align="left"><code>git mergetool</code></td><td align="left">启动合并工具，以解决合并冲突。</td><td align="left"><code>git mergetool</code>：使用默认合并工具解决冲突 <code>git mergetool --tool=&lt;tool-name&gt;</code>：指定合并工具</td></tr><tr><td align="left"><code>git log</code></td><td align="left">显示提交历史记录。</td><td align="left"><code>git log</code>：显示提交历史 <code>git log --oneline</code>：以简洁模式显示提交历史</td></tr><tr><td align="left"><code>git stash</code></td><td align="left">保存当前工作目录中的未提交更改，并将其恢复到干净的工作区。</td><td align="left"><code>git stash</code>：保存当前更改 <code>git stash pop</code>：恢复最近保存的更改 <code>git stash list</code>：列出所有保存的更改</td></tr><tr><td align="left"><code>git tag</code></td><td align="left">创建、列出或删除标签。标签用于标记特定的提交。</td><td align="left"><code>git tag</code>：列出所有标签 <code>git tag v1.0</code>：创建一个新标签 <code>git tag -d v1.0</code>：删除标签</td></tr><tr><td align="left"><code>git worktree</code></td><td align="left">允许在一个仓库中检查多个工作区，适用于同时处理多个分支。</td><td align="left"><code>git worktree add &lt;path&gt; branch-name</code>：在指定路径添加新的工作区并切换到指定分支 <code>git worktree remove &lt;path&gt;</code>：删除工作区</td></tr></tbody></table><hr><h1 id="Git-查看提交历史"><a href="#Git-查看提交历史" class="headerlink" title="Git 查看提交历史"></a>Git 查看提交历史</h1><p>查看 Git 提交历史可以帮助你了解代码的变更情况和开发进度。</p><p>Git 提供了多种命令和选项来查看提交历史，从简单的日志到详细的差异对比。</p><p>Git 提交历史一般常用两个命令：</p><ul><li><code>git log</code> - 查看历史提交记录</li><li><code>git blame &lt;file&gt;</code> - 以列表形式查看指定文件的历史修改记录。</li></ul><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>在使用 Git 提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用 <code>git log</code> 命令查看。</p><p>git log 命令用于查看 Git 仓库中提交历史记录。</p><p>git log 显示了从最新提交到最早提交的所有提交信息，包括提交的哈希值、作者、提交日期和提交消息等。</p><p>git log 命令的基本语法：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> [选项] [分支名/提交哈希]</span><br></pre></td></tr></table></figure><p>常用的选项包括：</p><ul><li><code>-p</code>：显示提交的补丁（具体更改内容）。</li><li><code>--oneline</code>：以简洁的一行格式显示提交信息。</li><li><code>--graph</code>：以图形化方式显示分支和合并历史。</li><li><code>--decorate</code>：显示分支和标签指向的提交。</li><li><code>--author=&lt;作者&gt;</code>：只显示特定作者的提交。</li><li><code>--since=&lt;时间&gt;</code>：只显示指定时间之后的提交。</li><li><code>--until=&lt;时间&gt;</code>：只显示指定时间之前的提交。</li><li><code>--grep=&lt;模式&gt;</code>：只显示包含指定模式的提交消息。</li><li><code>--no-merges</code>：不显示合并提交。</li><li><code>--stat</code>：显示简略统计信息，包括修改的文件和行数。</li><li><code>--abbrev-commit</code>：使用短提交哈希值。</li><li><code>--pretty=&lt;格式&gt;</code>：使用自定义的提交信息显示格式。</li></ul><p>针对我们前一章节的操作，使用 <strong>git log</strong> 命令列出历史提交记录如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit d5e9fc2c811e0ca2b2d28506ef7dc14171a207d9 (HEAD -&gt; master)</span><br><span class="line">Merge: c68142b 7774248</span><br><span class="line">Author: runoob &lt;<span class="built_in">test</span>@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:55:58 2019 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">&#x27;change_site&#x27;</span></span><br><span class="line"></span><br><span class="line">commit c68142b562c260c3071754623b08e2657b4c6d5b</span><br><span class="line">Author: runoob &lt;<span class="built_in">test</span>@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:52:12 2019 +0800</span><br><span class="line"></span><br><span class="line">    修改代码</span><br><span class="line"></span><br><span class="line">commit 777424832e714cf65d3be79b50a4717aea51ab69 (change_site)</span><br><span class="line">Author: runoob &lt;<span class="built_in">test</span>@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:49:26 2019 +0800</span><br><span class="line"></span><br><span class="line">    changed the runoob.php</span><br><span class="line"></span><br><span class="line">commit c1501a244676ff55e7cccac1ecac0e18cbf6cb00</span><br><span class="line">Author: runoob &lt;<span class="built_in">test</span>@runoob.com&gt;</span><br><span class="line">Date:   Fri May 3 15:35:32 2019 +0800</span><br></pre></td></tr></table></figure><p>我们可以用 –oneline 选项来查看历史记录的简洁的版本。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">d5e9fc2 (HEAD -&gt; master) Merge branch <span class="string">&#x27;change_site&#x27;</span></span><br><span class="line">c68142b 修改代码</span><br><span class="line">7774248 (change_site) changed the runoob.php</span><br><span class="line">c1501a2 removed test.txt、add runoob.php</span><br><span class="line">3e92c19 add test.txt</span><br><span class="line">3b58100 第一次版本提交</span><br></pre></td></tr></table></figure><p>这告诉我们的是，此项目的开发历史。</p><p>我们还可以用 –graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">*   d5e9fc2 (HEAD -&gt; master) Merge branch <span class="string">&#x27;change_site&#x27;</span></span><br><span class="line">|\  </span><br><span class="line">| * 7774248 (change_site) changed the runoob.php</span><br><span class="line">* | c68142b 修改代码</span><br><span class="line">|/  </span><br><span class="line">* c1501a2 removed test.txt、add runoob.php</span><br><span class="line">* 3e92c19 add test.txt</span><br><span class="line">* 3b58100 第一次版本提交</span><br></pre></td></tr></table></figure><p>现在我们可以更清楚明了地看到何时工作分叉、又何时归并。</p><p>你也可以用 <strong>–reverse</strong> 参数来逆向显示所有日志。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --reverse --oneline</span><br><span class="line">3b58100 第一次版本提交</span><br><span class="line">3e92c19 add test.txt</span><br><span class="line">c1501a2 removed test.txt、add runoob.php</span><br><span class="line">7774248 (change_site) changed the runoob.php</span><br><span class="line">c68142b 修改代码</span><br><span class="line">d5e9fc2 (HEAD -&gt; master) Merge branch <span class="string">&#x27;change_site&#x27;</span></span><br></pre></td></tr></table></figure><p>如果只想查找指定用户的提交日志可以使用命令：git log –author , 例如，比方说我们要找 Git 源码中 Linus 提交的部分：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --author=Linus --oneline -5</span><br><span class="line">81b50f3 Move <span class="string">&#x27;builtin-*&#x27;</span> into a <span class="string">&#x27;builtin/&#x27;</span> subdirectory</span><br><span class="line">3bb7256 make <span class="string">&quot;index-pack&quot;</span> a built-in</span><br><span class="line">377d027 make <span class="string">&quot;git pack-redundant&quot;</span> a built-in</span><br><span class="line">b532581 make <span class="string">&quot;git unpack-file&quot;</span> a built-in</span><br><span class="line">112dd51 make <span class="string">&quot;mktag&quot;</span> a built-in</span><br></pre></td></tr></table></figure><p>如果你要指定日期，可以执行几个选项：–since 和 –before，但是你也可以用 –until 和 –after。</p><p>例如，如果我要看 Git 项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了 –no-merges 选项以隐藏合并提交）：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges</span><br><span class="line">5469e2d Git 1.7.1-rc2</span><br><span class="line">d43427d Documentation/remote-helpers: Fix typos and improve language</span><br><span class="line">272a36b Fixup: Second argument may be any arbitrary string</span><br><span class="line">b6c8d2d Documentation/remote-helpers: Add invocation section</span><br><span class="line">5ce4f4e Documentation/urls: Rewrite to accomodate transport::address</span><br><span class="line">00b84e9 Documentation/remote-helpers: Rewrite description</span><br><span class="line">03aa87e Documentation: Describe other situations <span class="built_in">where</span> -z affects git diff</span><br><span class="line">77bc694 rebase-interactive: silence warning when no commits rewritten</span><br><span class="line">636db2c t3301: add tests to use --format=<span class="string">&quot;%N&quot;</span></span><br></pre></td></tr></table></figure><h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><p>限制显示的提交数：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n &lt;number&gt;</span><br></pre></td></tr></table></figure><p>例如，显示最近的 5 次提交：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> -n 5</span><br></pre></td></tr></table></figure><p>显示自指定日期之后的提交：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --since=<span class="string">&quot;2024-01-01&quot;</span></span><br></pre></td></tr></table></figure><p>显示指定日期之前的提交：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --<span class="keyword">until</span>=<span class="string">&quot;2024-07-01&quot;</span></span><br></pre></td></tr></table></figure><p>只显示某个作者的提交：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;Author Name&quot;</span></span><br></pre></td></tr></table></figure><p>更多 <strong>git log</strong> 命令可查看 <a href="http://git-scm.com/docs/git-log">http://git-scm.com/docs/git-log</a> 或使用 <strong>git log –help</strong> 命令查看帮助信息。</p><h2 id="git-blame"><a href="#git-blame" class="headerlink" title="git blame"></a>git blame</h2><p>git blame 命令用于逐行显示指定文件的每一行代码是由谁在什么时候引入或修改的。</p><p>git blame 可以追踪文件中每一行的变更历史，包括作者、提交哈希、提交日期和提交消息等信息。</p><p>如果要查看指定文件的修改记录可以使用 git blame 命令，格式如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git blame [选项] &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><p>常用的选项包括：</p><ul><li><code>-L &lt;起始行号&gt;,&lt;结束行号&gt;</code>：只显示指定行号范围内的代码注释。</li><li><code>-C</code>：对于重命名或拷贝的代码行，也进行代码行溯源。</li><li><code>-M</code>：对于移动的代码行，也进行代码行溯源。</li><li><code>-C -C</code> 或 <code>-M -M</code>：对于较多改动的代码行，进行更进一步的溯源。</li><li><code>--show-stats</code>：显示包含每个作者的行数统计信息。</li></ul><p>显示文件每一行的代码注释和相关信息：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git blame &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><p>只显示指定行号范围内的代码注释：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git blame -L &lt;起始行号&gt;,&lt;结束行号&gt; &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><p>对于重命名或拷贝的代码进行溯源：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git blame -C &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><p>对于移动的代码进行溯源：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git blame -M &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><p>显示行数统计信息：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git blame --show-status &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><p>git blame 命令是以列表形式显示修改记录，如下实例：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git blame README </span><br><span class="line">^d2097aa (tianqixin 2020-08-25 14:59:25 +0800 1) <span class="comment"># Runoob Git 测试</span></span><br><span class="line">db9315b0 (runoob    2020-08-25 16:00:23 +0800 2) <span class="comment"># 菜鸟教程 </span></span><br></pre></td></tr></table></figure><h2 id="恢复和回退"><a href="#恢复和回退" class="headerlink" title="恢复和回退"></a>恢复和回退</h2><p>Git 提供了多种方式来恢复和回退到之前的版本，不同的命令适用于不同的场景和需求。</p><p>以下是几种常见的方法：</p><ul><li><code>git checkout</code>：切换分支或恢复文件到指定提交</li><li><code>git reset</code>：重置当前分支到指定提交（软重置、混合重置、硬重置）。</li><li><code>git revert</code>：创建一个新的提交以撤销指定提交，不改变提交历史。</li><li><code>git reflog</code>：查看历史操作记录，找回丢失的提交。</li></ul><h3 id="1、git-checkout：检查出特定版本的文件"><a href="#1、git-checkout：检查出特定版本的文件" class="headerlink" title="1、git checkout：检查出特定版本的文件"></a>1、git checkout：检查出特定版本的文件</h3><p>git checkout 命令用于切换分支或恢复工作目录中的文件到指定的提交。</p><p>恢复工作目录中的文件到某个提交：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout &lt;commit&gt; -- &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>例如，将 file.txt 恢复到 abc123 提交时的版本：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout abc123 -- file.txt</span><br></pre></td></tr></table></figure><p>切换到特定提交：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout abc123</span><br></pre></td></tr></table></figure><p>这种方式切换到特定的提交时，处于分离头指针（detached HEAD）状态。</p><h3 id="2、git-reset：重置当前分支到特定提交"><a href="#2、git-reset：重置当前分支到特定提交" class="headerlink" title="2、git reset：重置当前分支到特定提交"></a>2、git reset：重置当前分支到特定提交</h3><p>git reset 命令可以更改当前分支的提交历史，它有三种主要模式：–soft、–mixed 和 –hard。</p><p><strong>–soft</strong>：只重置 HEAD 到指定的提交，暂存区和工作目录保持不变。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --soft &lt;commit&gt;</span><br></pre></td></tr></table></figure><p><strong>–mixed（默认）</strong>：重置 HEAD 到指定的提交，暂存区重置，但工作目录保持不变。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --mixed &lt;commit&gt;</span><br></pre></td></tr></table></figure><p><strong>–hard</strong>：重置 HEAD 到指定的提交，暂存区和工作目录都重置。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --hard &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>例如，将当前分支重置到 abc123 提交：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --hard abc123</span><br></pre></td></tr></table></figure><h3 id="3、git-revert：撤销某次提交"><a href="#3、git-revert：撤销某次提交" class="headerlink" title="3、git revert：撤销某次提交"></a>3、git revert：撤销某次提交</h3><p>git revert 命令创建一个新的提交，用来撤销指定的提交，它不会改变提交历史，适用于已经推送到远程仓库的提交。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>例如，撤销 abc123 提交：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git revert abc123</span><br></pre></td></tr></table></figure><h3 id="4、git-reflog：查看历史操作记录"><a href="#4、git-reflog：查看历史操作记录" class="headerlink" title="4、git reflog：查看历史操作记录"></a>4、git reflog：查看历史操作记录</h3><p>git reflog 命令记录了所有 HEAD 的移动。即使提交被删除或重置，也可以通过 reflog 找回。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>利用 reflog 可以找到之前的提交哈希，从而恢复到特定状态。例如：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD@&#123;3&#125;</span><br></pre></td></tr></table></figure><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>以下是一个综合示例，演示如何使用这些命令恢复历史版本：</p><p>查看提交历史：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><p>假设输出如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">abc1234 Commit 1</span><br><span class="line">def5678 Commit 2</span><br><span class="line">ghi9012 Commit 3</span><br></pre></td></tr></table></figure><p>切换到 Commit 2（处于分离头指针状态）：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout def5678</span><br></pre></td></tr></table></figure><p>重置到 Commit 2，保留更改到暂存区：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --soft def5678</span><br></pre></td></tr></table></figure><p>重置到 Commit 2，取消暂存区更改：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --mixed def5678</span><br></pre></td></tr></table></figure><p>重置到 Commit 2，丢弃所有更改：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --hard def5678</span><br></pre></td></tr></table></figure><p>撤销 Commit 2：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git revert def5678</span><br></pre></td></tr></table></figure><p>查看 reflog 找回丢失的提交：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>找到之前的提交哈希并恢复：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD@&#123;3&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="Git-标签"><a href="#Git-标签" class="headerlink" title="Git 标签"></a>Git 标签</h1><p>如果你达到一个重要的阶段，并希望永远记住提交的快照，你可以使用 <strong>git tag</strong> 给它打上标签。</p><p>Git 标签（Tag）用于给仓库中的特定提交点加上标记，通常用于发布版本（如 v1.0, v2.0）。</p><p>比如说，我们想为我们的 runoob 项目发布一个 “1.0” 版本，我们可以用 <strong>git tag -a v1.0</strong> 命令给最新一次提交打上（HEAD） “v1.0” 的标签。</p><p><strong><em>*-a*</em> 选项意为</strong>“创建一个带注解的标签”，不用 <strong>-a</strong> 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解，我们推荐一直创建带注解的标签。</p><p><strong>标签语法格式：</strong></p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag &lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag v1.0</span><br></pre></td></tr></table></figure><p><strong>-a</strong> 选项可以添加注解：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git tag -a v1.0 </span><br></pre></td></tr></table></figure><p>当你执行 git tag -a 命令时，Git 会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。</p><p>现在，注意当我们执行 <strong>git log –decorate</strong> 时，我们可以看到我们的标签了：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">*   d5e9fc2 (HEAD -&gt; master) Merge branch <span class="string">&#x27;change_site&#x27;</span></span><br><span class="line">|\  </span><br><span class="line">| * 7774248 (change_site) changed the runoob.php</span><br><span class="line">* | c68142b 修改代码</span><br><span class="line">|/  </span><br><span class="line">* c1501a2 removed test.txt、add runoob.php</span><br><span class="line">* 3e92c19 add test.txt</span><br><span class="line">* 3b58100 第一次版本提交</span><br></pre></td></tr></table></figure><p>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。</p><p>例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 我们现在也可以：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git tag -a v0.9 85fc7e7</span><br><span class="line">$ git <span class="built_in">log</span> --oneline --decorate --graph</span><br><span class="line">*   d5e9fc2 (HEAD -&gt; master) Merge branch <span class="string">&#x27;change_site&#x27;</span></span><br><span class="line">|\  </span><br><span class="line">| * 7774248 (change_site) changed the runoob.php</span><br><span class="line">* | c68142b 修改代码</span><br><span class="line">|/  </span><br><span class="line">* c1501a2 removed test.txt、add runoob.php</span><br><span class="line">* 3e92c19 add test.txt</span><br><span class="line">* 3b58100 (tag: v0.9) 第一次版本提交</span><br></pre></td></tr></table></figure><p>如果我们要查看所有标签可以使用以下命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure><h3 id="推送标签到远程仓库"><a href="#推送标签到远程仓库" class="headerlink" title="推送标签到远程仓库"></a>推送标签到远程仓库</h3><p>默认情况下，git push 不会推送标签，你需要显式地推送标签。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin &lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>推送所有标签：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure><h3 id="删除轻量标签"><a href="#删除轻量标签" class="headerlink" title="删除轻量标签"></a>删除轻量标签</h3><p>本地删除：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag -d &lt;tagname&gt;</span><br></pre></td></tr></table></figure><p>远程删除：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin --delete &lt;tagname&gt;</span><br></pre></td></tr></table></figure><h3 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h3><p>附注标签存储了创建者的名字、电子邮件、日期，并且可以包含标签信息。附注标签更为正式，适用于需要额外元数据的场景。</p><p>创建附注标签语法：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m <span class="string">&quot;message&quot;</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m <span class="string">&quot;runoob.com标签&quot;</span></span><br></pre></td></tr></table></figure><p>PGP 签名标签命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag -s &lt;tagname&gt; -m <span class="string">&quot;runoob.com标签&quot;</span></span><br></pre></td></tr></table></figure><p>查看标签信息：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git show &lt;tagname&gt;</span><br></pre></td></tr></table></figure><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><p>以下是一个综合示例，演示如何创建、查看、推送和删除标签。</p><p>创建轻量标签和附注标签：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag v1.0</span><br><span class="line">git tag -a v1.1 -m <span class="string">&quot;runoob.com标签&quot;</span></span><br></pre></td></tr></table></figure><p>查看标签和标签信息：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag</span><br><span class="line">git show v1.1</span><br></pre></td></tr></table></figure><p>推送标签到远程仓库：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin v1.0</span><br><span class="line">git push origin v1.1</span><br><span class="line">git push origin --tags  <span class="comment"># 推送所有标签</span></span><br></pre></td></tr></table></figure><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p>本地删除：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git tag -d v1.0</span><br></pre></td></tr></table></figure><p>远程删除：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git push origin --delete v1.0</span><br></pre></td></tr></table></figure><hr><h1 id="Git-Flow"><a href="#Git-Flow" class="headerlink" title="Git Flow"></a>Git Flow</h1><p>Git Flow 是一种基于 Git 的分支模型，旨在帮助团队更好地管理和发布软件。</p><p>Git Flow 由 Vincent Driessen 在 2010 年提出，并通过一套标准的分支命名和工作流程，使开发、测试和发布过程更加有序和高效。</p><p>Git Flow 主要由以下几类分支组成：<code>master</code>、<code>develop</code>、<code>feature</code>、<code>release</code>、<code>hotfix</code>。</p><h2 id="Git-Flow-安装"><a href="#Git-Flow-安装" class="headerlink" title="Git Flow 安装"></a>Git Flow 安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p><strong>Debian&#x2F;Ubuntu:</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install git-flow</span><br></pre></td></tr></table></figure><p><strong>Fedora:</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> dnf install gitflow</span><br><span class="line"><span class="built_in">sudo</span> apt-get install git-flow</span><br></pre></td></tr></table></figure><h3 id="macOS"><a href="#macOS" class="headerlink" title="macOS"></a>macOS</h3><p>在 macOS 上，你可以使用 Homebrew 来安装 Git Flow:</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install git-flow</span><br></pre></td></tr></table></figure><h3 id="源码安装-1"><a href="#源码安装-1" class="headerlink" title="源码安装"></a>源码安装</h3><p>如果你的发行版的包管理器中没有 Git Flow，你也可以从源代码进行安装：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/nvie/gitflow.git</span><br><span class="line"><span class="built_in">cd</span> gitflow</span><br><span class="line"><span class="built_in">sudo</span> make install</span><br></pre></td></tr></table></figure><p>安装完成后，你可以通过以下命令验证 Git Flow 是否成功安装：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git flow version</span><br></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在 Windows 上，你可以通过以下方式安装 Git Flow：</p><ul><li><p><strong>使用 Git for Windows</strong>: Git for Windows 包含了 Git Flow。你可以从 <a href="https://gitforwindows.org/">Git for Windows</a> 安装 Git，然后使用 Git Bash 来使用 Git Flow。</p></li><li><p><strong>使用 Scoop</strong>: 如果你使用 Scoop 包管理工具，可以通过以下命令安装 Git Flow：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">scoop install git-flow</span><br></pre></td></tr></table></figure></li><li><p><strong>使用 Chocolatey</strong>: 如果你使用 Chocolatey 包管理工具，可以通过以下命令安装 Git Flow：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">choco install gitflow</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Git-Flow-分支模型"><a href="#Git-Flow-分支模型" class="headerlink" title="Git Flow 分支模型"></a>Git Flow 分支模型</h2><p><strong><code>master</code> 分支</strong>：</p><ul><li>永远保持稳定和可发布的状态。</li><li>每次发布一个新的版本时，都会从 <code>develop</code> 分支合并到 <code>master</code> 分支。</li></ul><p><strong><code>develop</code> 分支</strong>：</p><ul><li>用于集成所有的开发分支。</li><li>代表了最新的开发进度。</li><li>功能分支、发布分支和修复分支都从这里分支出去，最终合并回这里。</li></ul><p><strong><code>feature</code> 分支</strong>：</p><ul><li>用于开发新功能。</li><li>从 <code>develop</code> 分支创建，开发完成后合并回 <code>develop</code> 分支。</li><li>命名规范：<code>feature/feature-name</code>。</li></ul><p><strong><code>release</code> 分支</strong>：</p><ul><li>用于准备新版本的发布。</li><li>从 <code>develop</code> 分支创建，进行最后的测试和修复，然后合并回 <code>develop</code> 和 <code>master</code> 分支，并打上版本标签。</li><li>命名规范：<code>release/release-name</code>。</li></ul><p><strong><code>hotfix</code> 分支</strong>：</p><ul><li>用于修复紧急问题。</li><li>从 <code>master</code> 分支创建，修复完成后合并回 <code>master</code> 和 <code>develop</code> 分支，并打上版本标签。</li><li>命名规范：<code>hotfix/hotfix-name</code>。</li></ul><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2024/07/git-flow.png" alt="img"></p><h3 id="分支操作原理"><a href="#分支操作原理" class="headerlink" title="分支操作原理"></a>分支操作原理</h3><ul><li>Master 分支上的每个 Commit 应打上 Tag，Develop 分支基于 Master 创建。</li><li>Feature 分支完成后合并回 Develop 分支，并通常删除该分支。</li><li>Release 分支基于 Develop 创建，用于测试和修复 Bug，发布后合并回 Master 和 Develop，并打 Tag 标记版本号。</li><li>Hotfix 分支基于 Master 创建，完成后合并回 Master 和 Develop，并打 Tag 1。</li></ul><h3 id="Git-Flow-命令示例"><a href="#Git-Flow-命令示例" class="headerlink" title="Git Flow 命令示例"></a>Git Flow 命令示例</h3><ul><li>开始 Feature 分支：<code>git flow feature start MYFEATURE</code></li><li>完成 Feature 分支：<code>git flow feature finish MYFEATURE</code></li><li>开始 Release 分支：<code>git flow release start RELEASE [BASE]</code></li><li>完成 Release 分支：合并到 Master 和 Develop，打 Tag，删除 Release 分支。</li><li>开始 Hotfix 分支：<code>git flow hotfix start HOTFIX [BASE]</code></li><li>完成 Hotfix 分支：合并到 Master 和 Develop，打 Tag，删除 Hotfix 分支。</li></ul><h3 id="Git-Flow-工作流程"><a href="#Git-Flow-工作流程" class="headerlink" title="Git Flow 工作流程"></a>Git Flow 工作流程</h3><h4 id="1-初始化-Git-Flow"><a href="#1-初始化-Git-Flow" class="headerlink" title="1. 初始化 Git Flow"></a>1. 初始化 Git Flow</h4><p>首先，在项目中初始化 Git Flow。可以使用 Git Flow 插件（例如 <code>git-flow</code>）来简化操作。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git flow init</span><br></pre></td></tr></table></figure><p>初始化时，你需要设置分支命名规则和默认分支。</p><h4 id="2-创建功能分支"><a href="#2-创建功能分支" class="headerlink" title="2. 创建功能分支"></a>2. 创建功能分支</h4><p>当开始开发一个新功能时，从 <code>develop</code> 分支创建一个功能分支。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git flow feature start feature-name</span><br></pre></td></tr></table></figure><p>完成开发后，将功能分支合并回 <code>develop</code> 分支，并删除功能分支。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git flow feature finish feature-name</span><br></pre></td></tr></table></figure><h4 id="3-创建发布分支"><a href="#3-创建发布分支" class="headerlink" title="3. 创建发布分支"></a>3. 创建发布分支</h4><p>当准备发布一个新版本时，从 <code>develop</code> 分支创建一个发布分支。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git flow release start release-name</span><br></pre></td></tr></table></figure><p>在发布分支上进行最后的测试和修复，准备好发布后，将发布分支合并回 <code>develop</code> 和 <code>master</code> 分支，并打上版本标签。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git flow release finish release-name</span><br></pre></td></tr></table></figure><h4 id="4-创建修复分支"><a href="#4-创建修复分支" class="headerlink" title="4. 创建修复分支"></a>4. 创建修复分支</h4><p>当发现需要紧急修复的问题时，从 <code>master</code> 分支创建一个修复分支。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git flow hotfix start hotfix-name</span><br></pre></td></tr></table></figure><p>修复完成后，将修复分支合并回 <code>master</code> 和 <code>develop</code> 分支，并打上版本标签。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git flow hotfix finish hotfix-name</span><br></pre></td></tr></table></figure><h3 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h3><p>以下是一个实际使用 Git Flow 的综合实例。</p><p><strong>初始化 Git Flow</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git flow init</span><br></pre></td></tr></table></figure><p><strong>创建和完成功能分支</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git flow feature start new-feature <span class="comment"># 开发新功能</span></span><br><span class="line">git flow feature finish new-feature</span><br></pre></td></tr></table></figure><p><strong>创建和完成发布分支</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git flow release start v1.0.0 <span class="comment"># 测试和修复</span></span><br><span class="line">git flow release finish v1.0.0</span><br></pre></td></tr></table></figure><p><strong>创建和完成修复分支</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git flow hotfix start hotfix-1.0.1. <span class="comment"># 修复紧急问题</span></span><br><span class="line">git flow hotfix finish hotfix-1.0.1</span><br></pre></td></tr></table></figure><h3 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h3><p><strong>优点</strong></p><ul><li><strong>明确的分支模型</strong>：清晰的分支命名和使用规则，使得开发过程井然有序。</li><li><strong>隔离开发和发布</strong>：开发和发布过程分离，减少了开发中的不确定性对发布的影响。</li><li><strong>版本管理</strong>：每次发布和修复都会打上版本标签，方便回溯和管理。</li></ul><p><strong>缺点</strong></p><ul><li><strong>复杂性</strong>：对于小型团队或简单项目，Git Flow 的分支模型可能显得过于复杂。</li><li><strong>频繁的合并</strong>：在大型团队中，频繁的分支合并可能导致合并冲突增加。</li></ul><p>Git Flow 是一种结构化的分支管理模型，通过定义明确的分支和工作流程，帮助团队更好地管理软件开发和发布过程。虽然它增加了一定的复杂性，但对于大型项目和团队协作，Git Flow 提供了强大的支持和管理能力。</p><hr><h1 id="Git-进阶操作"><a href="#Git-进阶操作" class="headerlink" title="Git 进阶操作"></a>Git 进阶操作</h1><p>在掌握了 Git 的基础操作之后，进阶操作可以帮助你更高效地管理和优化你的代码库。</p><p>以下是一些常见的进阶操作及其详细说明：</p><ul><li><strong>交互式暂存</strong>：逐块选择要暂存的更改，精细控制提交内容。</li><li><strong>Git Stash</strong>：临时保存工作进度，方便切换任务。</li><li><strong>Git Rebase</strong>：将一个分支上的更改移到另一个分支之上，保持提交历史线性。</li><li><strong>Git Cherry-Pick</strong>：选择特定提交并应用到当前分支。</li></ul><h3 id="1、交互式暂存（Interactive-Staging）"><a href="#1、交互式暂存（Interactive-Staging）" class="headerlink" title="1、交互式暂存（Interactive Staging）"></a>1、交互式暂存（Interactive Staging）</h3><p><code>git add</code> 命令可以选择性地将文件或文件的一部分添加到暂存区，这在处理复杂更改时非常有用。</p><ul><li>**使用 <code>git add -p</code>**：逐块选择要暂存的更改。</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add -p</span><br></pre></td></tr></table></figure><p>执行此命令后，Git 会逐块显示文件的更改，你可以选择是否暂存每个块。常用选项包括：</p><ul><li><code>y</code>：暂存当前块</li><li><code>n</code>：跳过当前块</li><li><code>s</code>：拆分当前块</li><li><code>e</code>：手动编辑当前块</li><li><code>q</code>：退出暂存</li></ul><h3 id="2、Git-Stash：临时保存工作进度"><a href="#2、Git-Stash：临时保存工作进度" class="headerlink" title="2、Git Stash：临时保存工作进度"></a>2、Git Stash：临时保存工作进度</h3><p><code>git stash</code> 命令允许你临时保存当前工作目录的更改，以便你可以切换到其他分支或处理其他任务。</p><p><strong>保存当前工作进度</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p><strong>查看存储的进度</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p><strong>应用最近一次存储的进度</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure><p><strong>应用并删除最近一次存储的进度</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure><p><strong>删除特定存储</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash drop stash@&#123;n&#125;</span><br></pre></td></tr></table></figure><p><strong>清空所有存储</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash clear</span><br></pre></td></tr></table></figure><h3 id="3、Git-Rebase：变基"><a href="#3、Git-Rebase：变基" class="headerlink" title="3、Git Rebase：变基"></a>3、Git Rebase：变基</h3><p><code>git rebase</code> 命令用于将一个分支上的更改移到另一个分支之上。它可以帮助保持提交历史的线性，减少合并时的冲突。</p><p><strong>变基当前分支到指定分支</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rebase &lt;branchname&gt;</span><br></pre></td></tr></table></figure><p>例如，将当前分支变基到 <code>main</code> 分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rebase main</span><br></pre></td></tr></table></figure><ul><li><strong>交互式变基</strong>：</li></ul><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rebase -i &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>交互式变基允许你在变基过程中编辑、删除或合并提交。常用选项包括：</p><ul><li><code>pick</code>：保留提交</li><li><code>reword</code>：修改提交信息</li><li><code>edit</code>：编辑提交</li><li><code>squash</code>：将当前提交与前一个提交合并</li><li><code>fixup</code>：将当前提交与前一个提交合并，不保留提交信息</li><li><code>drop</code>：删除提交</li></ul><h3 id="4、Git-Cherry-Pick：拣选提交"><a href="#4、Git-Cherry-Pick：拣选提交" class="headerlink" title="4、Git Cherry-Pick：拣选提交"></a>4、Git Cherry-Pick：拣选提交</h3><p><code>git cherry-pick</code> 命令允许你选择特定的提交并将其应用到当前分支。它在需要从一个分支移植特定更改到另一个分支时非常有用。</p><p><strong>拣选提交</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git cherry-pick &lt;commit&gt;</span><br></pre></td></tr></table></figure><p>例如，将 <code>abc123</code> 提交应用到当前分支：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git cherry-pick abc123</span><br></pre></td></tr></table></figure><p><strong>处理拣选冲突</strong>：如果拣选过程中出现冲突，解决冲突后使用 <code>git cherry-pick --continue</code> 继续拣选。</p><h3 id="示例操作"><a href="#示例操作" class="headerlink" title="示例操作"></a>示例操作</h3><p>以下是一个综合示例，展示了如何使用这些进阶操作：</p><p><strong>交互式暂存</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git add -p</span><br></pre></td></tr></table></figure><p><strong>保存工作进度</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure><p><strong>查看存储的进度</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure><p><strong>应用存储的进度</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git stash apply</span><br></pre></td></tr></table></figure><p><strong>变基当前分支到 <code>main</code> 分支</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rebase main</span><br></pre></td></tr></table></figure><p><strong>交互式变基，编辑提交历史</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br></pre></td></tr></table></figure><p>编辑提交历史，如合并和重命名提交。</p><p><strong>拣选 <code>feature</code> 分支上的特定提交到 <code>main</code> 分支</strong>：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git cherry-pick abc123</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud微服务项目</title>
      <link href="/posts/6ed5eebe.html"/>
      <url>/posts/6ed5eebe.html</url>
      
        <content type="html"><![CDATA[<h1 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h1><h2 id="1-前端项目"><a href="#1-前端项目" class="headerlink" title="1.前端项目"></a>1.前端项目</h2><ul><li>采用 <strong>Vue3 + TS + ElementPlus</strong></li></ul><h2 id="2-后端项目结构"><a href="#2-后端项目结构" class="headerlink" title="2.后端项目结构"></a>2.后端项目结构</h2><ul><li>采用插件化 + 扩展包形式 结构解耦 已于扩展</li></ul><h2 id="3-后端代码风格"><a href="#3-后端代码风格" class="headerlink" title="3.后端代码风格"></a>3.后端代码风格</h2><ul><li>严格遵守 <strong>Alibaba</strong> 规范与项目统一配置的代码格式化</li></ul><h2 id="4-分布式注册中心"><a href="#4-分布式注册中心" class="headerlink" title="4.分布式注册中心"></a>4.分布式注册中心</h2><ul><li><strong>Alibaba Nacos</strong></li></ul><h2 id="5-分布式配置中心"><a href="#5-分布式配置中心" class="headerlink" title="5.分布式配置中心"></a>5.分布式配置中心</h2><ul><li><strong>Alibaba Nacos</strong></li></ul><h2 id="6-服务网关"><a href="#6-服务网关" class="headerlink" title="6.服务网关"></a>6.服务网关</h2><ul><li><strong>SpringCloud Gateway</strong></li></ul><h2 id="7-负载均衡"><a href="#7-负载均衡" class="headerlink" title="7.负载均衡"></a>7.负载均衡</h2><ul><li><strong>SpringCloud Loadbalancer</strong></li></ul><h2 id="8-RPC-远程调用"><a href="#8-RPC-远程调用" class="headerlink" title="8.RPC 远程调用"></a>8.RPC 远程调用</h2><ul><li><strong>Apache Dubbo 3.x</strong></li><li><strong>OpenFeign</strong></li></ul><h2 id="9-分布式限流熔断"><a href="#9-分布式限流熔断" class="headerlink" title="9.分布式限流熔断"></a>9.分布式限流熔断</h2><ul><li><strong>Alibaba Sentinel</strong></li></ul><h2 id="10-分布式事务"><a href="#10-分布式事务" class="headerlink" title="10.分布式事务"></a>10.分布式事务</h2><ul><li><strong>Alibaba Seata</strong></li></ul><h2 id="11-Web-容器"><a href="#11-Web-容器" class="headerlink" title="11.Web 容器"></a>11.Web 容器</h2><ul><li>采用 <strong>Undertow</strong> 基于 <strong>XNIO</strong> 的高性能容器</li></ul><h2 id="12-权限认证"><a href="#12-权限认证" class="headerlink" title="12.权限认证"></a>12.权限认证</h2><ul><li><strong>Sa-Token</strong></li><li><strong>Spring Security</strong></li></ul><h2 id="13-权限注解"><a href="#13-权限注解" class="headerlink" title="13.权限注解"></a>13.权限注解</h2><ul><li><strong>Sa-Token</strong></li><li><strong>Spring Security</strong></li></ul><h2 id="14-关系型数据库"><a href="#14-关系型数据库" class="headerlink" title="14.关系型数据库"></a>14.关系型数据库</h2><ul><li><strong>MySQL</strong></li><li><strong>Oracle</strong></li><li><strong>PostgreSQL</strong></li><li><strong>SQLServer</strong></li><li>使用异构切换（支持 <strong>mybatis-plus</strong> 支持的所有数据库）</li></ul><h2 id="15-缓存数据库"><a href="#15-缓存数据库" class="headerlink" title="15.缓存数据库"></a>15.缓存数据库</h2><ul><li><strong>Redis</strong></li></ul><h2 id="16-Redis客户端"><a href="#16-Redis客户端" class="headerlink" title="16.Redis客户端"></a>16.Redis客户端</h2><ul><li><strong>Redisson</strong></li></ul><h2 id="17-缓存注解"><a href="#17-缓存注解" class="headerlink" title="17.缓存注解"></a>17.缓存注解</h2><ul><li><strong>Spring-Cache</strong></li></ul><h2 id="18-ORM-框架"><a href="#18-ORM-框架" class="headerlink" title="18.ORM 框架"></a>18.ORM 框架</h2><ul><li><strong>Mybatis-Plus</strong></li></ul><h2 id="19-SQL-监控"><a href="#19-SQL-监控" class="headerlink" title="19.SQL 监控"></a>19.SQL 监控</h2><ul><li><strong>p6spy</strong></li></ul><h2 id="20-数据分页"><a href="#20-数据分页" class="headerlink" title="20.数据分页"></a>20.数据分页</h2><ul><li><strong>Mybatis-Plus</strong> 分页插件</li></ul><h2 id="21-数据权限"><a href="#21-数据权限" class="headerlink" title="21.数据权限"></a>21.数据权限</h2><ul><li>采用 <strong>Mybatis-Plus</strong> 插件，自行分析拼接 <strong>SQL</strong> 无感式过滤，只需要为 <strong>Mapper</strong> 设置好注解条件 支持多种自定义 不限于部门角色</li></ul><h2 id="22-数据脱敏"><a href="#22-数据脱敏" class="headerlink" title="22.数据脱敏"></a>22.数据脱敏</h2><ul><li>注解 + <strong>jackson</strong></li></ul><h2 id="23-多数据源框架"><a href="#23-多数据源框架" class="headerlink" title="23.多数据源框架"></a>23.多数据源框架</h2><ul><li><strong>dynamic-datasource</strong></li></ul><h2 id="24-多数据源事务"><a href="#24-多数据源事务" class="headerlink" title="24.多数据源事务"></a>24.多数据源事务</h2><ul><li><strong>dynamic-datasource</strong></li></ul><h2 id="25-数据库连接池"><a href="#25-数据库连接池" class="headerlink" title="25.数据库连接池"></a>25.数据库连接池</h2><ul><li><strong>HikariCP</strong></li></ul><h2 id="26-数据库主键"><a href="#26-数据库主键" class="headerlink" title="26.数据库主键"></a>26.数据库主键</h2><ul><li>采用 <strong>雪花ID 基于时间戳的 有序增长 唯一ID</strong></li></ul><h2 id="27-WebSocket协议"><a href="#27-WebSocket协议" class="headerlink" title="27.WebSocket协议"></a>27.WebSocket协议</h2><ul><li>基于 Spring 封装的 WebSocket 协议，扩展 Token 鉴权与分布式会话，不局限于单机</li></ul><h2 id="28-SSE-推送"><a href="#28-SSE-推送" class="headerlink" title="28.SSE 推送"></a>28.SSE 推送</h2><ul><li><strong>Spring SSE</strong></li></ul><h2 id="29-序列化"><a href="#29-序列化" class="headerlink" title="29.序列化"></a>29.序列化</h2><ul><li><strong>Jackson</strong></li></ul><h2 id="30-分布式幂等"><a href="#30-分布式幂等" class="headerlink" title="30.分布式幂等"></a>30.分布式幂等</h2><ul><li>美团 <strong>GTIS</strong></li></ul><h2 id="31-分布式任务调度"><a href="#31-分布式任务调度" class="headerlink" title="31.分布式任务调度"></a>31.分布式任务调度</h2><ul><li><strong>SnailJob</strong></li><li><strong>XxlJob</strong></li></ul><h2 id="32-分布式日志中心"><a href="#32-分布式日志中心" class="headerlink" title="32.分布式日志中心"></a>32.分布式日志中心</h2><ul><li><strong>ELK</strong></li></ul><h2 id="33-分布式搜索引擎"><a href="#33-分布式搜索引擎" class="headerlink" title="33.分布式搜索引擎"></a>33.分布式搜索引擎</h2><ul><li>采用 ElasticSearch 、Easy-Es 以 Mybatis-Plus 方式操作 ElasticSearch</li></ul><h2 id="34-分布式消息队列"><a href="#34-分布式消息队列" class="headerlink" title="34.分布式消息队列"></a>34.分布式消息队列</h2><ul><li><strong>Kafaka</strong></li><li><strong>RockketMQ</strong></li><li><strong>RabbitMQ</strong></li></ul><h2 id="35-分布式消息总线"><a href="#35-分布式消息总线" class="headerlink" title="35.分布式消息总线"></a>35.分布式消息总线</h2><ul><li>采用 SpringCloud Bus 实现事件总线 跨服务通知，支持 Kafaka 、RocketMQ 、RabbitM!Q</li></ul><h2 id="36-分库分表功能"><a href="#36-分库分表功能" class="headerlink" title="36.分库分表功能"></a>36.分库分表功能</h2><ul><li><strong>Apache Sharding-Proxy</strong></li></ul><h2 id="37-文件存储"><a href="#37-文件存储" class="headerlink" title="37.文件存储"></a>37.文件存储</h2><ul><li>采用 <strong>Minio</strong> 分布式文件存储 支持 七牛、阿里、腾讯 等一切支持 <strong>S3</strong> 协议的厂家</li></ul><h2 id="38-短信"><a href="#38-短信" class="headerlink" title="38.短信"></a>38.短信</h2><ul><li><strong>sms</strong></li></ul><h2 id="39-邮件"><a href="#39-邮件" class="headerlink" title="39.邮件"></a>39.邮件</h2><ul><li><strong>mail-api</strong></li></ul><h2 id="40-接口文档"><a href="#40-接口文档" class="headerlink" title="40.接口文档"></a>40.接口文档</h2><ul><li><strong>SpringDoc javadoc</strong></li><li><strong>swagger2 knife4j</strong></li></ul><h2 id="41-校验框架"><a href="#41-校验框架" class="headerlink" title="41.校验框架"></a>41.校验框架</h2><ul><li><strong>Validation</strong></li></ul><h2 id="42-Excel-框架"><a href="#42-Excel-框架" class="headerlink" title="42.Excel 框架"></a>42.Excel 框架</h2><ul><li><strong>Alibaba EasyExcel</strong></li></ul><h2 id="43-工作流支持"><a href="#43-工作流支持" class="headerlink" title="43.工作流支持"></a>43.工作流支持</h2><ul><li><strong>Flowable</strong></li><li><strong>activiti</strong></li></ul><h2 id="44-工具类框架"><a href="#44-工具类框架" class="headerlink" title="44.工具类框架"></a>44.工具类框架</h2><ul><li><strong>Hutool</strong></li><li><strong>Lombok</strong></li></ul><h2 id="45-服务监控框架"><a href="#45-服务监控框架" class="headerlink" title="45.服务监控框架"></a>45.服务监控框架</h2><ul><li><strong>Spring-Admin</strong></li></ul><h2 id="46-全方位监控报警"><a href="#46-全方位监控报警" class="headerlink" title="46.全方位监控报警"></a>46.全方位监控报警</h2><ul><li><strong>Prometheus  Grafana</strong></li></ul><h2 id="47-链路追踪"><a href="#47-链路追踪" class="headerlink" title="47.链路追踪"></a>47.链路追踪</h2><ul><li><strong>Apache SkyWalking</strong></li></ul><h2 id="48-代码生成器"><a href="#48-代码生成器" class="headerlink" title="48.代码生成器"></a>48.代码生成器</h2><ul><li>只需设计好表结构 一键生成所有 CRUD 代码页面</li><li>降低 80% 的开发量，把精力投入业务涉及上</li><li>框架为其适配 MP、SpringDoc 规范化代码，同时支持动态多数据源代码生成</li></ul><h2 id="49-部署方式"><a href="#49-部署方式" class="headerlink" title="49.部署方式"></a>49.部署方式</h2><ul><li><strong>Docker</strong></li></ul><h2 id="50-国际化"><a href="#50-国际化" class="headerlink" title="50.国际化"></a>50.国际化</h2>]]></content>
      
      
      <categories>
          
          <category> 程序员 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java架构师成长路径图</title>
      <link href="/posts/621998ca.html"/>
      <url>/posts/621998ca.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/load.gif" data-original="https://pic3.zhimg.com/v2-f4dcb6e49d978a81b787ff845fcc60c2_720w.jpg?source=172ae18b" alt="https://pic3.zhimg.com/v2-f4dcb6e49d978a81b787ff845fcc60c2_720w.jpg?source=172ae18b"></p><h1 id="Java-架构师之路"><a href="#Java-架构师之路" class="headerlink" title="Java 架构师之路"></a>Java 架构师之路</h1><p>架构师的内功主要包括三部分：<strong>判断力、执行力、创新力</strong>，简单解释如下：</p><ol><li>判断力：能够准确判断系统的复杂度在哪里，就像武侠高手一样，能够准确地看出对手的破绽和弱点。</li><li>执行力：能够使用合适的方案去解决复杂度问题，就像武侠高手一样，能选择合适的招式或者方法打败对手。</li><li>创新里：能够创造新的解决方案解决复杂度问题，就像武侠世界里，小一些的创新是创新招式，而武学宗师能够创立新的武学或者心法，例如张三丰创立太极拳一样。</li></ol><p>因此，要成为一个优秀的架构师，就需要不断提升自己这几方面的内功，而者三方面的能力来源于 <strong>经验、视野、思考</strong>。</p><ol><li>经验：设计的系统越多，系统越复杂，架构师的内功也就越强，不管是成功的架构，还是失败的架构，不管是踩坑的经验，还是填坑的经验，都将成为架构师内功的一部分。</li><li>视野：掌握的知识和技能越多、越深，架构师的内功也就越强，他山之石可以攻玉，站在巨人的肩膀上会看的更高更远。</li><li>思考：经验和视野都是外部输入，类似于我们吃的食物，但光吃还不行，还要消化，将其变为我们自己的营养，这就是思考的作用，思考能将部分经验和视野中的模式、判断、选择、技巧等提炼出来为我们所用，思考也能促使我们产生新的创意和灵感。</li></ol><p>结合上面的分析，从程序员到架构师的成长之路，总的指导原则是：积累经验、拓展视野、深度思考。按照这个总的原则为指导，接下来我们看看从程序员到架构师的成长过程中，具体如何实践。</p><p>程序员到架构师的技术成长之路分为几个典型的阶段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">工程师 - 高级工程师 - 技术专家 - 初级架构师 - 中级架构师 - 高级架构师</span><br></pre></td></tr></table></figure><p>虽然总的指导原则是一样的，但具体的实践方法有很大差别，如果在正确的姐u的那采取了错误的方法，可能会出现事倍功半的问题。</p><hr><h1 id="第一步：工程师"><a href="#第一步：工程师" class="headerlink" title="第一步：工程师"></a>第一步：工程师</h1><h2 id="1-阶段描述"><a href="#1-阶段描述" class="headerlink" title="1.阶段描述"></a>1.阶段描述</h2><p>成为一个合格的工程师需要 1~3 年时间，其典型特征是 ”在别人的指导下完成开发“ ，这里的 ”别人“ 主要是 ”高级工程师“ 或者 ”技术专家“ ，通常情况下，高级工程师或者技术专家负责需求分析和过程讨论、方案设计，工程师则负责编码实现，高级工程师或者技术专家会指导工程师进行编码实现。</p><h2 id="2-成长指导"><a href="#2-成长指导" class="headerlink" title="2.成长指导"></a>2.成长指导</h2><p>工程师阶段是最原始的 <strong>基础技能积累阶段</strong> ，主要积累基础知识，包括编程语言、编程工具、各类系统的基本使用。以 Java 后端工程师为例，工程师阶段需要积累的经验和技能有：</p><ul><li>Java 的语法、基本数据结构的使用。</li><li>Eclipse、IDEA、Maven、Linux 命令行等各种工具。</li><li>数据库 CRUD 操作、缓存的基本使用等。</li><li>业务系统的基本流程。</li></ul><p>工程师阶段最好的学习方法就是，找经典的书籍系统地学习，而不是遇到一个问题到网上搜搜然后就解决了事。以 Java 为例，《Java 编程思想》《Java 核心技术》《TCP&#x2F;IP 协议》这类大部头，一定要完整地看一遍，即使里面很多内容当前工作暂时用不上。</p><hr><h1 id="第二步：高级工程师"><a href="#第二步：高级工程师" class="headerlink" title="第二步：高级工程师"></a>第二步：高级工程师</h1><h2 id="1-阶段描述-1"><a href="#1-阶段描述-1" class="headerlink" title="1.阶段描述"></a>1.阶段描述</h2><p>成为高级工程师需要 2~5 年，其典型特征是 <strong>独立完成开发</strong> ，包括需求分析、方案设计、编码实现，其中需求分析和方案设计已经包含了 <strong>判断</strong> 和 <strong>选择</strong>，只是范围相对于来说小一些，更多是在已有架构下进行设计。以 Java 后端工程师为例，高级工程师需要完成的工作包括：</p><ul><li>MySQL 数据库表如何设计，是设计成两个表还是三个表？</li><li>是否要使用缓存，缓存的 Key 和 Value 如何设计，缓存的更新策略是什么？</li><li>产品提出的需求是否合理？是否有更好的方式来满足？</li></ul><h2 id="2-成长指导-1"><a href="#2-成长指导-1" class="headerlink" title="2.成长指导"></a>2.成长指导</h2><p>从普通工程师成长为高级工程师，主要需要 <strong>积累方案设计经验</strong> ，简单来说就是业务当前用到德相关技术德设计经验。以 Java 后端工程师为例，包括：表设计经验、缓存设计经验、业务流程设计经验、接口设计经验等。当接到一个业务需求德时候，高级工程师柠檬狗组合这些设计经验，最终完成业务需求。</p><p>高级工程师阶段相比于工程师阶段，有两个典型的差异：</p><ul><li>深度：如果说工程师是要求知道 How ，那高级工程师就要求知道 Why 了。例如 Java 的各种数据结构的实现原理，因为只有深入掌握了这些实现原理，才能对其优缺点和使用场景有深刻理解，这样在做具体方案设计的时候才能够选择合适的数据结构。</li><li>理论：理论就是前人总结出来的成熟的设计经验，例如数据库设计的  3 个范式、面向对象的设计模式、SOLID 设计原则、缓存设计理论 (缓存穿透、缓存雪崩、缓存热点) 等。</li></ul><p>针对技术深度，建议去进行系统地学习，包括看书和研究源码。例如研究 Java 虚拟机可以看《深入理解 Java 虚拟机》、研究 MySQL 可以看《MySQL 技术内幕：InnoDB 存储引擎》、研究 Memcache 可以去看其源码。</p><p>针对设计理论，由于涉及的点很多，没有一本书能够涵盖这么多的设计点，因此更多的是依靠自己去网上搜索资料学习、那么我们怎么知道哪些地方有设计理论呢？简单来说，就是假设每个环节都有设计理论，然后带着这种假设去搜索验证看看是否真的有很成熟的设计理念。</p><hr><h1 id="第三步：技术专家"><a href="#第三步：技术专家" class="headerlink" title="第三步：技术专家"></a>第三步：技术专家</h1><h2 id="1-阶段描述-2"><a href="#1-阶段描述-2" class="headerlink" title="1.阶段描述"></a>1.阶段描述</h2><p>成长为技术专家需要 4~8  年时间，其典型的特征是 ”某个领域的专家“ ，通俗地讲，只要是这个领域的问题，技术专家都可以解决。例如 Java 开发专家、PHP 开发专家、Android 开发专家、iOS 开发专家、前端开发专家等等。通常情况下，”领域“ 的范围不能太小，例如我们可以说 ”Java 开发专家“，但不会说 ”Java 多线程专家“ 或 ”Java JDBC 专家“ 。</p><p>技术专家与高级工程师的一个典型区别就是，高级工程师主要是在已有的架构框架下完成设计，而技术专家会根据需要修改、扩展、优化架构。例如，同样是 Java 开发，高级工程师关注的是如何优化 MySQL 的查询性能，而技术专家就会考虑引入 Elasticsearch 来完成搜索。</p><h2 id="2-成长指导-2"><a href="#2-成长指导-2" class="headerlink" title="2.成长指导"></a>2.成长指导</h2><p>从高级工程师成长为技术专家，主要需要 <strong>拓展技术宽度</strong> ，因为一个 <strong>领域</strong> 必然会涉及众多的技术面。以 Java 后端开发为例，要成为一个 Java 开发专家，需要掌握 Java 多线程、JDBC 、Java 虚拟机、面向对象、设计模式、Netty、Elasrucsearch、Memcache、Redis、MySQL 等众多技术。常见的拓展技术宽度的方法有：</p><ul><li>学习业界成熟的开源方案，例如，Java 开发可以去学习 Redis、Memcache、Netty 等，Android 开发可以去研究 Retrofit、Fresco、OkHttp 等。</li><li>研究业界的经验分享，例如 BAT、FANG 等大公司的经验，可以通过参加技术大会等方式去近距离了解。</li></ul><p>需要注意的是，拓展技术宽度并不意味着仅仅只是知道一个技术名词，而是要深入去理解每个技术的原理、优缺点、应用场景，否则就会成为传说中的“PPT 技术专家”。例如，以 Java 开发为例，知道 Netty 是个高性能网络库是远远不够的，还需要学习 Netty 的原理，以及具体如何使用 Netty 来开发高性能系统。</p><hr><h1 id="第四步：初级架构师"><a href="#第四步：初级架构师" class="headerlink" title="第四步：初级架构师"></a>第四步：初级架构师</h1><h2 id="1-阶段描述-3"><a href="#1-阶段描述-3" class="headerlink" title="1.阶段描述"></a>1.阶段描述</h2><p>成长为初级架构师需要 5~10 年，其典型特征就是能够 <strong>独立完成一个系统的设计</strong> ，可以是从 0 到 1 设计一个新系统，也可以是将架构从 1.0 重构到 2.0 。初级架构师负责的系统复杂度相对来说不高，例如后台管理系统、某个业务下的子系统、100 万 PV 量级的网站等。</p><p>初级架构师和技术专家的典型区别是：架构师是基于完善的架构设计方法论的指导来进行架构设计，而技术专家更多的是基于经验进行架构设计。简单来说，即使是同样一个方案，初级架构师能够清晰地阐述架构设计的理由和原因，而技术专家可能就是因为自己曾经这样做过，或者看别人这样做过而选择设计方案。</p><p>但在实践工作中，技术专家和初级架构师的区别并不是很明显，事实上很多技术专家其实就承担了初级架构师的角色，因为在系统复杂度相对不高的情况下，架构设计的难度不高，用不同的备选方案最终都能够较好的完成系统设计。例如，设计一个日 PV 100 万的网站，MySQL + Memcache + Spring Boot 可以很好地完成，MongoDB + Redis + Nginx + php-fpm 也可以很好地完成，备选方案设计和选择并不太难，更多的是看团队熟悉哪个技术。</p><h2 id="2-成长指导-3"><a href="#2-成长指导-3" class="headerlink" title="2.成长指导"></a>2.成长指导</h2><p>从技术专家成长为初级架构师，最主要的是形成自己的 <strong>架构设计方法论</strong> ，架构设计专栏其实就是为了讲述完整的架构设计方法论，包括架构设计目的、架构设计原则、架构设计步骤、架构设计模式等，类似的架构设计方法论还有 《恰如其分的软件架构：风险驱动的设计方法》和《领域驱动设计》等。</p><p>要形成自己的架构设计方法论，主要手段有：</p><ul><li>系统学习架构设计方法论，包括订阅专栏或者阅读书籍等。</li><li>深入研究成熟开源系统的架构设计，这个手段在技术专家阶段也会用到，但关注点不一样，同样是研究开源系统，技术专家阶段聚焦于如何更好地应用开源项目；初级架构师阶段聚焦于学习其架构设计原理和理想，例如 Kafaka 的文档中就有关于消息队列架构设计的分析和取舍。</li><li>结合架构设计方法论，分析和总结自己团队甚至是公司的各种系统的架构设计优缺点，尝试思考架构重构方案。如果在这个基础上真的能够推动架构重构，那就更好了，既能够实践自己的架构设计方法论，同时积累经验，有能够展现自己的技术实力，拿到结果。</li></ul><hr><h1 id="第五步：中级架构师"><a href="#第五步：中级架构师" class="headerlink" title="第五步：中级架构师"></a>第五步：中级架构师</h1><h2 id="1-阶段描述-4"><a href="#1-阶段描述-4" class="headerlink" title="1.阶段描述"></a>1.阶段描述</h2><p>成长为中级架构师需要 8 年以上时间，其典型特征是 <strong>能够完成复杂系统的架构设计</strong> ，包含高性能、高可用、可扩展、海量存储等复杂系统，例如设计一个和 kafaka 性能匹敌的消息队列系统，将业务改造为异地多活，设计一个总共 100 人参与开发的业务系统等，</p><p>中级架构师与初级架构师的典型区别在于系统的复杂度不同，中级架构师面对的系统复杂度要高于初级架构师。以开源项目为例，初级架构师可能引入某个开源项目就可以完成架构设计，而中级架构师可能发现其实没有哪个开源项目是合适的，而需要自己开发一个全新的项目，事实上很多开源项目就是这样诞生出来的，</p><h2 id="2-成长指导-4"><a href="#2-成长指导-4" class="headerlink" title="2.成长指导"></a>2.成长指导</h2><p>从初级架构师成长为中级架构师，最关键的是 <strong>技术深度和技术理论的积累</strong> ，例如：</p><ul><li>技术理论：CAP 、BASE 是异地多活的设计理论基础，Paxos 是分布式一致性的基础算法、2PC、3PC是分布式事务的基础算法等。</li><li>技术深度：Kafaka 用磁盘存储还能够做到高效是因为磁盘顺序写；Disruptor 高性能是结合 CPU 预读取机制、缓存行、无锁设计等基础技术；Storm 的高效异或确认机制；Flink 的分布式快照算法等。</li></ul><p>疑问：</p><p>这些技术理论和技术深度的事情不应该是高级工程师阶段或者技术专家阶段就应该积累的么？为何到了中级架构师阶段反而是成长的关键呢？</p><p>主要原因在于高级工程师或者技术专家阶段即使去学习这些技术，实际上也比较难理解透彻，更加难以有机会去应用，更多的时候只是为了这个技术点而已；而到了中级架构师阶段，面对高度复杂的系统，很多时候就是几个关键技术细节决定整个架构设计的成败，或者某个设计方案理论上就是不可行的，如果不深刻理解理论和相关的关键技术点，很难设计优秀的架构。</p><hr><h1 id="第六步：高级架构师"><a href="#第六步：高级架构师" class="headerlink" title="第六步：高级架构师"></a>第六步：高级架构师</h1><h2 id="1-阶段描述-5"><a href="#1-阶段描述-5" class="headerlink" title="1.阶段描述"></a>1.阶段描述</h2><p>成长为高级架构师需要 10 年以上的时间，其典型特征是 <strong>创造新的架构模式</strong> ，例如：</p><ul><li>谷歌大数据论文，创造了分布式存储架构、分布式计算 MapReduce 架构、列式存储架构，开创了大数据时代。</li><li>在有 MapReduce 分布式u计算架构背景下，Storm 有创造了流式计算架构。</li><li>在虚拟机很成熟的背景下，Docker 创造了容器化的技术潮流。</li></ul><p>高级架构师与中级架构师相比，典型区别在于 <strong>创造性</strong> ，高级架构师能够创造新的架构模式，开创新的技术潮流。</p><h2 id="2-成长指导-5"><a href="#2-成长指导-5" class="headerlink" title="2.成长指导"></a>2.成长指导</h2><p>参考技术界：</p><ul><li>足够复杂的业务场景：例如谷歌的大数据、阿里的双十一、Facebook 的海量用户等，业务场景越复杂，给技术带来的挑战更大，更有可能产生创造性的技术突破。</li><li>足够强大的技术团队：绝大部分创造性的架构都来源于公司，或者知名的研究机构；灭有技术实力支撑，想突破也是心有余而力不足。</li><li>不满足于现状的态度：例如虚拟机很成熟但是资源占用太多，所以发明 Docker；MapReduce 难以做到实时运算，所以创造 Storm 流式运算。</li><li>尊重技术价值的文化：创造性的东西往往需要投入大量的人力和时间，而且刚开始一般都不会很成熟，如果完全结果导向、KPI 导向，创新技术很可能在萌芽阶段就被否定。</li></ul><hr><h1 id="学习线路图"><a href="#学习线路图" class="headerlink" title="学习线路图"></a>学习线路图</h1><h2 id="（一）微服务"><a href="#（一）微服务" class="headerlink" title="（一）微服务"></a>（一）微服务</h2><p><img src="/img/load.gif" data-original="/../../../images/programmer/Java/a/v1.png" alt="微服务架构"></p><h2 id="（二）分布式"><a href="#（二）分布式" class="headerlink" title="（二）分布式"></a>（二）分布式</h2><p><img src="/img/load.gif" data-original="/../../../images/programmer/Java/a/v2.png" alt="分布式"></p><h2 id="（三）源码分析"><a href="#（三）源码分析" class="headerlink" title="（三）源码分析"></a>（三）源码分析</h2><p><img src="/img/load.gif" data-original="/../../../images/programmer/Java/a/v3.png" alt="源码分析"></p><h2 id="（四）多线程并发"><a href="#（四）多线程并发" class="headerlink" title="（四）多线程并发"></a>（四）多线程并发</h2><p><img src="/img/load.gif" data-original="/../../../images/programmer/Java/a/v4.png" alt="多线程并发"></p><h2 id="（五）工程化"><a href="#（五）工程化" class="headerlink" title="（五）工程化"></a>（五）工程化</h2><p><img src="/img/load.gif" data-original="/../../../images/programmer/Java/a/v5.png" alt="工程化"></p><h2 id="（六）性能优化"><a href="#（六）性能优化" class="headerlink" title="（六）性能优化"></a>（六）性能优化</h2><p><img src="/img/load.gif" data-original="/../../../images/programmer/Java/a/v6.png" alt="性能优化"></p><h2 id="（七）电商项目"><a href="#（七）电商项目" class="headerlink" title="（七）电商项目"></a>（七）电商项目</h2><p><img src="/img/load.gif" data-original="/../../../images/programmer/Java/a/v7.png" alt="电商项目"></p>]]></content>
      
      
      <categories>
          
          <category> 程序员 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java程序员 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL使用教程</title>
      <link href="/posts/5d06cb2d.html"/>
      <url>/posts/5d06cb2d.html</url>
      
        <content type="html"><![CDATA[<img src="/img/load.gif" data-original="https://roaringelephant.org/wp-content/uploads/sites/5/2016/03/SQL.jpg" alt="SQL" height="300" /><h1 id="SQL-教程"><a href="#SQL-教程" class="headerlink" title="SQL 教程"></a>SQL 教程</h1><p><strong>SQL</strong> ( <code>Structured Query Language</code> ，结构化查询语言) 是一种用于管理和操作关系型数据库的标准化编程语言。</p><p>在线测试工具：<a href="https://www.jyshare.com/front-end/7768/">https://www.jyshare.com/front-end/7768/</a></p><hr><h2 id="SQL-简介"><a href="#SQL-简介" class="headerlink" title="SQL 简介"></a>SQL 简介</h2><p><strong>SQL</strong> （ <code>Structured Query Language</code> ，结构化查询语言）是用于管理关系数据库管理系统 （<strong>RDBMS</strong>）。</p><p>SQL 通过一系列的语句和命令来执行数据定义、数据查询、数据操作和数据控制等功能，包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。</p><h3 id="SQL-是什么？"><a href="#SQL-是什么？" class="headerlink" title="SQL 是什么？"></a>SQL 是什么？</h3><ul><li>SQL 值结构化查询语言，全称是 <code>Structured Query Language</code></li><li>SQL 让你可以访问和处理数据库，包括数据插入、查询、更新和删除</li><li>SQL 语言采用英语关键词，使其易读易写</li><li>SQL 有国际标准化组织 (ISO) 和美国国家标准协会 (ANSI) 标准化</li><li>SQL 提供了丰富的操作数据的功能，从简单的查询到复杂的数据库管理操作</li></ul><h3 id="SQL-能做什么？"><a href="#SQL-能做什么？" class="headerlink" title="SQL 能做什么？"></a>SQL 能做什么？</h3><ul><li>SQL 面向数据库执行查询</li><li>SQL 可以从数据库取回数据</li><li>SQL 可在数据库中插入新的记录</li><li>SQL 可更新数据库中的数据</li><li>SQL 可创建新数据库</li><li>SQL 可在数据库中创建新表</li><li>SQL 可在数据库中创建存储过程</li><li>SQL 可在数据库中创建视图</li><li>SQL 可设置表、存储过程和视图的权限</li></ul><h3 id="SQL-是一种标准-但是-…"><a href="#SQL-是一种标准-但是-…" class="headerlink" title="SQL 是一种标准-但是 …"></a>SQL 是一种标准-但是 …</h3><p>虽然 SQL 是一门 ANSI （American National Standards Institute 美国国家标准化组织）标准的计算机语言，但是任然存在着许多不同版本的 SQL 语言。</p><p>然而，为了与 ANSI 标准相兼容，他们必须以相似的方式共同地来支持一些主要的命令 （比如 SELECT、UPDATE、DELETE、INSERT、WHERE 等等）。</p><blockquote><p>💡   注释：除了 SQL 标准外，大部分 SQL 数据库都拥有它们自己的专有扩展！</p></blockquote><h3 id="在网站中使用-SQL"><a href="#在网站中使用-SQL" class="headerlink" title="在网站中使用 SQL"></a>在网站中使用 SQL</h3><p>要创建一个显示数据库中数据的网站：</p><ul><li>RDBMS 数据库程序（比如 MS Access、SQL Server、MySQL）</li><li>使用服务器端脚本语言，比如 PHP 或 ASP</li><li>使用 SQL 来获取您想要的数据</li><li>使用 HTML &#x2F; CSS</li></ul><h3 id="RDBMS"><a href="#RDBMS" class="headerlink" title="RDBMS"></a>RDBMS</h3><p>RDBMS 指关系型数据库管理系统，全称 <code>Relational Database Management System</code>。</p><p>RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server、IBM DB2、Oracle、MySQL 以及 Microsoft Access。</p><p>RDBMS 中的数据存储在被称为表的数据库对象中。</p><p>表是相关的数据项的集合，它由列和行组成。</p><h3 id="SQL-发展历史"><a href="#SQL-发展历史" class="headerlink" title="SQL 发展历史"></a>SQL 发展历史</h3><p>以下是 SQL 发展历史的关键节点：</p><h4 id="1970s-起源与早期发展"><a href="#1970s-起源与早期发展" class="headerlink" title="1970s: 起源与早期发展"></a>1970s: 起源与早期发展</h4><ol><li><strong>1970年</strong>：埃德加·科德（Edgar F. Codd）发表了《A Relational Model of Data for Large Shared Data Banks》论文，提出了关系数据库的概念，为 SQL 的发展奠定了理论基础。</li><li><strong>1973年-1974年</strong>：IBM 的研究人员 Donald D. Chamberlin 和 Raymond F. Boyce 在科德的理论基础上开发了一种名为 SEQUEL（Structured English Query Language）的语言，用于操作和管理 IBM 的 System R 关系数据库。</li><li><strong>1976年</strong>：SEQUEL 更名为 SQL（Structured Query Language）。</li></ol><h4 id="1980s-标准化与商业化"><a href="#1980s-标准化与商业化" class="headerlink" title="1980s: 标准化与商业化"></a>1980s: 标准化与商业化</h4><ol><li><strong>1981年</strong>：IBM 推出了商用关系数据库系统 SQL&#x2F;DS（Database System）和 DB2（Database 2）。</li><li><strong>1986年</strong>：美国国家标准协会（ANSI）发布了第一个 SQL 标准 ANSI SQL-86（SQL-87）。</li><li><strong>1987年</strong>：国际标准化组织（ISO）也采纳了 ANSI SQL-86 作为国际标准。</li></ol><h4 id="1990s-扩展与改进"><a href="#1990s-扩展与改进" class="headerlink" title="1990s: 扩展与改进"></a>1990s: 扩展与改进</h4><ol><li><strong>1992年</strong>：发布了 SQL-92（SQL2）标准，显著扩展了 SQL 语言的功能，包括对新数据类型、嵌套查询和连接的支持。</li><li><strong>1999年</strong>：发布了 SQL:1999（SQL3）标准，引入了对象关系数据库（ORDBMS）特性、递归查询、触发器和用户定义函数。</li></ol><h4 id="2000s-持续演进与新特性"><a href="#2000s-持续演进与新特性" class="headerlink" title="2000s: 持续演进与新特性"></a>2000s: 持续演进与新特性</h4><ol><li><strong>2003年</strong>：发布了 SQL:2003 标准，引入了 XML 相关特性和窗口函数。</li><li><strong>2006年</strong>：发布了 SQL:2006 标准，主要增强了对 XML 的支持。</li><li><strong>2008年</strong>：发布了 SQL:2008 标准，进一步改进了语法和性能优化。</li></ol><h4 id="2010s-新功能与大数据支持"><a href="#2010s-新功能与大数据支持" class="headerlink" title="2010s: 新功能与大数据支持"></a>2010s: 新功能与大数据支持</h4><ol><li><strong>2011年</strong>：发布了 SQL:2011 标准，增加了对时间数据类型和时间旅行（temporal data）的支持。</li><li><strong>2016年</strong>：发布了 SQL:2016 标准，引入了 JSON 数据类型和相关操作函数，适应了 NoSQL 数据库和大数据处理需求。</li></ol><h4 id="2020s-现代化与标准更新"><a href="#2020s-现代化与标准更新" class="headerlink" title="2020s: 现代化与标准更新"></a>2020s: 现代化与标准更新</h4><ol><li><strong>2023年</strong>：最新的 SQL 标准持续改进，增加了对更现代化的数据库需求和特性的支持。</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>SQL 从一种基于关系模型的查询语言发展成为现代数据库管理的核心语言，其标准在不断演进和扩展。各大数据库管理系统（如 MySQL、PostgreSQL、SQLite、SQL Server、Oracle 等）在遵循 SQL 标准的基础上，加入了自身的扩展和优化，使 SQL 成为数据操作和管理的强大工具。SQL 的发展不仅体现了技术的进步，也反映了数据管理需求的变化和增长。</p><hr><h2 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h2><p><strong>SQL</strong>（Structured Query Language）是一种用于管理和操作关系数据库的标准语言，包括数据查询、数据插入、数据更新、数据删除、数据库结构创建和修改等功能</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/SQL.png" alt=" https://www.runoob.com/wp-content/uploads/2013/09/SQL.png"></p><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><p>一个数据库通常包含一个或多个表，每个表有一个名字标识（例如:”<strong>Websites</strong>“），表包含带有数据的记录（行）。</p><p>在本教程中，我们在 MySQL 的 RUNOOB 数据库中创建了 Websites 表，用于存储网站记录。</p><p>我们可以通过以下命令查看 “Websites” 表的数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> use RUNOOB;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> names utf8;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> url                       <span class="operator">|</span> alexa <span class="operator">|</span> country <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> Google       <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.google.cm<span class="operator">/</span>    <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> 淘宝          <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.taobao.com<span class="operator">/</span>   <span class="operator">|</span> <span class="number">13</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> 菜鸟教程      <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>www.runoob.com<span class="operator">/</span>    <span class="operator">|</span> <span class="number">4689</span>  <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> 微博          <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>weibo.com<span class="operator">/</span>         <span class="operator">|</span> <span class="number">20</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> Facebook     <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.facebook.com<span class="operator">/</span> <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>解析</strong></p><ul><li><strong>use RUNOOB;</strong> 命令用于选择数据库。</li><li><strong>set names utf8;</strong> 命令用于设置使用的字符集。</li><li><strong>SELECT * FROM Websites;</strong> 读取数据表的信息。</li><li>上面的表包含五条记录（每一条对应一个网站信息）和5个列（id、name、url、alexa 和country）。</li></ul><h3 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><p>你需要在数据库上执行的大部分工作都由 SQL 语句完成。</p><p>下面的 SQL 语句从 <strong>Websites</strong> 表中选取所有记录：</p><p><strong>实例</strong></p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites;</span><br></pre></td></tr></table></figure><h3 id="请记住-…"><a href="#请记住-…" class="headerlink" title="请记住 …"></a>请记住 …</h3><ul><li>SQL 对大小写不敏感：<strong>SELECT</strong> 和 <strong>select</strong> 是相同的</li></ul><h3 id="SQL-语句后面加分号"><a href="#SQL-语句后面加分号" class="headerlink" title="SQL 语句后面加分号?"></a>SQL 语句后面加分号?</h3><p>某些数据库系统要求在每条 SQL 语句的末端使用分号。</p><p>分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 SQL 语句。</p><h3 id="一些重要的-SQL-命令"><a href="#一些重要的-SQL-命令" class="headerlink" title="一些重要的 SQL 命令"></a>一些重要的 SQL 命令</h3><ul><li><strong>SELECT</strong>  - 从数据库中提取数据</li><li><strong>UPDATE</strong> - 更新数据库中的数据</li><li><strong>DELETE</strong> - 从数据库中删除数据</li><li><strong>INSERT INTO</strong> - 向数据库中插入新数据</li><li><strong>CREATE DATABASE</strong> - 创建新数据库</li><li><strong>ALTER DATABASE</strong> - 修改数据库</li><li><strong>DROP TABLE</strong> - 删除表</li><li><strong>CREATE INDEX</strong> - 创建索引 （搜索值）</li><li><strong>DROP INDEX</strong> - 删除索引</li></ul><p>以下是一些常用的 SQL 语句和语法：</p><p><code>SELECT</code>：用于从数据库中查询数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><ul><li><code>column_name(s)</code> ：要查询的列</li><li><code>table_name</code> ：要查询的表</li><li><code>condition</code> ： 查询调价 （可选）</li><li><code>ORDER BY</code> ：排序方式，<strong>ASC</strong> 表示升序，<strong>DESC</strong> 表示降序</li></ul><p><code>INSERT INTO</code> ：用于向数据库插入新数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, ...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, ...)</span><br></pre></td></tr></table></figure><ul><li><code>table_name</code> ：要插入数据的表</li><li><code>(column1, column2, ...)</code> ：要插入数据的列</li><li><code>(value1, value2, ...)</code> ：对应列的值</li></ul><p><code>UPDATE</code> ：用于更新数据库表中的现有数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2, ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure><ul><li><code>table_name</code> ：要更新数据的表</li><li><code>column1 = value1, column2 = value2, ...</code> ：要更新的列及其新值</li><li><code>condition</code> ：更新条件</li></ul><p><code>DELETE</code> ：用于从数据库表中删除数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure><ul><li><code>table_name</code> ：要删除数据的表</li><li><code>condition</code> ：删除条件</li></ul><p><code>CREATE TABLE</code> ：用于创建新的数据库表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column1 data_type <span class="keyword">constraint</span>,</span><br><span class="line">    column2 data_type <span class="keyword">constraint</span>,</span><br><span class="line">    ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>table_name</code> ：要创建的表明</li><li><code>column1,column2, ...</code> ：表的列</li><li><code>data_type</code> ：列的数据类型 （如 <strong>INT</strong>、<strong>VARCHAR</strong> 等）</li><li><code>constraint</code> ：列的约束 （如 <strong>PRIMARY KEY</strong> 、<strong>NOT NULL</strong> 等）</li></ul><p><code>ALETER TABLE</code> ：用于修改现有数据库表的结构</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> column_name data_type</span><br></pre></td></tr></table></figure><ul><li><code>table_name</code> ：要修改的表</li><li><code>column_name</code> ：要添加的列</li><li><code>data_type</code> ：列的数据类型</li></ul><p>或：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name</span><br></pre></td></tr></table></figure><ul><li><code>column_name</code>：要删除的列</li></ul><p><code>DROP TABLE</code> ：用于删除数据库表</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name</span><br></pre></td></tr></table></figure><ul><li><code>table_name</code> ：要删除的表</li></ul><p><code>CREATE INDEX</code> ：用于创建索引，以加快查询速度</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column_name)</span><br></pre></td></tr></table></figure><ul><li><code>index_name</code> ：索引的名称</li><li><code>column_name</code> ：要索引的列</li></ul><p><code>DROP INDEX</code> ：用于删除索引</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name</span><br></pre></td></tr></table></figure><ul><li><code>index_name</code> ：要删除的索引名称</li><li><code>table_name</code> ：索引所在的表</li></ul><p><code>WHERE</code> ：用于指定筛选条件。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure><ul><li><code>condition</code> ：筛选条件。</li></ul><p><code>ORDER BY</code> ：用于对结果集进行排序</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><ul><li><code>column_name</code> ：用于排序的列</li><li><code>ASC</code> ：升序（默认）</li><li><code>DESC</code> ：降序</li></ul><p><code>GROUP BY</code> ：用于将结果集按一列或多列进行分组</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s), aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name(s)</span><br></pre></td></tr></table></figure><ul><li><code>aggregate_function(column_name)</code> ：聚合函数 （如 <strong>COUNT</strong> 、<strong>SUM</strong> 、<strong>AVG</strong> 等）</li></ul><p><code>HAVING</code> ：用于对分组后的结果集进行筛选</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s), aggregate_function(column_name)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column_name(s)</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure><ul><li><code>condition</code> ：筛选条件</li></ul><p><code>JOIN</code> ：用于将两个或多个表的记录结合起来</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name1</span><br><span class="line"><span class="keyword">JOIN</span> table_name2</span><br><span class="line"><span class="keyword">ON</span> table_name1.column_name <span class="operator">=</span> table_name2.column_name</span><br></pre></td></tr></table></figure><ul><li><code>JOIN</code>: 可以是 INNER JOIN、LEFT JOIN、RIGHT JOIN 或 FULL JOIN。</li></ul><p><code>DISTINCT</code> ：用于返回唯一不同的值。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br></pre></td></tr></table></figure><ul><li><code>column_name(s)</code>：要查询的列。</li></ul><hr><h2 id="SQL-SELECT"><a href="#SQL-SELECT" class="headerlink" title="SQL SELECT"></a>SQL SELECT</h2><p><strong>SELECT</strong>  语句用于从数据库中选取数据。</p><p>结果被存储在一个结果表中，称为结果集。</p><h3 id="SQL-SELECT-语法"><a href="#SQL-SELECT-语法" class="headerlink" title="SQL SELECT 语法"></a>SQL SELECT 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>与</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>column1, column2, ...</code> ：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。</li><li><code>table_name</code> ：要查询的表名称。</li><li><code>*</code>  ：通配符，表示选择表中的所有列。</li></ul><h3 id="演示数据库"><a href="#演示数据库" class="headerlink" title="演示数据库"></a>演示数据库</h3><p>下面是选自 “<strong>Websites</strong>“ 表的数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> url                       <span class="operator">|</span> alexa <span class="operator">|</span> country <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> Google       <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.google.cm<span class="operator">/</span>    <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> 淘宝          <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.taobao.com<span class="operator">/</span>   <span class="operator">|</span> <span class="number">13</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> 菜鸟教程      <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>www.runoob.com<span class="operator">/</span>    <span class="operator">|</span> <span class="number">4689</span>  <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> 微博          <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>weibo.com<span class="operator">/</span>         <span class="operator">|</span> <span class="number">20</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> Facebook     <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.facebook.com<span class="operator">/</span> <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SELECT-Column-实例"><a href="#SELECT-Column-实例" class="headerlink" title="SELECT Column 实例"></a>SELECT Column 实例</h3><p>下面的 SQL 语句从 Websites 表中选取 name 和 country 列：</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name,country <span class="keyword">FROM</span> Websites;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/98E6B49C-06AF-469B-B907-81C52BBE6BDC.jpg" alt=" https://www.runoob.com/wp-content/uploads/2013/09/98E6B49C-06AF-469B-B907-81C52BBE6BDC.jpg"></p><h3 id="SELECT-实例"><a href="#SELECT-实例" class="headerlink" title="SELECT *  实例"></a>SELECT *  实例</h3><p>下面的 SQL 语句从 Websites 表中选取所有列：</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/DE979628-6FAF-46BD-920F-18F9565ADD78.jpg" alt="https://www.runoob.com/wp-content/uploads/2013/09/DE979628-6FAF-46BD-920F-18F9565ADD78.jpg"></p><hr><h2 id="SQL-SELECT-DISTINCT"><a href="#SQL-SELECT-DISTINCT" class="headerlink" title="SQL SELECT DISTINCT"></a>SQL SELECT DISTINCT</h2><p>SELECT DISTINCT 语句用于返回唯一不同的值。</p><p>在表中，一个列可能包含多个重复值，有时你也许希望仅仅列出不同 （<strong>distinct</strong>）的值。</p><p>DISTINCT 关键词用于返回唯一不同的值。</p><h3 id="SQL-SELECT-DISTINCT-语法"><a href="#SQL-SELECT-DISTINCT-语法" class="headerlink" title="SQL SELECT DISTINCT 语法"></a>SQL SELECT DISTINCT 语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT column1, column2, ...</span><br><span class="line">FROM table_name;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>column1, column2, ...</code> ：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。</li><li><code>table_name</code> ：要查询的表名称。</li></ul><h3 id="演示数据库-1"><a href="#演示数据库-1" class="headerlink" title="演示数据库"></a>演示数据库</h3><p>下面是选自 “<strong>Websites</strong>“ 表的数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> url                       <span class="operator">|</span> alexa <span class="operator">|</span> country <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> Google       <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.google.cm<span class="operator">/</span>    <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> 淘宝          <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.taobao.com<span class="operator">/</span>   <span class="operator">|</span> <span class="number">13</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> 菜鸟教程      <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>www.runoob.com<span class="operator">/</span>    <span class="operator">|</span> <span class="number">4689</span>  <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> 微博          <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>weibo.com<span class="operator">/</span>         <span class="operator">|</span> <span class="number">20</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> Facebook     <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.facebook.com<span class="operator">/</span> <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SELECT-DISTINCT-实例"><a href="#SELECT-DISTINCT-实例" class="headerlink" title="SELECT DISTINCT 实例"></a>SELECT DISTINCT 实例</h3><p>下面的 SQL 语句仅从 Websites 表的 country 列中选取唯一不同的值，也就是去掉 contry 列的重复值：</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> country <span class="keyword">FROM</span> Websites;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="//www.runoob.com/wp-content/uploads/2013/09/E3012A35-35DF-4BBB-8657-8A312C5AEAB6.jpg" alt="https://www.runoob.com/wp-content/uploads/2013/09/E3012A35-35DF-4BBB-8657-8A312C5AEAB6.jpg"></p><hr><h2 id="SQL-WHERE"><a href="#SQL-WHERE" class="headerlink" title="SQL WHERE"></a>SQL WHERE</h2><p><strong>where</strong> 子句用于过滤记录</p><h3 id="SQL-WHERE-子句"><a href="#SQL-WHERE-子句" class="headerlink" title="SQL WHERE 子句"></a>SQL WHERE 子句</h3><p><strong>WHERE</strong> 子句用于提取那些满足指定条件的记录。</p><h3 id="SQL-WHERE-语法"><a href="#SQL-WHERE-语法" class="headerlink" title="SQL WHERE 语法"></a>SQL WHERE 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>column1, column2, ...</code>：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。</li><li><code>table_name</code>：要查询的表名称。</li></ul><h3 id="演示数据库-2"><a href="#演示数据库-2" class="headerlink" title="演示数据库"></a>演示数据库</h3><p>下面是选自 “<strong>Websites</strong>“ 表的数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> url                       <span class="operator">|</span> alexa <span class="operator">|</span> country <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> Google       <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.google.cm<span class="operator">/</span>    <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> 淘宝          <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.taobao.com<span class="operator">/</span>   <span class="operator">|</span> <span class="number">13</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> 菜鸟教程      <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>www.runoob.com<span class="operator">/</span>    <span class="operator">|</span> <span class="number">4689</span>  <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> 微博          <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>weibo.com<span class="operator">/</span>         <span class="operator">|</span> <span class="number">20</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> Facebook     <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.facebook.com<span class="operator">/</span> <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="WHERE-子句实例"><a href="#WHERE-子句实例" class="headerlink" title="WHERE 子句实例"></a>WHERE 子句实例</h3><p>下面的 SQL 语句从 “Websites” 表中选取国家为 “CN” 的所有网站：</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites <span class="keyword">WHERE</span> country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/4B7980AC-2566-43F7-843A-256E868B92A4.jpg" alt="https://www.runoob.com/wp-content/uploads/2013/09/4B7980AC-2566-43F7-843A-256E868B92A4.jpg"></p><h3 id="文本字段-vs-数值字段"><a href="#文本字段-vs-数值字段" class="headerlink" title="文本字段 vs. 数值字段"></a>文本字段 vs. 数值字段</h3><p>SQL 使用单引号来环绕文本值 （大部分数据库系统也接受双引号）</p><p>在上个实例中 ‘CN’ 文本字段使用了单引号。</p><p>如果是数值字段，请不要使用引号。</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/639D2956-99CE-44E9-B960-EA14D296820E.jpg" alt="https://www.runoob.com/wp-content/uploads/2013/09/639D2956-99CE-44E9-B960-EA14D296820E.jpg"></p><h3 id="WHERE-子句中的运算符"><a href="#WHERE-子句中的运算符" class="headerlink" title="WHERE 子句中的运算符"></a>WHERE 子句中的运算符</h3><p>下面的运算符可以在 WHERE 子句中使用：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">等于</td></tr><tr><td align="left">&lt;&gt;</td><td align="left">不等于。<strong>注释：</strong>在 SQL 的一些版本中，该操作符可被写成 !&#x3D;</td></tr><tr><td align="left">&gt;</td><td align="left">大于</td></tr><tr><td align="left">&lt;</td><td align="left">小于</td></tr><tr><td align="left">&gt;&#x3D;</td><td align="left">大于等于</td></tr><tr><td align="left">&lt;&#x3D;</td><td align="left">小于等于</td></tr><tr><td align="left">BETWEEN</td><td align="left">在某个范围内</td></tr><tr><td align="left">LIKE</td><td align="left">搜索某种模式</td></tr><tr><td align="left">IN</td><td align="left">指定针对某个列的多个可能值</td></tr></tbody></table><h2 id="SQL-AND-OR"><a href="#SQL-AND-OR" class="headerlink" title="SQL AND &amp; OR"></a>SQL AND &amp; OR</h2><p>AND &amp; OR 运算符用于基于一个以上的条件对记录进行过滤。</p><h3 id="SQL-AND-OR-运算符"><a href="#SQL-AND-OR-运算符" class="headerlink" title="SQL AND &amp; OR 运算符"></a>SQL AND &amp; OR 运算符</h3><p>如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。</p><p>如果第一个条件和第二个条件只要有一个成立，则 OR 运算符显示一条记录。</p><h3 id="演示数据库-3"><a href="#演示数据库-3" class="headerlink" title="演示数据库"></a>演示数据库</h3><p>下面是选自 “<strong>Websites</strong>“ 表的数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> url                       <span class="operator">|</span> alexa <span class="operator">|</span> country <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> Google       <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.google.cm<span class="operator">/</span>    <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> 淘宝          <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.taobao.com<span class="operator">/</span>   <span class="operator">|</span> <span class="number">13</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> 菜鸟教程      <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>www.runoob.com<span class="operator">/</span>    <span class="operator">|</span> <span class="number">4689</span>  <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> 微博          <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>weibo.com<span class="operator">/</span>         <span class="operator">|</span> <span class="number">20</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> Facebook     <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.facebook.com<span class="operator">/</span> <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AND-运算符实例"><a href="#AND-运算符实例" class="headerlink" title="AND  运算符实例"></a>AND  运算符实例</h3><p>下面的 SQL 语句从 <strong>Websites</strong> 表中选取国家为 CN 且 alexa 排名大于 50 的所有网站：</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> alexa <span class="operator">&gt;</span> <span class="number">50</span>;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/and-or1.jpg" alt="https://www.runoob.com/wp-content/uploads/2013/09/and-or1.jpg"></p><h3 id="OR-运算符实例"><a href="#OR-运算符实例" class="headerlink" title="OR 运算符实例"></a>OR 运算符实例</h3><p>下面的 SQL 语句从 Websites 表中选取国家为 USA 或者 CN 的所有客户：</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> country<span class="operator">=</span><span class="string">&#x27;USA&#x27;</span></span><br><span class="line"><span class="keyword">OR</span> country<span class="operator">=</span><span class="string">&#x27;CN&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/and-or2.jpg" alt="https://www.runoob.com/wp-content/uploads/2013/09/and-or2.jpg"></p><p>结合 AND &amp; OR</p><p>可以把 AND 和 OR 结合起来（使用圆括号来组成复杂的表达式）</p><p>下面的 SQL 语句从 Websites 表中选取 alexa 排名大于 15 且国家为 CN 或 USA 的所有网站：</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> alexa <span class="operator">&gt;</span> <span class="number">15</span></span><br><span class="line"><span class="keyword">AND</span> (country <span class="operator">=</span> <span class="string">&#x27;CN&#x27;</span> <span class="keyword">OR</span> country <span class="operator">=</span> <span class="string">&#x27;USA&#x27;</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/and-or3.jpg" alt="https://www.runoob.com/wp-content/uploads/2013/09/and-or3.jpg"></p><h2 id="SQL-ORDER-BY"><a href="#SQL-ORDER-BY" class="headerlink" title="SQL ORDER BY"></a>SQL ORDER BY</h2><p>ORDER BY 关键字用于对结果集进行排序。</p><h3 id="SQL-ORDER-BY-关键字"><a href="#SQL-ORDER-BY-关键字" class="headerlink" title="SQL ORDER BY 关键字"></a>SQL ORDER BY 关键字</h3><p>ORDER BY 关键字用于对于结果集按照一个列或者多个列进行排序。</p><p>ORDER BY 关键字默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，你可以使用 <strong>DESC</strong> 关键字。</p><h3 id="SQL-ORDER-BY-语法"><a href="#SQL-ORDER-BY-语法" class="headerlink" title="SQL ORDER BY 语法"></a>SQL ORDER BY 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1,column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column1,column2, ... <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><ul><li><code>column1,column2, ...</code> ：要排序的字段名称，可以为多个字段</li><li><code>ASC</code> ：表示按升序排序</li><li><code>DESC</code> ：表示按降序排序</li></ul><h3 id="演示数据库-4"><a href="#演示数据库-4" class="headerlink" title="演示数据库"></a>演示数据库</h3><p>下面是选自 “<strong>Websites</strong>“ 表的数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> url                       <span class="operator">|</span> alexa <span class="operator">|</span> country <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> Google       <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.google.cm<span class="operator">/</span>    <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> 淘宝          <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.taobao.com<span class="operator">/</span>   <span class="operator">|</span> <span class="number">13</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> 菜鸟教程      <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>www.runoob.com<span class="operator">/</span>    <span class="operator">|</span> <span class="number">4689</span>  <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> 微博          <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>weibo.com<span class="operator">/</span>         <span class="operator">|</span> <span class="number">20</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> Facebook     <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.facebook.com<span class="operator">/</span> <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ORDER-BY-实例"><a href="#ORDER-BY-实例" class="headerlink" title="ORDER BY 实例"></a>ORDER BY 实例</h3><p>下面的 SQL 语句从 Websites 表中选取所有网站，并按照 alexa 列排序：</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> alexa;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/orderby1.jpg" alt="https://www.runoob.com/wp-content/uploads/2013/09/orderby1.jpg"></p><h3 id="ORDER-BY-DESC-实例"><a href="#ORDER-BY-DESC-实例" class="headerlink" title="ORDER BY DESC 实例"></a>ORDER BY DESC 实例</h3><p>下面的 SQL 语句从 Websites 表中选取所有网站，并按照 alexa 列降序排序：</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> alexa <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/orderby2.jpg" alt="https://www.runoob.com/wp-content/uploads/2013/09/orderby2.jpg"></p><h3 id="ORDER-BY-多列"><a href="#ORDER-BY-多列" class="headerlink" title="ORDER BY 多列"></a>ORDER BY 多列</h3><p>下面的 SQL 语句从 Websites 表中选取所有网站，并且按照 country 和 alexa 列排序：</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> country,alexa;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/orderby3.jpg" alt=" https://www.runoob.com/wp-content/uploads/2013/09/orderby3.jpg"></p><h2 id="SQL-INSERT-INTO"><a href="#SQL-INSERT-INTO" class="headerlink" title="SQL INSERT INTO"></a>SQL INSERT INTO</h2><p>INSERT INTO 语句用于向表中插入新记录</p><h3 id="SQL-INSERT-INTO-语法"><a href="#SQL-INSERT-INTO-语法" class="headerlink" title="SQL INSERT INTO 语法"></a>SQL INSERT INTO 语法</h3><p>INSERT INTO 语句有两种可以编写形式。</p><p>第一种形式无需指定要插入数据的列名，值需要提供被插入的值即可：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure><p>第二种形式需要指定列名及被插入的值：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1,column2,column3,..)</span><br><span class="line"><span class="keyword">VALUES</span> (value1,value2,value3,...);</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>table_name</code> ：需要插入新纪录的表名</li><li><code>column1,column2,column3,..</code> ：需要插入的字段名</li><li><code>value1,value2,value3,...</code> ：需要插入的字段值。</li></ul><h3 id="演示数据库-5"><a href="#演示数据库-5" class="headerlink" title="演示数据库"></a>演示数据库</h3><p>下面是选自 “<strong>Websites</strong>“ 表的数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> url                       <span class="operator">|</span> alexa <span class="operator">|</span> country <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> Google       <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.google.cm<span class="operator">/</span>    <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> 淘宝          <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.taobao.com<span class="operator">/</span>   <span class="operator">|</span> <span class="number">13</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> 菜鸟教程      <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>www.runoob.com<span class="operator">/</span>    <span class="operator">|</span> <span class="number">4689</span>  <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> 微博          <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>weibo.com<span class="operator">/</span>         <span class="operator">|</span> <span class="number">20</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> Facebook     <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.facebook.com<span class="operator">/</span> <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>INSERT INTO 实例</p><p>假设我们要向 Websites 表中插入一个新列</p><p>我们可以使用下面的 SQL 语句</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Websites (name,url,alexa,country)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;百度&#x27;</span>,<span class="string">&#x27;https://www.baidu.com/&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;CN&#x27;</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/insert1.jpg" alt="https://www.runoob.com/wp-content/uploads/2013/09/insert1.jpg"></p><blockquote><p>💡   你是否注意到，我们没有向 id 字段插入任何数字？</p><p>id 列是自动更新的，表中的每条记录都有一个唯一的数字</p></blockquote><h3 id="在指定的列插入数据"><a href="#在指定的列插入数据" class="headerlink" title="在指定的列插入数据"></a>在指定的列插入数据</h3><p>我们也可以在指定的列插入数据</p><p>下面的 SQL 语句将插入一个新行，但只是在 name、url 和 country 列插入数据 (id字段会自动更新)</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Websites (name,url,country)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;stackoverflow&#x27;</span>, <span class="string">&#x27;http://stackoverflow.com/&#x27;</span>, <span class="string">&#x27;IND&#x27;</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/insert2.jpg" alt=" https://www.runoob.com/wp-content/uploads/2013/09/insert2.jpg"></p><h2 id="SQL-UPDATE"><a href="#SQL-UPDATE" class="headerlink" title="SQL UPDATE"></a>SQL UPDATE</h2><p>UPDATE 语句用于更新表中的记录</p><h3 id="SQL-UPDATE-语法"><a href="#SQL-UPDATE-语法" class="headerlink" title="SQL UPDATE 语法"></a>SQL UPDATE 语法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2, ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>table_name</code> ：要修改的表的名称</li><li><code>column1,column2,...</code> ：要修改的字段名称，可以为多个字段</li><li><code>value1,value2,...</code> ：要修改的值，可以为多个值</li><li><code>condition</code> ：修改条件，用于指定哪些数据要修改</li></ul><blockquote><p>💡   请注意 SQL UPDATE 语句中的 WHERE 子句！</p><p>WHERE 子句规定哪条记录或者哪些记录需要更新。如果你省略了 WHERE 子句，所有的记录都将被更新！</p></blockquote><h3 id="演示数据库-6"><a href="#演示数据库-6" class="headerlink" title="演示数据库"></a>演示数据库</h3><p>下面是选自 “<strong>Websites</strong>“ 表的数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> url                       <span class="operator">|</span> alexa <span class="operator">|</span> country <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> Google       <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.google.cm<span class="operator">/</span>    <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> 淘宝          <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.taobao.com<span class="operator">/</span>   <span class="operator">|</span> <span class="number">13</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> 菜鸟教程      <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>www.runoob.com<span class="operator">/</span>    <span class="operator">|</span> <span class="number">4689</span>  <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> 微博          <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>weibo.com<span class="operator">/</span>         <span class="operator">|</span> <span class="number">20</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> Facebook     <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.facebook.com<span class="operator">/</span> <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SQL-UPDATE-实例"><a href="#SQL-UPDATE-实例" class="headerlink" title="SQL UPDATE 实例"></a>SQL UPDATE 实例</h3><p>假设我们要把 菜鸟教程 的 alexa 排名更新为 5000，country 改为 USA</p><p>我们使用下面的 SQL 语句</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Websites </span><br><span class="line"><span class="keyword">SET</span> alexa<span class="operator">=</span><span class="string">&#x27;5000&#x27;</span>, country<span class="operator">=</span><span class="string">&#x27;USA&#x27;</span> </span><br><span class="line"><span class="keyword">WHERE</span> name<span class="operator">=</span><span class="string">&#x27;菜鸟教程&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/update1.jpg" alt="https://www.runoob.com/wp-content/uploads/2013/09/update1.jpg"></p><h3 id="UPDATE-警告！"><a href="#UPDATE-警告！" class="headerlink" title="UPDATE 警告！"></a>UPDATE 警告！</h3><p>在更新记录时要格外小心！在上面的实例中，如果我们省略了 WHERE 子句，如下所示：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Websites</span><br><span class="line"><span class="keyword">SET</span> alexa<span class="operator">=</span><span class="string">&#x27;5000&#x27;</span>, country<span class="operator">=</span><span class="string">&#x27;USA&#x27;</span></span><br></pre></td></tr></table></figure><p>执行以上代码会将 Websites 表中所有数据的 alexa 改为 5000，country 改为 USA</p><p>执行没有 WHERE 子句的 UPDATE 要慎重，再慎重。</p><h2 id="SQL-DELETE"><a href="#SQL-DELETE" class="headerlink" title="SQL DELETE"></a>SQL DELETE</h2><p>DELETE 语句用于删除表中的记录</p><p>SQL DELETE 语法</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>table_name</code> ：要删除的表的名称</li><li><code>condition</code> ：删除条件，用于指定哪些数据要删除</li></ul><blockquote><p>💡   请注意 SQL DELETE 语句中的 WHERE 子句！</p><p>WHERE 子句规定哪条记录或者哪些记录需要删除，如果你省略了 WHERE 子句，所有的记录都将被删除！</p></blockquote><h3 id="演示数据库-7"><a href="#演示数据库-7" class="headerlink" title="演示数据库"></a>演示数据库</h3><p>下面是选自 “<strong>Websites</strong>“ 表的数据：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name         <span class="operator">|</span> url                       <span class="operator">|</span> alexa <span class="operator">|</span> country <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">1</span>  <span class="operator">|</span> Google       <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.google.cm<span class="operator">/</span>    <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">2</span>  <span class="operator">|</span> 淘宝          <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.taobao.com<span class="operator">/</span>   <span class="operator">|</span> <span class="number">13</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">3</span>  <span class="operator">|</span> 菜鸟教程      <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>www.runoob.com<span class="operator">/</span>    <span class="operator">|</span> <span class="number">4689</span>  <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">4</span>  <span class="operator">|</span> 微博          <span class="operator">|</span> http:<span class="operator">/</span><span class="operator">/</span>weibo.com<span class="operator">/</span>         <span class="operator">|</span> <span class="number">20</span>    <span class="operator">|</span> CN      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">5</span>  <span class="operator">|</span> Facebook     <span class="operator">|</span> https:<span class="operator">/</span><span class="operator">/</span>www.facebook.com<span class="operator">/</span> <span class="operator">|</span> <span class="number">3</span>     <span class="operator">|</span> USA     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------------------+-------+---------+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="SQL-DELETE-实例"><a href="#SQL-DELETE-实例" class="headerlink" title="SQL DELETE 实例"></a>SQL DELETE 实例</h3><p>假设我们要从 Websites 表中删除网站名称为 Facebook 且国家为 USA 的网站</p><p>我们使用一下 SQL 语句：</p><p>实例：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Websites</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Facebook&#x27;</span> <span class="keyword">AND</span> country <span class="operator">=</span> <span class="string">&#x27;USA&#x27;</span>;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><img src="/img/load.gif" data-original="https://www.runoob.com/wp-content/uploads/2013/09/BD5EFB9A-2A65-4AF8-81F3-022E051811DC.jpg" alt=" https://www.runoob.com/wp-content/uploads/2013/09/BD5EFB9A-2A65-4AF8-81F3-022E051811DC.jpg"></p><h3 id="删除所有数据"><a href="#删除所有数据" class="headerlink" title="删除所有数据"></a>删除所有数据</h3><p>你可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注释</strong>：在删除记录时要格外小心！因为你不能重来！</p></blockquote><hr><h1 id="SQL-高级教程"><a href="#SQL-高级教程" class="headerlink" title="SQL 高级教程"></a>SQL 高级教程</h1><h2 id="SQL-SELECT-TOP"><a href="#SQL-SELECT-TOP" class="headerlink" title="SQL SELECT TOP"></a>SQL SELECT TOP</h2><p>SELECT TOP 语句用于在 SQL 中限制返回的结果集中的行数，它通常用于值需要查询前几行数据的情况，尤其在数据集非常大时，可</p>]]></content>
      
      
      <categories>
          
          <category> 编程语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker使用</title>
      <link href="/posts/cd988ed5.html"/>
      <url>/posts/cd988ed5.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/load.gif" data-original="https://www.kubernetes.org.cn/img/2018/04/v2-efd70b66fc1a550ab8d7b926cbd0cccf_hd.jpg" alt="Docker使用"></p><h1 id="1-快速入门"><a href="#1-快速入门" class="headerlink" title="1.快速入门"></a>1.快速入门</h1><p>安装 <strong>Docker</strong> ：</p><a href="/posts/f5f9fa9b.html" target="_blank">  <img src="/img/load.gif" data-original="https://image.3001.net/images/20171222/15139427067456.png" alt="Docker安装"></a><h2 id="1-1-部署-MySQL"><a href="#1-1-部署-MySQL" class="headerlink" title="1.1.部署 MySQL"></a>1.1.部署 MySQL</h2><p>传统安装 <strong>MySQL</strong> ：</p><ul><li>搜索并下载MySQL安装包</li><li>上传至Linux环境</li><li>编译和配置环境</li><li>安装</li></ul><p><strong>Docker</strong> 安装 <strong>MySQL</strong> ：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">docker run <span class="literal">-d</span> \</span><br><span class="line">  <span class="literal">--name</span> mysql \</span><br><span class="line">  <span class="literal">-p</span> <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">  <span class="literal">-e</span> TZ=Asia/Shanghai \</span><br><span class="line">  <span class="literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="number">123</span> \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="/img/load.gif" data-original="/images/environment/docker/docker/a/v1.png" alt="运行效果"></p><p><strong>MySQL</strong> 安装完毕，通过任意客户端工具即可连接 <strong>MySQL</strong> .</p><p>执行命令后，<strong>Docker</strong> 回去自动搜索并下载 <strong>MySQL</strong> ，然后自动运行 <strong>MySQL</strong> ，并不需要我们插手，十分便捷。</p><p>而且通过这种方式完全不需要考虑运行的操作系统环境，它不仅仅在 <strong>CentOS</strong> 系统，在 <strong>Ubuntu</strong> 系统，<strong>macOS</strong>系统，甚至是安装了 <strong>WSL</strong> 的 <strong>Windows</strong> 系统下，都可以使用这条命令来安装 <strong>MySQL</strong> 。</p><p>要知道，<strong>不同操作系统下其安装包、运行环境是都不相同的</strong>！如果是<strong>手动安装，必须手动解决安装包不同、环境不同的、配置不同的问题</strong>！</p><p>而使用 <strong>Docker</strong>，这些完全不用考虑。就是因为 <strong>Docker</strong> 会自动搜索并下载 <strong>MySQL</strong> 。注意：这里下载的不是安装包，而是<strong>镜像。</strong>镜像中不仅包含了 <strong>MySQL</strong> 本身，还包含了其运行所需要的环境、配置、系统级函数库。因此它在运行时就有自己独立的环境，就可以跨系统运行，也不需要手动再次配置环境了。这套独立运行的隔离环境我们称为<strong>容器</strong>。</p><p>说明：</p><ul><li>镜像：英文是 <code>image</code></li><li>容器：英文是 <code>container</code></li></ul><blockquote><p>因此，<strong>Docker</strong> 安装的过程，就是自动搜索并下载镜像，然后创建并运行容器的过程。</p></blockquote><p><strong>Docker</strong> 会根据命令中的镜像名称自动搜索并下载镜像，那么问题来了，它是去哪里搜索和下载镜像的呢？这些镜像又是谁制作的呢？</p><p><strong>Docker</strong> 官方提供了一个专门管理、存储镜像的网站，并对外开放了镜像上传、下载的权利。<strong>Docker</strong> 官方提供了一些基础镜像，然后各大然间公司又在基础上，制作了自家的镜像软件，全部都存放在这个网站上，这个网站就成了 <strong>Docker</strong> 镜像交流社区：</p><blockquote><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p></blockquote><p>基本上我们常用的各种软件都能在这个网站上找到，我们甚至可以自己制作镜像上传上去。</p><p>像这种提供存储，管理 <strong>Docker</strong> 镜像的服务器，被称为 <strong>DockerRegistry</strong> ，可以翻译为镜像仓库。<strong>DockerHub</strong> 网站时官方仓库，阿里云、华为云会提供一些第三方仓库，我们也可以搭建私有的镜像仓库。</p><p>官方仓库在国外，下载速度较慢，一般我们都会使用第三方仓库提供的镜像加速功能，提高下载速度。在企业内部的机密项目，往往会采用私有镜像仓库。</p><p>总之，镜像的来源有两种：</p><ul><li>基于官方基础镜像自己制作</li><li>直接去 <strong>DockerRegistry</strong> 下载</li></ul><blockquote><p><strong>总结一下</strong>：</p><p><strong>Docker</strong> 本身包含一个后台服务，我们可以利用 <strong>Docker</strong> 命令告诉 <strong>Docker</strong> 服务，帮助我们快速部署指定的应用。<strong>Docker</strong> 服务部署应用时，首先要去搜索并下载应用对应的镜像，然后根据镜像创建并允许容器，应用就部署完成了。</p></blockquote><p>如图所示：</p><p><img src="/img/load.gif" data-original="/images/environment/docker/docker/a/v2.png" alt="运行效果"></p><h2 id="1-2-命令解读"><a href="#1-2-命令解读" class="headerlink" title="1.2.命令解读"></a>1.2.命令解读</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">  --name mysql \</span><br><span class="line">  -p 3306:3306 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -e MYSQL_ROOT_PASSWORD=123 \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure><blockquote><p>解读：</p><ul><li><code>docker run -d</code> ：创建并运行一个容器 <code>-d</code> 则时让容器以后台进程进行</li><li><code>--name mysql</code> ：给容器起个名字叫 <code>mysql</code>，也可以去别的</li><li><code>-p 3306:3306</code> ：设置多口映射<ul><li><strong>容器是隔离环境</strong>，外界不可访问。但是可以<strong>将宿主机端口映射容器内到端口</strong>，当访问宿主机指定端口时，就是在访问容器内的端口了。</li><li>容器内端口往往是由容器内的进程决定。例如 <strong>MySQL</strong> 进行默认端口是 <code>3306</code> ，因此容器内端口一定是 <code>3306</code> ；而宿主机端口则可以任意指定，一般与容器内保持一致。</li><li>格式：<code>-p 宿主机端口:容器内端口</code> ，示例中就是将宿主机的 <code>3306</code> 映射到容器内的 <code>3306</code> 端口</li></ul></li><li><code>-e TZ=Asia/Shanghai</code> ：配置容器内进行运行时的一些参数<ul><li>格式：<code>-e KEY=VALUE</code> ,<strong>KEY</strong> 和 <strong>VALUE</strong> 都由容器内进程决定</li><li>案例中 <code>TZ=Asia/Shanghai</code> 是设置时区；<code>MYSQL_ROOT_PASSWORD=123</code> 是设置 MySQL 默认密码</li></ul></li><li><code>mysql</code> ：设置镜像名称，Docker 会根据这个名字搜索并下载镜像<ul><li>格式：<code>REPOSITORY:TAG</code>，例如<code>mysql:8.0</code>，其中<code>REPOSITORY</code>可以理解为镜像名，<code>TAG</code>是版本号</li><li>在未指定<code>TAG</code>的情况下，默认是最新版本，也就是<code>mysql:latest</code></li></ul></li></ul></blockquote><p>镜像的名称不是随意的，而是要到 <strong>DockerRegistry</strong> 中寻找，镜像运行时的配置也不是随意的，要参考镜像的帮助文档，这些在 <strong>DockerHub</strong> 网站或者软件的官方网站中都能找到。</p><p>如果我们要安装其他软件，也可以到 <strong>DockerRegistry</strong> 中寻找对应的镜像名称和版本，阅读相关配置即可。</p><hr><h1 id="2-Docker-基础"><a href="#2-Docker-基础" class="headerlink" title="2.Docker 基础"></a>2.Docker 基础</h1><p><strong>Docker</strong> 官方文档：</p><p><a href="https://docs.docker.com/">https://docs.docker.com/</a></p><h2 id="2-1-常见命令"><a href="#2-1-常见命令" class="headerlink" title="2.1.常见命令"></a>2.1.常见命令</h2><p><a href="https://docs.docker.com/reference/cli/docker/">https://docs.docker.com/reference/cli/docker/</a></p><h3 id="2-1-1-常见命令介绍"><a href="#2-1-1-常见命令介绍" class="headerlink" title="2.1.1.常见命令介绍"></a>2.1.1.常见命令介绍</h3><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker pull</td><td align="left">拉取镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/pull/">docker pull</a></td></tr><tr><td align="left">docker push</td><td align="left">推送镜像到DockerRegistry</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/push/">docker push</a></td></tr><tr><td align="left">docker images</td><td align="left">查看本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/images/">docker images</a></td></tr><tr><td align="left">docker rmi</td><td align="left">删除本地镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rmi/">docker rmi</a></td></tr><tr><td align="left">docker run</td><td align="left">创建并运行容器（不能重复创建）</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/run/">docker run</a></td></tr><tr><td align="left">docker stop</td><td align="left">停止指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/stop/">docker stop</a></td></tr><tr><td align="left">docker start</td><td align="left">启动指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/start/">docker start</a></td></tr><tr><td align="left">docker restart</td><td align="left">重新启动容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/restart/">docker restart</a></td></tr><tr><td align="left">docker rm</td><td align="left">删除指定容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/rm/">docs.docker.com</a></td></tr><tr><td align="left">docker ps</td><td align="left">查看容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/ps/">docker ps</a></td></tr><tr><td align="left">docker logs</td><td align="left">查看容器运行日志</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/logs/">docker logs</a></td></tr><tr><td align="left">docker exec</td><td align="left">进入容器</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/exec/">docker exec</a></td></tr><tr><td align="left">docker save</td><td align="left">保存镜像到本地压缩文件</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/save/">docker save</a></td></tr><tr><td align="left">docker load</td><td align="left">加载本地压缩文件到镜像</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/load/">docker load</a></td></tr><tr><td align="left">docker inspect</td><td align="left">查看容器详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/inspect/">docker inspect</a></td></tr></tbody></table><p>用一幅图来表示这些命令的关系：</p><p><img src="/img/load.gif" data-original="/images/environment/docker/docker/a/v3.png" alt="命令关系"></p><p>补充：</p><p>默认情况下，每次重启虚拟机我们都需要手动启动 <strong>Docker</strong> 和 <strong>Docker</strong> 中的容器。通过命令可以实现开机启动：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker开机自启</span></span><br><span class="line">systemctl enable docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker容器开机自启</span></span><br><span class="line">docker update <span class="literal">--restart</span>=always [容器名/容器<span class="type">id</span>]</span><br></pre></td></tr></table></figure><h3 id="2-1-2-演示"><a href="#2-1-2-演示" class="headerlink" title="2.1.2.演示"></a>2.1.2.演示</h3><p>以 <strong>nginx</strong> 为例：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第1步，去DockerHub查看nginx镜像仓库及相关信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2步，拉取Nginx镜像</span></span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第3步，查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 结果如下：</span></span><br><span class="line">REPOSITORY   TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">nginx        latest    <span class="number">605</span>c77e624dd   <span class="number">16</span> months ago   <span class="number">141</span>MB</span><br><span class="line">mysql        latest    <span class="number">3218</span>b38490ce   <span class="number">17</span> months ago   <span class="number">516</span>MB</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第4步，创建并允许Nginx容器</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第5步，查看运行中容器</span></span><br><span class="line">docker <span class="built_in">ps</span></span><br><span class="line"><span class="comment"># 也可以加格式化方式访问，格式会更加清爽</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第6步，访问网页，地址：http://虚拟机地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第7步，停止容器</span></span><br><span class="line">docker stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第8步，查看所有容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">-a</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第9步，再次启动nginx容器</span></span><br><span class="line">docker <span class="built_in">start</span> nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第10步，再次查看容器</span></span><br><span class="line">docker <span class="built_in">ps</span> <span class="literal">--format</span> <span class="string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第11步，查看容器详细信息</span></span><br><span class="line">docker inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第12步，进入容器,查看容器内目录</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br><span class="line"><span class="comment"># 或者，可以进入MySQL</span></span><br><span class="line">docker exec <span class="literal">-it</span> mysql mysql <span class="literal">-uroot</span> <span class="literal">-p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第13步，删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> nginx</span><br><span class="line"><span class="comment"># 发现无法删除，因为容器运行中，强制删除容器</span></span><br><span class="line">docker <span class="built_in">rm</span> <span class="operator">-f</span> nginx</span><br></pre></td></tr></table></figure><h3 id="2-1-3-命令别名"><a href="#2-1-3-命令别名" class="headerlink" title="2.1.3.命令别名"></a>2.1.3.命令别名</h3><p>给常用的 <strong>Docker</strong> 命令起别名，方便我们访问：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改/root/.bashrc文件</span></span><br><span class="line">vi /root/.bashrc</span><br><span class="line">内容如下：</span><br><span class="line"><span class="comment"># .bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User specific aliases and functions</span></span><br><span class="line"></span><br><span class="line">alias <span class="built_in">rm</span>=<span class="string">&#x27;rm -i&#x27;</span></span><br><span class="line">alias <span class="built_in">cp</span>=<span class="string">&#x27;cp -i&#x27;</span></span><br><span class="line">alias <span class="built_in">mv</span>=<span class="string">&#x27;mv -i&#x27;</span></span><br><span class="line">alias dps=<span class="string">&#x27;docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Names&#125;&#125;&quot;&#x27;</span></span><br><span class="line">alias dis=<span class="string">&#x27;docker images&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source global definitions</span></span><br><span class="line"><span class="keyword">if</span> [ -<span class="type">f</span> /<span class="type">etc</span>/<span class="type">bashrc</span> ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>然后，执行命令使别名生效</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">source /root/.bashrc</span><br></pre></td></tr></table></figure><h2 id="2-2-数据卷"><a href="#2-2-数据卷" class="headerlink" title="2.2.数据卷"></a>2.2.数据卷</h2><p>容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便，问题思考：</p><ul><li>如果要升级 MySQL，需要销毁旧容器，那么旧数据岂不是跟着被销毁了？</li><li>MySQL 、Nginx 容器运行后，如果我要修改其中的某些配置该怎么办？</li><li>怎么让 Nginx 代理静态资源？</li></ul><p>因此，容器提供程序的运行环境，但是<strong>程序运行产生的数据、程序运行依赖的配置都应该与容器解耦</strong>。</p><h3 id="2-2-1-什么是数据卷"><a href="#2-2-1-什么是数据卷" class="headerlink" title="2.2.1.什么是数据卷"></a>2.2.1.什么是数据卷</h3><p><strong>数据卷(volume)<strong>是一个虚拟目录，是</strong>容器内目录与宿主机目录</strong>之间映射的桥梁。</p><p>以 <strong>Nginx</strong> 为例，我们知道 <strong>Nginx</strong> 中有两个关键的目录：</p><ul><li><code>html</code> ：放置一些静态资源</li><li><code>conf</code> ：放置配置文件</li></ul><p>如果我们要让 <strong>Nginx</strong> 代理我们的静态资源，最好放到 <strong>html</strong> 目录；如果我们要修改 <strong>Nginx</strong>  的配置，最好是找到 <strong>conf</strong> 下的 <strong>nginx.conf</strong> 文件</p><p>但遗憾的是，容器运行的 <strong>Nginx</strong> 所有的问及那都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作。如图：</p><p><img src="/img/load.gif" data-original="/images/environment/docker/docker/a/v4.png" alt="数据卷"></p><p>在上图中：</p><ul><li>我们创建了两个数据卷：<code>conf</code>、<code>html</code></li><li>Nginx容器内部的<code>conf</code>目录和<code>html</code>目录分别与两个数据卷关联。</li><li>而数据卷conf和html分别指向了宿主机的<code>/var/lib/docker/volumes/conf/_data</code>目录和<code>/var/lib/docker/volumes/html/_data</code>目录</li></ul><p>这样以来，容器内的<code>conf</code>和<code>html</code>目录就 与宿主机的<code>conf</code>和<code>html</code>目录关联起来，我们称为<strong>挂载</strong>。此时，我们操作宿主机的<code>/var/lib/docker/volumes/html/_data</code>就是在操作容器内的<code>/usr/share/nginx/html/_data</code>目录。只要我们将静态资源放入宿主机对应目录，就可以被Nginx代理了。</p><blockquote><p>小提示：</p><p><code>/var/lib/docker/volumes</code> 这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为 <code>/数据卷名/_data</code></p><p>为什么不让容器目录直接指向宿主机目录呢？</p><ul><li>因为直接指向宿主机目录就与宿主机强耦合了，如果切换了环境，宿主机目录就可能发生改变。由于容器一旦创建，目录挂载就无法修改，这样容器就无法正常工作了。</li><li>但是容器指向数据卷，一个逻辑名称，而数据卷再指向宿主机目录，就不存在强耦合。如果宿主机目录发生改变，只要改变数据卷与数组机目录之间的映射关系即可</li></ul><p>不过，我们由于数据卷目录比较深，不好寻找，通常我们也<strong>允许让容器直接与宿主机挂载而不使用数据卷</strong></p></blockquote><h3 id="2-2-2-数据卷命令"><a href="#2-2-2-数据卷命令" class="headerlink" title="2.2.2.数据卷命令"></a>2.2.2.数据卷命令</h3><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker volume create</td><td align="left">创建数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_create/">docker volume create</a></td></tr><tr><td align="left">docker volume ls</td><td align="left">查看所有数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker volume rm</td><td align="left">删除指定数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker volume inspect</td><td align="left">查看某个数据卷的详情</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_inspect/">docs.docker.com</a></td></tr><tr><td align="left">docker volume prune</td><td align="left">清除数据卷</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/volume_prune/">docker volume prune</a></td></tr></tbody></table><p>注意：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且<strong>创建容器的过程中，数据卷会自动创建</strong>。</p><p>演示一下 <strong>nginx</strong> 的 <strong>html</strong> 目录挂载：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.首先创建容器并指定数据卷，注意通过 -v 参数来指定数据卷</span></span><br><span class="line">docker run <span class="literal">-d</span> <span class="literal">--name</span> nginx <span class="literal">-p</span> <span class="number">80</span>:<span class="number">80</span> <span class="literal">-v</span> html:/usr/share/nginx/html nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看数据卷</span></span><br><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">DRIVER    VOLUME NAME</span><br><span class="line">local     <span class="number">29524</span>ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</span><br><span class="line">local     html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查看数据卷详情</span></span><br><span class="line">docker volume inspect html</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;CreatedAt&quot;</span>: <span class="string">&quot;2024-05-17T19:57:08+08:00&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Driver&quot;</span>: <span class="string">&quot;local&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Labels&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Mountpoint&quot;</span>: <span class="string">&quot;/var/lib/docker/volumes/html/_data&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;html&quot;</span>,</span><br><span class="line">        <span class="string">&quot;Options&quot;</span>: <span class="type">null</span>,</span><br><span class="line">        <span class="string">&quot;Scope&quot;</span>: <span class="string">&quot;local&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查看/var/lib/docker/volumes/html/_data目录</span></span><br><span class="line">ll /var/lib/docker/volumes/html/_data</span><br><span class="line"><span class="comment"># 可以看到与nginx的html目录内容一样，结果如下：</span></span><br><span class="line">总用量 <span class="number">8</span></span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">497</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> <span class="number">50</span>x.html</span><br><span class="line"><span class="literal">-rw-r--r--</span>. <span class="number">1</span> root root <span class="number">615</span> <span class="number">12</span>月 <span class="number">28</span> <span class="number">2021</span> index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.进入该目录，并随意修改index.html内容</span></span><br><span class="line"><span class="built_in">cd</span> /var/lib/docker/volumes/html/_data</span><br><span class="line">vi index.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.打开页面，查看效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7.进入容器内部，查看/usr/share/nginx/html目录内的文件是否变化</span></span><br><span class="line">docker exec <span class="literal">-it</span> nginx bash</span><br></pre></td></tr></table></figure><p>演示一下 <strong>MySQL</strong> 的匿名数据卷：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.查看MySQL容器详细信息</span></span><br><span class="line">docker inspect mysql</span><br><span class="line"><span class="comment"># 关注其中.Config.Volumes部分和.Mounts部分</span></span><br></pre></td></tr></table></figure><p>我们关注两部分内容，第一是<code>.Config.Volumes</code>部分：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="attr">&quot;Volumes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;/var/lib/mysql&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以发现这个容器声明了一个本地目录，需要挂载数据卷，但是<strong>数据卷未定义</strong>。这就是匿名卷。</p><p>然后，我们再看结果中的<code>.Mounts</code>部分：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Mounts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;Type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;volume&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Destination&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/var/lib/mysql&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;Driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;local&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以发现，其中有几个关键属性：</p><ul><li><strong>Name</strong>：数据卷名称。由于定义容器未设置容器名，这里的就是匿名卷自动生成的名字，一串 <strong>hash</strong> 值。</li><li><strong>Source</strong>：宿主机目录</li><li><strong>Destination</strong> : 容器内的目录</li></ul><p>上述配置是将容器内的<code>/var/lib/mysql</code>这个目录，与数据卷<code>29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f</code>挂载。于是在宿主机中就有了<code>/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</code>这个目录。这就是匿名数据卷对应的目录，其使用方式与普通数据卷没有差别。</p><p>接下来，可以查看该目录下的 <strong>MySQL</strong> 的 <strong>data</strong> 文件：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -l /var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data</span><br></pre></td></tr></table></figure><p>注意：每一个不同的镜像，将来创建容器后内部有哪些目录可以挂载，可以参考 <strong>DockerHub</strong> 对应的页面</p><h3 id="2-2-3-挂载本地目录或文件"><a href="#2-2-3-挂载本地目录或文件" class="headerlink" title="2.2.3.挂载本地目录或文件"></a>2.2.3.挂载本地目录或文件</h3><p>可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载本地目录</span></span><br><span class="line">-v 本地目录:容器内目录</span><br><span class="line"><span class="comment"># 挂载本地文件</span></span><br><span class="line">-v 本地文件:容器内文件</span><br></pre></td></tr></table></figure><blockquote><p>注意：本地目录或文件必须以 <code>/</code> 或 <code>./</code> 开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。。</p></blockquote><p>例如：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-v mysql:/var/lib/mysql <span class="comment"># 会被识别为一个数据卷叫mysql，运行时会自动创建这个数据卷</span></span><br><span class="line">-v ./mysql:/var/lib/mysql <span class="comment"># 会被识别为当前目录下的mysql目录，运行时如果不存在会创建目录</span></span><br></pre></td></tr></table></figure><h2 id="2-3-镜像"><a href="#2-3-镜像" class="headerlink" title="2.3.镜像"></a>2.3.镜像</h2><p>前面我们一直在使用别人准备好的镜像，那如果我要部署一个 <strong>Java</strong> 项目，把它打包为一个镜像该怎么做呢？</p><h3 id="2-3-1-镜像结构"><a href="#2-3-1-镜像结构" class="headerlink" title="2.3.1.镜像结构"></a>2.3.1.镜像结构</h3><p>要想自己构建镜像，必须先了解镜像的结构。</p><p>之前我们说过，镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。</p><p>因此，自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。</p><p>举个例子，我们要从0部署一个Java应用，大概流程是这样：</p><ul><li>准备一个linux服务（CentOS或者Ubuntu均可）</li><li>安装并配置JDK</li><li>上传Jar包</li><li>运行jar包</li></ul><p>那因此，我们打包镜像也是分成这么几步：</p><ul><li>准备Linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）</li><li>安装并配置JDK</li><li>拷贝jar包</li><li>配置启动脚本</li></ul><p>上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以<strong>镜像就是一堆文件的集合</strong>。</p><p>但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一 <strong>id</strong>，称为<strong>Layer</strong>（<strong>层</strong>）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。</p><p>例如，第一步中需要的Linux运行环境，通用性就很强，所以Docker官方就制作了这样的只包含Linux运行环境的镜像。我们在制作java镜像时，就无需重复制作，直接使用Docker官方提供的CentOS或Ubuntu镜像作为基础镜像。然后再搭建其它层即可，这样逐层搭建，最终整个Java项目的镜像结构如图所示：</p><p><img src="/img/load.gif" data-original="/images/environment/docker/docker/a/v5.png" alt="命令关系"></p><h3 id="2-3-2-Dockerfile"><a href="#2-3-2-Dockerfile" class="headerlink" title="2.3.2.Dockerfile"></a>2.3.2.Dockerfile</h3><p>由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以Docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给Docker去执行即可。</p><p>而这种记录镜像结构的文件就称为<strong>Dockerfile</strong>，其对应的语法可以参考官方文档：</p><p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p><p>其中的语法比较多，比较常用的有：</p><table><thead><tr><th align="left"><strong>指令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>示例</strong></th></tr></thead><tbody><tr><td align="left"><strong>FROM</strong></td><td align="left">指定基础镜像</td><td align="left"><code>FROM centos:6</code></td></tr><tr><td align="left"><strong>ENV</strong></td><td align="left">设置环境变量，可在后面指令使用</td><td align="left"><code>ENV key value</code></td></tr><tr><td align="left"><strong>COPY</strong></td><td align="left">拷贝本地文件到镜像的指定目录</td><td align="left"><code>COPY ./xx.jar /tmp/app.jar</code></td></tr><tr><td align="left"><strong>RUN</strong></td><td align="left">执行Linux的shell命令，一般是安装过程的命令</td><td align="left"><code>RUN yum install gcc</code></td></tr><tr><td align="left"><strong>EXPOSE</strong></td><td align="left">指定容器运行时监听的端口，是给镜像使用者看的</td><td align="left">EXPOSE 8080</td></tr><tr><td align="left"><strong>ENTRYPOINT</strong></td><td align="left">镜像中应用的启动命令，容器运行时调用</td><td align="left">ENTRYPOINT java -jar xx.jar</td></tr></tbody></table><p>例如，要基于Ubuntu镜像来构建一个Java应用，其Dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"><span class="comment"># 配置环境变量，JDK的安装目录、容器内时区</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_DIR=/usr/local</span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="comment"># 拷贝jdk和java项目的包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./jdk8.tar.gz <span class="variable">$JAVA_DIR</span>/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./docker-demo.jar /tmp/app.jar</span></span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 安装JDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> <span class="variable">$JAVA_DIR</span> \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; tar -xf ./jdk8.tar.gz \</span></span><br><span class="line"><span class="language-bash"> &amp;&amp; <span class="built_in">mv</span> ./jdk1.8.0_144 ./java8</span></span><br><span class="line"><span class="comment"># 配置环境变量</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=$JAVA_DIR/java8</span><br><span class="line"><span class="keyword">ENV</span> PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="comment"># 指定项目监听的端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># 入口，java项目的启动命令</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>同学们思考一下：以后我们会有很多很多java项目需要打包为镜像，他们都需要Linux系统环境、JDK环境这两层，只有上面的3层不同（因为jar包不同）。如果每次制作java镜像都重复制作前两层镜像，是不是很麻烦。</p><p>所以，就有人提供了基础的系统加JDK环境，我们在此基础上制作java镜像，就可以省去JDK的配置了：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">11.0</span>-jre-buster</span><br><span class="line"><span class="comment"># 设定时区</span></span><br><span class="line"><span class="keyword">ENV</span> TZ=Asia/Shanghai</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TZ</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TZ</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="comment"># 拷贝jar包</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> docker-demo.jar /app.jar</span></span><br><span class="line"><span class="comment"># 入口</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;/app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>是不是简单多了。</p><h3 id="2-3-3-构建镜像"><a href="#2-3-3-构建镜像" class="headerlink" title="2.3.3.构建镜像"></a>2.3.3.构建镜像</h3><p>当 <strong>Dockerfile</strong> 文件写好以后，就可以利用命令来构建镜像了</p><p>准备好了一个demo项目及对应的 <strong>Dockerfile</strong></p><p><img src="/img/load.gif" data-original="/images/environment/docker/docker/a/v6.png" alt="命令关系"></p><p>首先，我们将课前资料提供的<code>docker-demo.jar</code>包以及<code>Dockerfile</code>拷贝到虚拟机的<code>/root/demo</code>目录：</p><p><img src="/img/load.gif" data-original="/images/environment/docker/docker/a/v7.png" alt="命令关系"></p><p>然后，执行命令，构建镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入镜像目录</span></span><br><span class="line"><span class="built_in">cd</span> /root/demo</span><br><span class="line"><span class="comment"># 开始构建</span></span><br><span class="line">docker build -t docker-demo:1.0 .</span><br></pre></td></tr></table></figure><p>命令说明：</p><ul><li><code>docker build </code>: 就是构建一个docker镜像</li><li><code>-t docker-demo:1.0</code> ：<code>-t</code>参数是指定镜像的名称（<code>repository</code>和<code>tag</code>）</li><li><code>.</code> : 最后的点是指构建时Dockerfile所在路径，由于我们进入了demo目录，所以指定的是<code>.</code>代表当前目录，也可以直接指定Dockerfile目录：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接指定Dockerfile目录</span></span><br><span class="line">docker build -t docker-demo:1.0 /root/demo</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/img/load.gif" data-original="/images/environment/docker/docker/a/v8.png" alt="命令关系"></p><p>查看镜像列表：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看镜像列表：</span></span><br><span class="line">docker images</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">docker-demo   1.0       d6ab0b9e64b9   27 minutes ago   327MB</span><br><span class="line">nginx         latest    605c77e624dd   16 months ago    141MB</span><br><span class="line">mysql         latest    3218b38490ce   17 months ago    516MB</span><br></pre></td></tr></table></figure><p>然后尝试运行该镜像：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.创建并运行容器</span></span><br><span class="line">docker run -d --name <span class="built_in">dd</span> -p 8080:8080 docker-demo:1.0</span><br><span class="line"><span class="comment"># 2.查看容器</span></span><br><span class="line">dps</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">CONTAINER ID   IMAGE             PORTS                                                  STATUS         NAMES</span><br><span class="line">78a000447b49   docker-demo:1.0   0.0.0.0:8080-&gt;8080/tcp, :::8090-&gt;8090/tcp              Up 2 seconds   <span class="built_in">dd</span></span><br><span class="line">f63cfead8502   mysql             0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   Up 2 hours     mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.访问</span></span><br><span class="line">curl localhost:8080/hello/count</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">&lt;h5&gt;欢迎访问黑马商城, 这是您第1次访问&lt;h5&gt;</span><br></pre></td></tr></table></figure><h2 id="2-4-网络"><a href="#2-4-网络" class="headerlink" title="2.4.网络"></a>2.4.网络</h2><p>我们创建了一个Java项目的容器，而Java项目往往需要访问其它各种中间件，例如MySQL、Redis等。现在，我们的容器之间能否互相访问呢？我们来测试一下</p><p>首先，我们查看下MySQL容器的详细信息，重点关注其中的网络IP地址：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.用基本命令，寻找Networks.bridge.IPAddress属性</span></span><br><span class="line">docker inspect mysql</span><br><span class="line"><span class="comment"># 也可以使用format过滤结果</span></span><br><span class="line">docker inspect --format=<span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;println .IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> mysql</span><br><span class="line"><span class="comment"># 得到IP地址如下：</span></span><br><span class="line">172.17.0.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后通过命令进入dd容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.在容器内，通过ping命令测试网络</span></span><br><span class="line">ping 172.17.0.2</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.053 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.059 ms</span><br><span class="line">64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.058 ms</span><br></pre></td></tr></table></figure><p>发现可以互联，没有问题。</p><p>但是，容器的网络IP其实是一个虚拟的IP，其值并不固定与某一个容器绑定，如果我们在开发时写死某个IP，而在部署时很可能MySQL容器的IP会发生变化，连接会失败。</p><p>所以，我们必须借助于docker的网络功能来解决这个问题，官方文档：</p><p><a href="https://docs.docker.com/engine/reference/commandline/network/">https://docs.docker.com/engine/reference/commandline/network/</a></p><p>常见命令有：</p><table><thead><tr><th align="left"><strong>命令</strong></th><th align="left"><strong>说明</strong></th><th align="left"><strong>文档地址</strong></th></tr></thead><tbody><tr><td align="left">docker network create</td><td align="left">创建一个网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_create/">docker network create</a></td></tr><tr><td align="left">docker network ls</td><td align="left">查看所有网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_ls/">docs.docker.com</a></td></tr><tr><td align="left">docker network rm</td><td align="left">删除指定网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_rm/">docs.docker.com</a></td></tr><tr><td align="left">docker network prune</td><td align="left">清除未使用的网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_prune/">docs.docker.com</a></td></tr><tr><td align="left">docker network connect</td><td align="left">使指定容器连接加入某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_connect/">docs.docker.com</a></td></tr><tr><td align="left">docker network disconnect</td><td align="left">使指定容器连接离开某网络</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_disconnect/">docker network disconnect</a></td></tr><tr><td align="left">docker network inspect</td><td align="left">查看网络详细信息</td><td align="left"><a href="https://docs.docker.com/engine/reference/commandline/network_inspect/">docker network inspect</a></td></tr></tbody></table><p>教学演示：自定义网络</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.首先通过命令创建一个网络</span></span><br><span class="line">docker network create hmall</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.然后查看网络</span></span><br><span class="line">docker network <span class="built_in">ls</span></span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">NETWORK ID     NAME      DRIVER    SCOPE</span><br><span class="line">639bc44d0a87   bridge    bridge    <span class="built_in">local</span></span><br><span class="line">403f16ec62a2   hmall     bridge    <span class="built_in">local</span></span><br><span class="line">0dc0f72a0fbb   host      host      <span class="built_in">local</span></span><br><span class="line">cd8d3e8df47b   none      null      <span class="built_in">local</span></span><br><span class="line"><span class="comment"># 其中，除了hmall以外，其它都是默认的网络</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.让dd和mysql都加入该网络，注意，在加入网络时可以通过--alias给容器起别名</span></span><br><span class="line"><span class="comment"># 这样该网络内的其它容器可以用别名互相访问！</span></span><br><span class="line"><span class="comment"># 3.1.mysql容器，指定别名为db，另外每一个容器都有一个别名是容器名</span></span><br><span class="line">docker network connect hmall mysql --<span class="built_in">alias</span> db</span><br><span class="line"><span class="comment"># 3.2.db容器，也就是我们的java项目</span></span><br><span class="line">docker network connect hmall <span class="built_in">dd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.进入dd容器，尝试利用别名访问db</span></span><br><span class="line"><span class="comment"># 4.1.进入容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it <span class="built_in">dd</span> bash</span><br><span class="line"><span class="comment"># 4.2.用db别名访问</span></span><br><span class="line">ping db</span><br><span class="line"><span class="comment"># 结果</span></span><br><span class="line">PING db (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.070 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.056 ms</span><br><span class="line"><span class="comment"># 4.3.用容器名访问</span></span><br><span class="line">ping mysql</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">PING mysql (172.18.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=1 ttl=64 time=0.044 ms</span><br><span class="line">64 bytes from mysql.hmall (172.18.0.2): icmp_seq=2 ttl=64 time=0.054 ms</span><br></pre></td></tr></table></figure><p>OK，现在无需记住IP地址也可以实现容器互联了。</p><p><strong>总结</strong>：</p><ul><li>在自定义网络中，可以给容器起多个别名，默认的别名是容器名本身</li><li>在同一个自定义网络中的容器，可以通过别名互相访问</li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis安装说明</title>
      <link href="/posts/6b830637.html"/>
      <url>/posts/6b830637.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/load.gif" data-original="https://pic.crazytaxii.com/Redis_Logo.png"></p><h1 id="Redis安装说明"><a href="#Redis安装说明" class="headerlink" title="Redis安装说明"></a>Redis安装说明</h1><p>大多数企业都是基于Linux服务器来部署项目，而且Redis官方也没有提供Windows版本的安装包。因此我们会基于Linux系统来安装Redis。</p><p>此处选择的Linux版本为CentOS 7.</p><p>Redis的官方网站地址：<a href="https://redis.io/">https://redis.io/</a></p><h1 id="1-单机安装Redis"><a href="#1-单机安装Redis" class="headerlink" title="1.单机安装Redis"></a>1.单机安装Redis</h1><h2 id="1-1-安装Redis依赖"><a href="#1-1-安装Redis依赖" class="headerlink" title="1.1 安装Redis依赖"></a>1.1 安装Redis依赖</h2><p>Redis是基于C语言编写的，因此首先需要安装 <strong>Redis</strong> 所需要的 <strong>gcc</strong> 依赖：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><h2 id="1-2上传安装包并解压"><a href="#1-2上传安装包并解压" class="headerlink" title="1.2上传安装包并解压"></a>1.2上传安装包并解压</h2><p>然后将课前资料提供的 <strong>Redis</strong> 安装包上传到虚拟机的任意目录：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211211071712536.png" alt="image-20211211071712536"></p><p>例如，我放到了&#x2F;usr&#x2F;local&#x2F;src 目录：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211211080151539.png" alt="image-20211211080151539"></p><p>解压缩：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">tar -xzf redis-6.2.6.tar.gz</span><br></pre></td></tr></table></figure><p>解压后：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211211080339076.png" alt="image-20211211080339076"></p><p>进入redis目录：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-6.2.6</span><br></pre></td></tr></table></figure><p>运行编译命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>如果没有出错，应该就安装成功了。</p><p>默认的安装路径是在 <code>/usr/local/bin</code>目录下：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211211080603710.png" alt="image-20211211080603710"></p><p>该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：</p><ul><li>redis-cli：是redis提供的命令行客户端</li><li>redis-server：是redis的服务端启动脚本</li><li>redis-sentinel：是redis的哨兵启动脚本</li></ul><h2 id="1-3-启动"><a href="#1-3-启动" class="headerlink" title="1.3.启动"></a>1.3.启动</h2><p>redis的启动方式有很多种，例如：</p><ul><li>默认启动</li><li>指定配置启动</li><li>开机自启</li></ul><h3 id="1-3-1-默认启动"><a href="#1-3-1-默认启动" class="headerlink" title="1.3.1.默认启动"></a>1.3.1.默认启动</h3><p>安装完成后，在任意目录输入redis-server命令即可启动Redis：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>如图：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211211081716167.png" alt="image-20211211081716167"></p><p>这种启动属于<code>前台启动</code>，会阻塞整个会话窗口，窗口关闭或者按下<code>CTRL + C</code>则Redis停止。不推荐使用。</p><h3 id="1-3-2-指定配置启动"><a href="#1-3-2-指定配置启动" class="headerlink" title="1.3.2.指定配置启动"></a>1.3.2.指定配置启动</h3><p>如果要让Redis以<code>后台</code>方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下（<code>/usr/local/src/redis-6.2.6</code>），名字叫redis.conf：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211211082225509.png" alt="image-20211211082225509"></p><p>我们先将这个配置文件备份一份：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp redis.conf redis.conf.bck</span><br></pre></td></tr></table></figure><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure><p>Redis的其它常见配置：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监听的端口</span></span><br><span class="line"><span class="attr">port</span> <span class="string">6379</span></span><br><span class="line"><span class="comment"># 工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span></span><br><span class="line"><span class="attr">dir</span> <span class="string">.</span></span><br><span class="line"><span class="comment"># 数据库数量，设置为1，代表只使用1个库，默认有16个库，编号0~15</span></span><br><span class="line"><span class="attr">databases</span> <span class="string">1</span></span><br><span class="line"><span class="comment"># 设置redis能够使用的最大内存</span></span><br><span class="line"><span class="attr">maxmemory</span> <span class="string">512mb</span></span><br><span class="line"><span class="comment"># 日志文件，默认为空，不记录日志，可以指定日志文件名</span></span><br><span class="line"><span class="attr">logfile</span> <span class="string">&quot;redis.log&quot;</span></span><br></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入redis安装目录 </span></span><br><span class="line"><span class="built_in">cd</span> /usr/local/src/redis-6.2.6</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p>停止服务：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用redis-cli来执行 shutdown 命令，即可停止 Redis 服务，</span></span><br><span class="line"><span class="comment"># 因为之前配置了密码，因此需要通过 -u 来指定密码</span></span><br><span class="line">redis-cli -u 123321 shutdown</span><br></pre></td></tr></table></figure><h3 id="1-3-3-开机自启"><a href="#1-3-3-开机自启" class="headerlink" title="1.3.3.开机自启"></a>1.3.3.开机自启</h3><p>我们也可以通过配置来实现开机自启。</p><p>首先，新建一个系统服务文件：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure><p>内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>然后重载系统服务：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>现在，我们可以用下面这组命令来操作redis了：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br></pre></td></tr></table></figure><p>执行下面的命令，可以让redis开机自启：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure><h1 id="2-Redis客户端"><a href="#2-Redis客户端" class="headerlink" title="2.Redis客户端"></a>2.Redis客户端</h1><p>安装完成Redis，我们就可以操作Redis，实现数据的CRUD了。这需要用到Redis客户端，包括：</p><ul><li>命令行客户端</li><li>图形化桌面客户端</li><li>编程客户端</li></ul><h2 id="2-1-Redis命令行客户端"><a href="#2-1-Redis命令行客户端" class="headerlink" title="2.1.Redis命令行客户端"></a>2.1.Redis命令行客户端</h2><p>Redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">redis-cli [options] [commonds]</span><br></pre></td></tr></table></figure><p>其中常见的options有：</p><ul><li><code>-h 127.0.0.1</code>：指定要连接的redis节点的IP地址，默认是127.0.0.1</li><li><code>-p 6379</code>：指定要连接的redis节点的端口，默认是6379</li><li><code>-a 123321</code>：指定redis的访问密码</li></ul><p>其中的commonds就是Redis的操作命令，例如：</p><ul><li><code>ping</code>：与redis服务端做心跳测试，服务端正常会返回<code>pong</code></li></ul><p>不指定commond时，会进入<code>redis-cli</code>的交互控制台：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211211110439353.png" alt="image-20211211110439353"></p><h2 id="2-2-图形化桌面客户端"><a href="#2-2-图形化桌面客户端" class="headerlink" title="2.2.图形化桌面客户端"></a>2.2.图形化桌面客户端</h2><p>GitHub上的大神编写了Redis的图形化桌面客户端，地址：<a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a></p><p>不过该仓库提供的是RedisDesktopManager的源码，并未提供windows安装包。</p><p>在下面这个仓库可以找到安装包：<a href="https://github.com/lework/RedisDesktopManager-Windows/releases">https://github.com/lework/RedisDesktopManager-Windows/releases</a></p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211211111351885.png" alt="image-20211211111351885"></p><h3 id="2-2-1-安装"><a href="#2-2-1-安装" class="headerlink" title="2.2.1.安装"></a>2.2.1.安装</h3><p>在课前资料中可以找到Redis的图形化桌面客户端：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211214154938770.png" alt="image-20211214154938770"></p><p>解压缩后，运行安装程序即可安装：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211214155123841.png" alt="image-20211214155123841"></p><p>此处略。</p><p>安装完成后，在安装目录下找到rdm.exe文件：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211211110935819.png" alt="image-20211211110935819"></p><p>双击即可运行：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211214155406692.png" alt="image-20211214155406692"></p><h3 id="2-2-2-建立连接"><a href="#2-2-2-建立连接" class="headerlink" title="2.2.2.建立连接"></a>2.2.2.建立连接</h3><p>点击左上角的<code>连接到Redis服务器</code>按钮：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211214155424842.png" alt="image-20211214155424842"></p><p>在弹出的窗口中填写Redis服务信息：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211211111614483.png" alt="image-20211211111614483"></p><p>点击确定后，在左侧菜单会出现这个链接：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211214155804523.png" alt="image-20211214155804523"></p><p>点击即可建立连接了：</p><p><img src="/img/load.gif" data-original="/images/environment/database/redis/a/image-20211214155849495.png" alt="image-20211214155849495"></p><p>Redis默认有16个仓库，编号从0至15.  通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。</p><p>如果是基于redis-cli连接Redis服务，可以通过select命令来选择数据库：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选择 0号库</span></span><br><span class="line"><span class="keyword">select</span> 0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware</title>
      <link href="/posts/545a6120.html"/>
      <url>/posts/545a6120.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/load.gif" data-original="https://www.abackup.com/easybackup-tutorials/images/backup-vmware/vmware-workstation.png" alt="VMware虚拟机"></p><h1 id="什么是虚拟机"><a href="#什么是虚拟机" class="headerlink" title="什么是虚拟机"></a>什么是虚拟机</h1><p>虚拟机是指软件模拟的具有完整硬件系统功能的，运行在一个完全隔离环境中的完整计算系统，在实体计算机中能够完成的工作，在虚拟机中都能够实现。</p><hr><h1 id="VMware-简介"><a href="#VMware-简介" class="headerlink" title="VMware 简介"></a>VMware 简介</h1><blockquote><p>简而言之，<a href="https://www.vmware.com/"><strong>VMware</strong></a>（链接位于 <strong>ibm.com</strong> 外部）主要用于开发虚拟化软件。</p><p>虚拟化软件会在计算机硬件上创建一个抽象层，从而能够将单台计算机的硬件要素（处理器、内存、存储等）分成多个虚拟计算机（通常称为虚拟机 ( <strong>VM</strong> )）。 每个虚拟机都运行自己的操作系统 ( <strong>OS</strong> )，其行为就像一台独立的计算机，而实际上它只是在一部分底层计算机硬件上运行。</p></blockquote><h2 id="Ⅰ大概介绍"><a href="#Ⅰ大概介绍" class="headerlink" title="Ⅰ大概介绍"></a>Ⅰ大概介绍</h2><p><strong>VMware</strong> 虚拟机软件是一个虚拟 <strong>PC</strong> 软件，它可以让你在一台电脑上运行一个或多个操作系统。</p><h2 id="Ⅱ-详细介绍"><a href="#Ⅱ-详细介绍" class="headerlink" title="Ⅱ 详细介绍"></a>Ⅱ 详细介绍</h2><p><strong>VMware</strong>  是一款功能强大的桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试 、部署新的应用程序的最佳解决方案。<strong>VMware</strong> 可在一部实体机器上模拟完整的网络环境，以及可便于携带的虚拟机器，其更好的灵活性与先进的技术胜过了市面上其他的虚拟计算机软件。</p><hr><h1 id="VMware-下载"><a href="#VMware-下载" class="headerlink" title="VMware 下载"></a>VMware 下载</h1><h2 id="Ⅰ-官网地址"><a href="#Ⅰ-官网地址" class="headerlink" title="Ⅰ 官网地址"></a>Ⅰ 官网地址</h2><p><a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">下载 VMware Workstation Pro | CN</a></p><h2 id="Ⅱ-网盘下载"><a href="#Ⅱ-网盘下载" class="headerlink" title="Ⅱ 网盘下载"></a>Ⅱ 网盘下载</h2><p>打开浏览器搜索 <strong>VMware</strong> 下载，然后打开帖子，复制网盘下载。</p><p>或者打开 <a href="https://www.bilibili.com/"><code>B 站</code></a> ，进行搜索。</p><hr><h1 id="VMware-安装"><a href="#VMware-安装" class="headerlink" title="VMware 安装"></a>VMware 安装</h1><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v1.png" alt="VM安装"></p><p><strong>VMware</strong> 安装，点击下一步</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v2.png" alt="VM安装"></p><p>接受协议，下一步</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v3.png" alt="VM安装"></p><p>自定义 <strong>VMware</strong> 安装位置，下一步</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v4.png" alt="VM安装"></p><p>勾选快捷方式，下一步</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v5.png" alt="VM安装"></p><p>安装 <strong>VMware</strong> 虚拟机，点击完成即可。</p><hr><h1 id="VMware-新建虚拟机"><a href="#VMware-新建虚拟机" class="headerlink" title="VMware 新建虚拟机"></a>VMware 新建虚拟机</h1><p><strong>① 创建新的虚拟机</strong></p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v6.png" alt="VM安装"></p><p><strong>② 选择典型或自定义</strong></p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v7.png" alt="VM安装"></p><p><strong>③ 安装系统驱动</strong></p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v8.png" alt="VM安装"></p><p><strong>④ 下载 Linux 镜像</strong></p><p>网易开源镜像站:<a href="http://mirrors.163.com/">http://mirrors.163.com/</a><br>阿里云官方镜像站:<a href="http://mirrors.aliyun.com/">http://mirrors.aliyun.com</a></p><p>可选 <strong>Centos</strong> 或 <strong>Unbtor</strong></p><div style="display: flex;             justify-content: center;             gap: 10px;             padding: 10px;             background-color: #fff;             border-radius: 10px;             box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);             text-align: center;">    <img src="/img/load.gif" data-original="https://imcn.me/wp-content/uploads/2014/07/centos-logo.jpg" alt="Image 1" style="width: 60%; border-radius: 10px;">    <img src="/img/load.gif" data-original="https://p1.ssl.qhimg.com/t01244e5eda16b4451f.png" alt="Image 2" style="width: 45%; border-radius: 10px;"></div>**⑤ 配置信息**<p><img src="/img/load.gif" data-original="/images/tools/vm/a/v9.png" alt="VM安装"></p><p><strong>⑥ 自定义名称和路径</strong></p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v10.png" alt="VM安装"></p><p><strong>⑦ 设置磁盘</strong></p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v11.png" alt="VM安装"></p><p><strong>⑧ 配置硬件</strong></p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v12.png" alt="VM安装"></p><p><strong>⑨ 点击完成</strong></p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v13.png" alt="VM安装"></p><p>即可完成创建：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v14.png" alt="VM安装"></p><hr><h1 id="安装-Centos7"><a href="#安装-Centos7" class="headerlink" title="安装 Centos7"></a>安装 Centos7</h1><p>接下来，我们启动刚刚创建的虚拟机，开始安装 <code>Centos7</code> 系统：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v14.png" alt="VM安装"></p><p>启动后需要选择安装菜单，将鼠标移入黑窗口中后，将无法再使用鼠标，需要按上下键选择菜单。选中 <strong>Install Centos 7</strong> 后按下回车：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v17.png" alt="VM安装"></p><p>然后会提示我们按下 <strong>enter</strong> 键继续：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v18.png" alt="VM安装"></p><p>过一会儿后，会进入语言选择菜单，这里可以使用鼠标选择。选择中文-简体中文，然后继续：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v19.png" alt="VM安装"></p><p>接下来，会进入安装配置页面：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v20.png" alt="VM安装"></p><p>鼠标向下滚动后，找到系统安装位置配置，点击：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v21.png" alt="VM安装"></p><p>选择刚刚添加的磁盘，并点击完成：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v22.png" alt="VM安装"></p><p>然后回到配置页面，这次点击《网络和主机名》：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v23.png" alt="VM安装"></p><p>在网络页面做下面的几件事情：</p><ol><li>修改主机名为自己喜欢的主机名，不要出现中文和特殊字符，建议用localhost</li><li>点击应用</li><li>将网络连接打开</li><li>点击配置，设置详细网络信息</li></ol><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v24.png" alt="VM安装"></p><p>本机网络详细信息：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v25.png" alt="VM安装"></p><p>点击配置按钮后，我们需要把网卡地址改为静态IP，这样可以避免每次启动虚拟机IP都变化。所有配置照搬你自己截图的网络信息填写：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v26.png" alt="VM安装"></p><p>最后，点击完成按钮：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v27.png" alt="VM安装"></p><p>回到配置界面后，点击<code>开始安装</code>：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v28.png" alt="VM安装"></p><p>接下来需要设置root密码：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v29.png" alt="VM安装"></p><p>填写你要使用的root密码，然后点击完成：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v30.png" alt="VM安装"></p><p>接下来，耐心等待安装即可。</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v31.png" alt="VM安装"></p><p>等待安装完成后，点击<strong>重启</strong>：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v32.png" alt="VM安装"></p><p>输入密码即可登录：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v15.png" alt="VM技巧"></p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v16.png" alt="VM技巧"></p><p>打开中端输入密码切换 root 用户：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v33.png" alt="VM安装"></p><p>此时你要输入密码，不过需要注意的是密码是<strong>隐藏</strong>的，输入了也看不见。所以放心输入，完成后回车即可：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v34.png" alt="VM安装"></p><p>测试网络是否通畅：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure><p>如果看到这样的结果代表网络畅通：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v35.png" alt="VM安装"></p><p>默认ping命令会持续执行，按下<code>CTRL </code>+ <code>C</code>后命令即可停止。</p><hr><h1 id="设置虚拟机快照"><a href="#设置虚拟机快照" class="headerlink" title="设置虚拟机快照"></a>设置虚拟机快照</h1><p>在虚拟机安装完成后，最好立刻设置一个快照，这样一旦将来虚拟机出现问题，可以快速恢复。</p><p>我们先停止虚拟机，点击 <strong>VMware</strong> 顶部菜单中的<code>暂停</code>**<code>下拉选框</code>**，选择<code>关闭客户机</code>：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v36.png" alt="VM快照"></p><p>接着，点击VMware菜单中的🔧按钮:</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v37.png" alt="VM快照"></p><p>然后在弹出的快照管理窗口中，点击 <strong>拍摄快照</strong>，填写新的快照信息：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v38.png" alt="VM快照"></p><p>快照拍摄完成了！而且我们可以在不同阶段拍摄多个不同快照作为备份，方便后期恢复数据。</p><p>假如以后虚拟机文件受损，需要恢复到初始状态的话，可以选中要恢复的快照，点击转到即可：</p><p><img src="/img/load.gif" data-original="/images/tools/vm/a/v39.png" alt="VM快照"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus</title>
      <link href="/posts/8af9e237.html"/>
      <url>/posts/8af9e237.html</url>
      
        <content type="html"><![CDATA[<h1 id="MybatisPlus简介"><a href="#MybatisPlus简介" class="headerlink" title="MybatisPlus简介"></a>MybatisPlus简介</h1><p>在日常开发生活中，单表的 <strong>CRUD</strong> 功能代码重复度很高，也没什么难度，但是这部分代码的开发量往往却比较大，开发起来相当费时。</p><p>因此，目前企业中会使用一些组件来简化 <strong>CRUD</strong> 开发工作，而国内，使用最多的一个组件就是 <strong>MybatisPlus</strong> 。</p><p>官方网站如下：</p><p><a href="https://baomidou.com/"><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v1.png" alt="https://baomidou.com"></a></p><p><strong>MybatisPlus</strong> 不仅仅可以简化单表操作，而且还对 <strong>Mybatis</strong> 进行了增强。可以让我们能够简单高效地进行开发。</p><p>我们需要掌握的内容如下：</p><ul><li><p>能利用 <strong>MybatisPlus</strong> 实现基本的 <strong>CRUD</strong></p></li><li><p>使用条件构造器构建查询和更新语句</p></li><li><p>掌握 <strong>MybatisPlus</strong> 中常用的注解</p></li><li><p>会使用 <strong>MybatisPlus</strong> 处理枚举类、<strong>JSON</strong> 类型字段</p></li><li><p>会使用 <strong>MybatisPlus</strong> 实现分页</p></li></ul><hr><h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><p>创建一个 <strong>MybatisPlus</strong> 项目，并准备一些基础数据。</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v2.png" alt="MybatisPlus项目"></p><h2 id="Ⅰ环境准备"><a href="#Ⅰ环境准备" class="headerlink" title="Ⅰ环境准备"></a>Ⅰ环境准备</h2><p>① 打开 <strong>IDEA</strong> 导入 <strong>MybatisPlus</strong> 项目</p><p>② 打开 <strong>navicat</strong> 导入 <strong>mp.sql</strong> 文件</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v4.png" alt="配置数据库"></p><p>③ 配置项目 <strong>JDK</strong> 版本</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v3.png" alt="配置jdk"></p><p>④ 在 <strong>application.yml</strong> 文件中配置参数</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">com.itheima:</span> <span class="string">debug</span></span><br><span class="line">  <span class="attr">pattern:</span></span><br><span class="line">    <span class="attr">dateformat:</span> <span class="string">HH:mm:ss</span></span><br></pre></td></tr></table></figure><h2 id="Ⅱ-快速开始"><a href="#Ⅱ-快速开始" class="headerlink" title="Ⅱ 快速开始"></a>Ⅱ 快速开始</h2><ul><li>引入 <strong>MybatisPlus</strong> 依赖</li><li>定义 <strong>Mapper</strong></li></ul><h3 id="①-引入依赖"><a href="#①-引入依赖" class="headerlink" title="① 引入依赖"></a>① 引入依赖</h3><p>**MybatisPlus **提供了 <strong>starter</strong>，实现了自动 <strong>Mybatis</strong> 以及 <strong>MybatisPlus</strong> 的自动装配功能，坐标如下：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis-plus-boot-starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该依赖包含了对 <strong>mybatis</strong> 的自动装配，因此不需要 <strong>Mybatis</strong> 的 <strong>starter</strong> 。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis-plus-boot-starter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据库连接--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="②-定义-Mapper"><a href="#②-定义-Mapper" class="headerlink" title="② 定义 Mapper"></a>② 定义 Mapper</h3><p>为了简化单表 <strong>CRUD</strong> 开发，<strong>MybatisPlus</strong> 已经提供了一个基础的 <strong>BaseMapper</strong> 接口来实现单表 <strong>CRUD</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mapper 继承该接口后，无需编写 mapper.xml 文件，即可获得CRUD功能</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;这个 Mapper 支持 id 泛型&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hubin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2016-01-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BaseMapper</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Mapper</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">insert</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 主键ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据实体(ID)删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.4.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteById</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMap 表字段 map 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">deleteByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.delete(Wrappers.&lt;T&gt;query().allEq(columnMap));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除（根据ID或实体 批量删除）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idList 主键ID列表或实体列表(不能为 null 以及 empty)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">deleteBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLL)</span> Collection&lt;?&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 修改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">updateById</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 whereEntity 条件，更新记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity        实体对象 (set 条件值,可以为 null)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(Constants.ENTITY)</span> T entity, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; updateWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 更新记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateWrapper &#123;<span class="doctag">@link</span> UpdateWrapper&#125; or &#123;<span class="doctag">@link</span> LambdaUpdateWrapper&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; updateWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 主键ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    T <span class="title function_">selectById</span><span class="params">(Serializable id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据ID 批量查询）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idList 主键ID列表(不能为 null 以及 empty)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLL)</span> Collection&lt;? extends Serializable&gt; idList)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据ID 批量查询）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idList        idList 主键ID列表(不能为 null 以及 empty)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultHandler resultHandler 结果处理器 &#123;<span class="doctag">@link</span> ResultHandler&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">selectBatchIds</span><span class="params">(<span class="meta">@Param(Constants.COLL)</span> Collection&lt;? extends Serializable&gt; idList, ResultHandler&lt;T&gt; resultHandler)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据 columnMap 条件）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMap 表字段 map 对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;T&gt; <span class="title function_">selectByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.selectList(Wrappers.&lt;T&gt;query().allEq(columnMap));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据 columnMap 条件）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMap     表字段 map 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultHandler resultHandler 结果处理器 &#123;<span class="doctag">@link</span> ResultHandler&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">selectByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap, ResultHandler&lt;T&gt; resultHandler)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.selectList(Wrappers.&lt;T&gt;query().allEq(columnMap), resultHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，查询一条记录</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;查询一条记录，例如 qw.last(&quot;limit 1&quot;) 限制取一条记录, 注意：多条数据会报异常&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.selectOne(queryWrapper, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，查询一条记录，现在会根据&#123;<span class="doctag">@code</span> throwEx&#125;参数判断是否抛出异常，如果为false就直接返回一条数据</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;查询一条记录，例如 qw.last(&quot;limit 1&quot;) 限制取一条记录, 注意：多条数据会报异常&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwEx      boolean 参数，为true如果存在多个结果直接抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> T <span class="title function_">selectOne</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span> &#123;</span><br><span class="line">        List&lt;T&gt; list = <span class="built_in">this</span>.selectList(queryWrapper);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (throwEx) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TooManyResultsException</span>(<span class="string">&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot;</span> + size);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，判断是否存在记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否存在记录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">exists</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.selectCount(queryWrapper);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span> != count &amp;&amp; count &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Long <span class="title function_">selectCount</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper  实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultHandler 结果处理器 &#123;<span class="doctag">@link</span> ResultHandler&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">selectList</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper, ResultHandler&lt;T&gt; resultHandler)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         分页查询条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.3.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;T&gt; <span class="title function_">selectList</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page          分页查询条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper  实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultHandler 结果处理器 &#123;<span class="doctag">@link</span> ResultHandler&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">selectList</span><span class="params">(IPage&lt;T&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper, ResultHandler&lt;T&gt; resultHandler)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper  实体对象封装操作类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultHandler 结果处理器 &#123;<span class="doctag">@link</span> ResultHandler&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">selectMaps</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper, ResultHandler&lt;Map&lt;String, Object&gt;&gt; resultHandler)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         分页查询条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.3.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">selectMaps</span><span class="params">(IPage&lt;? extends Map&lt;String, Object&gt;&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page          分页查询条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper  实体对象封装操作类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultHandler 结果处理器 &#123;<span class="doctag">@link</span> ResultHandler&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">selectMaps</span><span class="params">(IPage&lt;? extends Map&lt;String, Object&gt;&gt; page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper, ResultHandler&lt;Map&lt;String, Object&gt;&gt; resultHandler)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;注意： 只返回第一个字段的值&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;E&gt; List&lt;E&gt; <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;注意： 只返回第一个字段的值&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper  实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultHandler 结果处理器 &#123;<span class="doctag">@link</span> ResultHandler&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.4</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;E&gt; <span class="keyword">void</span> <span class="title function_">selectObjs</span><span class="params">(<span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper, ResultHandler&lt;E&gt; resultHandler)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         分页查询条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类（可以为 null）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;P <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; P <span class="title function_">selectPage</span><span class="params">(P page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        page.setRecords(selectList(page, queryWrapper));</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录（并翻页）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         分页查询条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;P <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; P <span class="title function_">selectMapsPage</span><span class="params">(P page, <span class="meta">@Param(Constants.WRAPPER)</span> Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        page.setRecords(selectMaps(page, queryWrapper));</span><br><span class="line">        <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们只需要将自定义的 <strong>Mapper</strong> 实现 <strong>BaseMapper</strong> 接口，就无需自己实现 <strong>CRUD</strong> 。</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v5.png" alt="配置Mapper"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatisplus.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mybatisplus.domain.entity.UserEntity;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;UserEntity&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="③-测试"><a href="#③-测试" class="headerlink" title="③ 测试"></a>③ 测试</h3><p>新建测试类，进行 <strong>CURD</strong> 测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatisplus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.json.JSONUtil;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.metadata.OrderItem;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.Wrappers;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.pagination.Page;</span><br><span class="line"><span class="keyword">import</span> com.mybatisplus.domain.entity.AddressEntity;</span><br><span class="line"><span class="keyword">import</span> com.mybatisplus.domain.entity.UserEntity;</span><br><span class="line"><span class="keyword">import</span> com.mybatisplus.eum.UserStatus;</span><br><span class="line"><span class="keyword">import</span> com.mybatisplus.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.mybatisplus.service.IAddressService;</span><br><span class="line"><span class="keyword">import</span> com.mybatisplus.service.IUserService;</span><br><span class="line"><span class="keyword">import</span> jakarta.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> org.apache.catalina.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest(classes = MyBatisPlusApplication.class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBatisPlusApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IUserService userService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IAddressService addressService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ①查询出名字中带o的,存款大于等于1000元的用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testQueryMapper</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;UserEntity&gt; userEntityList = userMapper.selectList(Wrappers.lambdaQuery(UserEntity.class)</span><br><span class="line">                .like(UserEntity::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">                .ge(UserEntity::getBalance, <span class="number">1000</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;userEntityList ===&gt; &quot;</span>+userEntityList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ②更新用户名为Jack的用户余额为2000</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdateMapper</span><span class="params">()</span> &#123;</span><br><span class="line">        userMapper.update(Wrappers.lambdaUpdate(UserEntity.class)</span><br><span class="line">                .set(UserEntity::getBalance, <span class="number">2000</span>)</span><br><span class="line">                .eq(UserEntity::getUsername, <span class="string">&quot;Jack&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ③基于UpdateWrapper的更新 更新id为1、2、4的用户余额,扣200</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">        userMapper.update(<span class="literal">null</span>, Wrappers.&lt;UserEntity&gt;update().lambda()</span><br><span class="line">                .setSql(<span class="string">&quot;balance = balance - 200&quot;</span>)</span><br><span class="line">                .in(UserEntity::getId, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义SQL</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testCustomWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">        List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">        <span class="comment">// 2、定义条件</span></span><br><span class="line">        QueryWrapper&lt;UserEntity&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;UserEntity&gt;().in(<span class="string">&quot;id&quot;</span>, ids);</span><br><span class="line">        <span class="comment">// 3.调用mapper的自定义方法，直接传递Wrapper</span></span><br><span class="line">        userMapper.deductBalanceByIds(<span class="number">200</span>, wrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量新增用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testInsertBatch</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;UserEntity&gt; userEntityList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="type">UserEntity</span> <span class="variable">userEntity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserEntity</span>();</span><br><span class="line">            userEntity.setUsername(<span class="string">&quot;user_&quot;</span> + i);</span><br><span class="line">            userEntity.setBalance(<span class="number">1000</span>+i);</span><br><span class="line"><span class="comment">//            userEntity.setInfo(1);</span></span><br><span class="line">            userEntity.setPhone(<span class="string">&quot;phone_&quot;</span>+i);</span><br><span class="line">            userEntity.setStatus(UserStatus.NORMAL);</span><br><span class="line">            userEntity.setPassword(<span class="string">&quot;password_&quot;</span>+i);</span><br><span class="line">            userEntity.setCreateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            userEntity.setUpdateTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="comment">//            userEntity.setInfo(JSONUtil.toJsonStr(1));</span></span><br><span class="line">            userEntityList.add(userEntity);</span><br><span class="line">            <span class="keyword">if</span> (i%<span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                userService.saveBatch(userEntityList);</span><br><span class="line">                <span class="comment">//4、清空集合,准备下一批数据</span></span><br><span class="line">                userEntityList.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span>+(l1-l));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 地址逻辑删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testDelete</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1、删除</span></span><br><span class="line">        addressService.removeById(<span class="number">59L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、查询</span></span><br><span class="line">        <span class="type">AddressEntity</span> <span class="variable">addressEntity</span> <span class="operator">=</span> addressService.getById(<span class="number">59L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;addressEntity ===&gt; &quot;</span>+addressEntity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 枚举处理测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testService</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;UserEntity&gt; list = userService.list();</span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testPageQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.分页查询，new Page()的两个参数分别是：页码、每页大小</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        Page&lt;UserEntity&gt; page = Page.of(current, size);</span><br><span class="line">        <span class="comment">// 1.2、排序</span></span><br><span class="line">        page.addOrder(OrderItem.asc(<span class="string">&quot;balance&quot;</span>));</span><br><span class="line">        page.addOrder(OrderItem.desc(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        Page&lt;UserEntity&gt; p = userService.page(page);</span><br><span class="line">        <span class="comment">// 2.总条数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;total = &quot;</span> + p.getTotal());</span><br><span class="line">        <span class="comment">// 3.总页数</span></span><br><span class="line">        System.out.println(<span class="string">&quot;pages = &quot;</span> + p.getPages());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.数据</span></span><br><span class="line">        List&lt;UserEntity&gt; records = p.getRecords();</span><br><span class="line">        records.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅲ-常见注解"><a href="#Ⅲ-常见注解" class="headerlink" title="Ⅲ 常见注解"></a>Ⅲ 常见注解</h2><p>在上述的案例中我们发现仅仅引入了依赖，继承了 <strong>BaseMapper</strong> 就能够使用 <strong>MybatisPlus</strong> 。但是问题是：</p><p><strong>MybatisPlus</strong> 是怎么知道我们要查询的是哪张表呢？表中有哪些字段呢？</p><p>其实在我们继承 BaseMapper 的时候，就给其指定了一个泛型：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v5.png" alt="配置Mapper"></p><p>泛型中的 <strong>UserEntity</strong> 就是与数据库对应的 <strong>PO</strong> 实体</p><p><strong>MybatisPlus</strong> 就是根据 <strong>PO</strong> 实体的信息来推断出数据库表的信息，从而生成 <strong>SQL</strong>，默认情况是：</p><ul><li><strong>MybatisPlus</strong> 会把 <strong>PO</strong> 实体的类名驼峰转下划线作为表名</li><li><strong>MybatisPlus</strong> 会把 <strong>PO</strong> 实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型</li><li><strong>MybatisPlus</strong> 会把名为 <strong>id</strong> 的字段作为主键</li></ul><p>但在很多情况下，默认的实现与我们的实际场景不符，因此 <strong>MybatisPlus</strong> 提供了一些注解来让我们进行声明</p><h3 id="①-TableName"><a href="#①-TableName" class="headerlink" title="① @TableName"></a>① @TableName</h3><ul><li>描述：表名注解，标识实体类对应的表</li><li>使用位置：实体类</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TableName</strong> 的属性：</p><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>必须指定</strong></th><th><strong>默认值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>表名</td></tr><tr><td>schema</td><td>String</td><td>否</td><td>“”</td><td>schema</td></tr><tr><td>keepGlobalPrefix</td><td>boolean</td><td>否</td><td>false</td><td>是否保持使用全局的 tablePrefix 的值（当全局 tablePrefix 生效时）</td></tr><tr><td>resultMap</td><td>String</td><td>否</td><td>“”</td><td>xml 中 resultMap 的 id（用于满足特定类型的实体类对象绑定）</td></tr><tr><td>autoResultMap</td><td>boolean</td><td>否</td><td>false</td><td>是否自动构建 resultMap 并使用（如果设置 resultMap 则不会进行 resultMap 的自动构建与注入）</td></tr><tr><td>excludeProperty</td><td>String[]</td><td>否</td><td>{}</td><td>需要排除的属性名 @since 3.3.1</td></tr></tbody></table><h3 id="②-TableId"><a href="#②-TableId" class="headerlink" title="② @TableId"></a>② @TableId</h3><ul><li>描述：主键注解，标识实体类中的主键字段</li><li>使用位置：实体类的主键字段</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TableId</strong> 的属性：</p><table><thead><tr><th align="left"><strong>属性</strong></th><th align="left"><strong>类型</strong></th><th align="left"><strong>必须指定</strong></th><th align="left"><strong>默认值</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">value</td><td align="left">String</td><td align="left">否</td><td align="left">“”</td><td align="left">表名</td></tr><tr><td align="left">type</td><td align="left">Enum</td><td align="left">否</td><td align="left">IdType.NONE</td><td align="left">指定主键类型</td></tr></tbody></table><p>**IdType **支持的类型有：</p><table><thead><tr><th align="left"><strong>值</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">AUTO</td><td align="left">数据库 ID 自增</td></tr><tr><td align="left">NONE</td><td align="left">无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT）</td></tr><tr><td align="left">INPUT</td><td align="left">insert 前自行 set 主键值</td></tr><tr><td align="left">ASSIGN_ID</td><td align="left">分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法)</td></tr><tr><td align="left">ASSIGN_UUID</td><td align="left">分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法)</td></tr><tr><td align="left">ID_WORKER</td><td align="left">分布式全局唯一 ID 长整型类型(please use ASSIGN_ID)</td></tr><tr><td align="left">UUID</td><td align="left">32 位 UUID 字符串(please use ASSIGN_UUID)</td></tr><tr><td align="left">ID_WORKER_STR</td><td align="left">分布式全局唯一 ID 字符串类型(please use ASSIGN_ID)</td></tr></tbody></table><p>这里比较常见的有三种：</p><ul><li><code>AUTO</code>：利用数据库的id自增长</li><li><code>INPUT</code>：手动生成id</li><li><code>ASSIGN_ID</code>：雪花算法生成<code>Long</code>类型的全局唯一id，这是默认的ID策略</li></ul><h3 id="③-TableField"><a href="#③-TableField" class="headerlink" title="③ @TableField"></a>③ @TableField</h3><ul><li>描述：普通字段的注解（与数据库字段匹配）</li><li>使用位置：<code>PO</code> 实体的普通字段</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@TableId</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@TableField(&quot;isMarried&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isMarried;</span><br><span class="line">    <span class="meta">@TableField(&quot;concat&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String concat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TableField</strong> 的属性：</p><table><thead><tr><th><strong>属性</strong></th><th><strong>类型</strong></th><th><strong>必填</strong></th><th><strong>默认值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>value</td><td>String</td><td>否</td><td>“”</td><td>数据库字段值</td></tr><tr><td>exist</td><td>boolean</td><td>否</td><td>true</td><td>是否为数据库表字段</td></tr><tr><td>condition</td><td>String</td><td>否</td><td>“”</td><td>字段 where 实体查询比较条件，有值设置则按设置的值为准，没有则为默认全局</td></tr><tr><td>update</td><td>String</td><td>否</td><td>“”</td><td>字段 update set 部分注入，例如：当在version字段上注解update&#x3D;”%s+1” 表示更新时会 set version&#x3D;version+1 （该属性优先级高于 el 属性）</td></tr><tr><td>insertStrategy</td><td>Enum</td><td>否</td><td>FieldStrategy.DEFAULT</td><td>字段验证策略之 insert: 当insert操作时，该字段拼接insert语句时的策略</td></tr><tr><td>updateStrategy</td><td>Enum</td><td>否</td><td>FieldStrategy.DEFAULT</td><td>字段验证策略之 update: 当更新操作时，该字段拼接set语句时的策略</td></tr><tr><td>whereStrategy</td><td>Enum</td><td>否</td><td>FieldStrategy.DEFAULT</td><td>字段验证策略之 where: 表示该字段在拼接where条件时的策略</td></tr><tr><td>fill</td><td>Enum</td><td>否</td><td>FieldFill.DEFAULT</td><td>字段自动填充策略</td></tr><tr><td>select</td><td>boolean</td><td>否</td><td>true</td><td>是否进行 select 查询</td></tr><tr><td>keepGlobalFormat</td><td>boolean</td><td>否</td><td>false</td><td>是否保持使用全局的 format 进行处理</td></tr><tr><td>jdbcType</td><td>JdbcType</td><td>否</td><td>JdbcType.UNDEFINED</td><td>JDBC 类型 (该默认值不代表会按照该值生效)</td></tr><tr><td>typeHandler</td><td>TypeHander</td><td>否</td><td></td><td>类型处理器 (该默认值不代表会按照该值生效)</td></tr><tr><td>numericScale</td><td>String</td><td>否</td><td>“”</td><td>指定小数点后保留的位数</td></tr></tbody></table><h2 id="Ⅳ-常见配置"><a href="#Ⅳ-常见配置" class="headerlink" title="Ⅳ 常见配置"></a>Ⅳ 常见配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="comment"># 全局配置文件位置（可选）</span></span><br><span class="line">  <span class="attr">config-location:</span> <span class="string">classpath:mybatis/mybatis-config.xml</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Mapper XML文件位置</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/**/*.xml</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 配置实体类所在的包名，MyBatis-Plus会自动扫描并注册为别名</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.example.yourproject.model</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 全局配置</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span> <span class="comment"># 全局id类型为自增长</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span> <span class="comment"># 配置表前缀</span></span><br><span class="line">    <span class="comment"># 开启驼峰命名规则转换</span></span><br><span class="line">    <span class="attr">capital-mode:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 配置逻辑删除相关属性</span></span><br><span class="line">    <span class="attr">logic-delete-field:</span> <span class="string">deleted</span></span><br><span class="line">    <span class="attr">logic-delete-value:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 自定义枚举类型转换器</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 分页插件配置</span></span><br><span class="line">  <span class="attr">pagination:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">page-size:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">reasonable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li><strong>config-location</strong> ：用于指定 <strong>Mybatis</strong> 配置文件的路径</li><li><strong>mapper-locations</strong> ：配置 <strong>Mapper</strong> <strong>XML</strong> 文件所在的位置</li><li><strong>type-aliases-package</strong> ：配置实体类所在的包名，<strong>MybatisPlus</strong> 会自动扫描并注册为别名</li><li><strong>global-config</strong> ：全局配置</li><li><strong>configuration</strong> ：自定义配置</li><li><strong>pagination</strong> ：分页插件配置</li></ul><p>大多数的配置都是有默认值的，因此我们都无需配置，但还是有一些没有默认值的，例如：</p><ul><li>实体类的别名扫描包</li><li>全局 <strong>id</strong> 类型</li></ul><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.mp.domain.po</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span> <span class="comment"># 全局id类型为自增长</span></span><br></pre></td></tr></table></figure><p>需要注意的是 MybatisPlus 也支持手写 SQL 的，而 mapper 文件的读取地址可以自己配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">&quot;classpath*:/mapper/**/*.xml&quot;</span> <span class="comment"># Mapper.xml文件地址，当前这个是默认值。</span></span><br></pre></td></tr></table></figure><p>可以看到默认值是 <code>&quot;classpath*:/mapper/**/*.xml&quot;</code>，也就是说我们需要把 Mapper.xml 文件放在这个位置下被加载</p><p>例如：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v6.png" alt="yaml配置"></p><hr><h1 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a>核心功能</h1><h2 id="Ⅰ-条件构造器"><a href="#Ⅰ-条件构造器" class="headerlink" title="Ⅰ 条件构造器"></a>Ⅰ 条件构造器</h2><p>除了新增以外，修改、删除、查询的 <strong>SQL</strong> 语句都需要指定 <strong>where</strong> 条件。因此 <strong>BaseMapper</strong> 中提供了了相关的方法除了支持 <strong>id</strong> 还支持更复杂的 <strong>where</strong> 条件。</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v7.png" alt="BaseMapper"></p><p>参数中的 <strong>Wrapper</strong> 就是条件构造的抽象类，其下有很多默认实现，继承关系如下图所示：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v8.png" alt="BaseMapper"></p><p><strong>Wrapper</strong> 的子类 <strong>AbstractWrapper</strong> 提供了 <strong>where</strong> 中所包含的所有条件构造方法：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v9.png" alt="AbstractWrapper"></p><p>而 <strong>QueryWrapper</strong> 在 <strong>AbstractWrapper</strong>  基础上拓展了一个 select 方法，用于指定查询字段：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueryWrapper</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AbstractWrapper</span>&lt;T, String, QueryWrapper&lt;T&gt;&gt; <span class="keyword">implements</span> <span class="title class_">Query</span>&lt;QueryWrapper&lt;T&gt;, T, String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SharedString sqlSelect;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>((Object)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QueryWrapper</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSelect = <span class="keyword">new</span> <span class="title class_">SharedString</span>();</span><br><span class="line">        <span class="built_in">super</span>.setEntity(entity);</span><br><span class="line">        <span class="built_in">super</span>.initNeed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">QueryWrapper</span><span class="params">(T entity, String... columns)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSelect = <span class="keyword">new</span> <span class="title class_">SharedString</span>();</span><br><span class="line">        <span class="built_in">super</span>.setEntity(entity);</span><br><span class="line">        <span class="built_in">super</span>.initNeed();</span><br><span class="line">        <span class="built_in">this</span>.select(columns);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">QueryWrapper</span><span class="params">(T entity, Class&lt;T&gt; entityClass, AtomicInteger paramNameSeq, Map&lt;String, Object&gt; paramNameValuePairs, MergeSegments mergeSegments, SharedString paramAlias, SharedString lastSql, SharedString sqlComment, SharedString sqlFirst)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sqlSelect = <span class="keyword">new</span> <span class="title class_">SharedString</span>();</span><br><span class="line">        <span class="built_in">super</span>.setEntity(entity);</span><br><span class="line">        <span class="built_in">super</span>.setEntityClass(entityClass);</span><br><span class="line">        <span class="built_in">this</span>.paramNameSeq = paramNameSeq;</span><br><span class="line">        <span class="built_in">this</span>.paramNameValuePairs = paramNameValuePairs;</span><br><span class="line">        <span class="built_in">this</span>.expression = mergeSegments;</span><br><span class="line">        <span class="built_in">this</span>.paramAlias = paramAlias;</span><br><span class="line">        <span class="built_in">this</span>.lastSql = lastSql;</span><br><span class="line">        <span class="built_in">this</span>.sqlComment = sqlComment;</span><br><span class="line">        <span class="built_in">this</span>.sqlFirst = sqlFirst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SafeVarargs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> QueryWrapper&lt;T&gt; <span class="title function_">select</span><span class="params">(String... columns)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.select(Arrays.asList(columns));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> QueryWrapper&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;String&gt; columns)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(columns)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.sqlSelect.setStringValue(String.join(<span class="string">&quot;,&quot;</span>, columns));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (QueryWrapper)<span class="built_in">this</span>.typedThis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> QueryWrapper&lt;T&gt; <span class="title function_">select</span><span class="params">(Class&lt;T&gt; entityClass, Predicate&lt;TableFieldInfo&gt; predicate)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setEntityClass(entityClass);</span><br><span class="line">        <span class="built_in">this</span>.sqlSelect.setStringValue(TableInfoHelper.getTableInfo(<span class="built_in">this</span>.getEntityClass()).chooseSelect(predicate));</span><br><span class="line">        <span class="keyword">return</span> (QueryWrapper)<span class="built_in">this</span>.typedThis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSqlSelect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.sqlSelect.getStringValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">columnSqlInjectFilter</span><span class="params">(String column)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.sqlInjectionReplaceBlank(column);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LambdaQueryWrapper&lt;T&gt; <span class="title function_">lambda</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>(<span class="built_in">this</span>.getEntity(), <span class="built_in">this</span>.getEntityClass(), <span class="built_in">this</span>.sqlSelect, <span class="built_in">this</span>.paramNameSeq, <span class="built_in">this</span>.paramNameValuePairs, <span class="built_in">this</span>.expression, <span class="built_in">this</span>.paramAlias, <span class="built_in">this</span>.lastSql, <span class="built_in">this</span>.sqlComment, <span class="built_in">this</span>.sqlFirst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> QueryWrapper&lt;T&gt; <span class="title function_">instance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>(<span class="built_in">this</span>.getEntity(), <span class="built_in">this</span>.getEntityClass(), <span class="built_in">this</span>.paramNameSeq, <span class="built_in">this</span>.paramNameValuePairs, <span class="keyword">new</span> <span class="title class_">MergeSegments</span>(), <span class="built_in">this</span>.paramAlias, SharedString.emptyString(), SharedString.emptyString(), SharedString.emptyString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.clear();</span><br><span class="line">        <span class="built_in">this</span>.sqlSelect.toNull();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <strong>UpdateWrapper</strong> 则在 <strong>AbstractWrapper</strong>  基础上拓展了了一个 <strong>set</strong> 方法，用于指定 <strong>SQL</strong> 中的 <strong>SET</strong> 部分：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UpdateWrapper</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AbstractWrapper</span>&lt;T, String, UpdateWrapper&lt;T&gt;&gt; <span class="keyword">implements</span> <span class="title class_">Update</span>&lt;UpdateWrapper&lt;T&gt;, String&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; sqlSet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UpdateWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>((Object)<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UpdateWrapper</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setEntity(entity);</span><br><span class="line">        <span class="built_in">super</span>.initNeed();</span><br><span class="line">        <span class="built_in">this</span>.sqlSet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">UpdateWrapper</span><span class="params">(T entity, List&lt;String&gt; sqlSet, AtomicInteger paramNameSeq, Map&lt;String, Object&gt; paramNameValuePairs, MergeSegments mergeSegments, SharedString paramAlias, SharedString lastSql, SharedString sqlComment, SharedString sqlFirst)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setEntity(entity);</span><br><span class="line">        <span class="built_in">this</span>.sqlSet = sqlSet;</span><br><span class="line">        <span class="built_in">this</span>.paramNameSeq = paramNameSeq;</span><br><span class="line">        <span class="built_in">this</span>.paramNameValuePairs = paramNameValuePairs;</span><br><span class="line">        <span class="built_in">this</span>.expression = mergeSegments;</span><br><span class="line">        <span class="built_in">this</span>.paramAlias = paramAlias;</span><br><span class="line">        <span class="built_in">this</span>.lastSql = lastSql;</span><br><span class="line">        <span class="built_in">this</span>.sqlComment = sqlComment;</span><br><span class="line">        <span class="built_in">this</span>.sqlFirst = sqlFirst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSqlSet</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CollectionUtils.isEmpty(<span class="built_in">this</span>.sqlSet) ? <span class="literal">null</span> : String.join(<span class="string">&quot;,&quot;</span>, <span class="built_in">this</span>.sqlSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UpdateWrapper&lt;T&gt; <span class="title function_">set</span><span class="params">(<span class="type">boolean</span> condition, String column, Object val, String mapping)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (UpdateWrapper)<span class="built_in">this</span>.maybeDo(condition, () -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="built_in">this</span>.formatParam(mapping, val);</span><br><span class="line">            <span class="built_in">this</span>.sqlSet.add(column + <span class="string">&quot;=&quot;</span> + sql);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UpdateWrapper&lt;T&gt; <span class="title function_">setSql</span><span class="params">(<span class="type">boolean</span> condition, String sql)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (condition &amp;&amp; StringUtils.isNotBlank(sql)) &#123;</span><br><span class="line">            <span class="built_in">this</span>.sqlSet.add(sql);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (UpdateWrapper)<span class="built_in">this</span>.typedThis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String <span class="title function_">columnSqlInjectFilter</span><span class="params">(String column)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.sqlInjectionReplaceBlank(column);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LambdaUpdateWrapper&lt;T&gt; <span class="title function_">lambda</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LambdaUpdateWrapper</span>(<span class="built_in">this</span>.getEntity(), <span class="built_in">this</span>.getEntityClass(), <span class="built_in">this</span>.sqlSet, <span class="built_in">this</span>.paramNameSeq, <span class="built_in">this</span>.paramNameValuePairs, <span class="built_in">this</span>.expression, <span class="built_in">this</span>.paramAlias, <span class="built_in">this</span>.lastSql, <span class="built_in">this</span>.sqlComment, <span class="built_in">this</span>.sqlFirst);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> UpdateWrapper&lt;T&gt; <span class="title function_">instance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>(<span class="built_in">this</span>.getEntity(), (List)<span class="literal">null</span>, <span class="built_in">this</span>.paramNameSeq, <span class="built_in">this</span>.paramNameValuePairs, <span class="keyword">new</span> <span class="title class_">MergeSegments</span>(), <span class="built_in">this</span>.paramAlias, SharedString.emptyString(), SharedString.emptyString(), SharedString.emptyString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.clear();</span><br><span class="line">        <span class="built_in">this</span>.sqlSet.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="①-QueryWrapper"><a href="#①-QueryWrapper" class="headerlink" title="① QueryWrapper"></a>① QueryWrapper</h3><p>无论是修改、更新、查询，都可以使用 QueryWrapper 来构建查询条件。</p><p><strong>查询：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ①查询出名字中带o的,存款大于等于1000元的用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建查询条件 where name like &quot;%o%&quot; AND balance &gt;= 1000</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">            .select(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;username&quot;</span>, <span class="string">&quot;info&quot;</span>, <span class="string">&quot;balance&quot;</span>)</span><br><span class="line">            .like(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(<span class="string">&quot;balance&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    <span class="comment">// 2.查询数据</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>更新：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ②更新用户名为Jack的用户余额为2000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateByQueryWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.构建查询条件 where name = &quot;Jack&quot;</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().eq(<span class="string">&quot;username&quot;</span>, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.更新数据，user中非null字段都会作为set语句</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setBalance(<span class="number">2000</span>);</span><br><span class="line">    userMapper.update(user, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②-UpdateWrapper"><a href="#②-UpdateWrapper" class="headerlink" title="② UpdateWrapper"></a>② UpdateWrapper</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ③基于UpdateWrapper的更新 更新id为1、2、4的用户余额,扣200</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    userMapper.update(<span class="literal">null</span>, Wrappers.&lt;UserEntity&gt;update().lambda()</span><br><span class="line">            .setSql(<span class="string">&quot;balance = balance - 200&quot;</span>)</span><br><span class="line">            .in(UserEntity::getId, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="③-LambdaQueryWrapper"><a href="#③-LambdaQueryWrapper" class="headerlink" title="③ LambdaQueryWrapper"></a>③ LambdaQueryWrapper</h3><p>其中一种办法是基于变量的 <strong>gettter</strong> 方法结合反射技术。因此我们只要将条件对应的字段的 <strong>gettter</strong> 方法传递给 <strong>MybatisPlus</strong> ，它就能计算出对应的变量名了。而传递方法可以使用 <strong>JDK8</strong> 中的<code>方法引用</code>和 <strong>Lambda</strong> 表达式。 因此 <strong>MybatisPlus</strong> 又提供了一套基于 <strong>Lambda</strong> 的 <strong>Wrapper</strong> ，包含两个：</p><ul><li><strong>LambdaQueryWrapper</strong></li><li><strong>LambdaUpdateWrapper</strong></li></ul><p>分别对应 <strong>QueryWrapper</strong> 和 <strong>UpdateWrappe</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ①查询出名字中带o的,存款大于等于1000元的用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQueryMapper</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;UserEntity&gt; userEntityList = userMapper.selectList(Wrappers.lambdaQuery(UserEntity.class)</span><br><span class="line">            .like(UserEntity::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(UserEntity::getBalance, <span class="number">1000</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;userEntityList ===&gt; &quot;</span>+userEntityList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ②更新用户名为Jack的用户余额为2000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateMapper</span><span class="params">()</span> &#123;</span><br><span class="line">    userMapper.update(Wrappers.lambdaUpdate(UserEntity.class)</span><br><span class="line">            .set(UserEntity::getBalance, <span class="number">2000</span>)</span><br><span class="line">            .eq(UserEntity::getUsername, <span class="string">&quot;Jack&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ③基于UpdateWrapper的更新 更新id为1、2、4的用户余额,扣200</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    userMapper.update(<span class="literal">null</span>, Wrappers.&lt;UserEntity&gt;update().lambda()</span><br><span class="line">            .setSql(<span class="string">&quot;balance = balance - 200&quot;</span>)</span><br><span class="line">            .in(UserEntity::getId, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅱ-自定义-SQL"><a href="#Ⅱ-自定义-SQL" class="headerlink" title="Ⅱ 自定义 SQL"></a>Ⅱ 自定义 SQL</h2><p><strong>MybatisPlus</strong> 提供了自定义 <strong>SQL</strong> 功能，可以让我们先利用 <strong>Wrapper</strong> 来构建查询条件，然后再结合 <strong>Mapper.xml</strong> 来编写 <strong>SQL</strong></p><h3 id="①-基本用法"><a href="#①-基本用法" class="headerlink" title="① 基本用法"></a>① 基本用法</h3><p>先构建查询条件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义SQL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    List&lt;Long&gt; ids = List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>);</span><br><span class="line">    <span class="comment">// 2、定义条件</span></span><br><span class="line">    QueryWrapper&lt;UserEntity&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;UserEntity&gt;().in(<span class="string">&quot;id&quot;</span>, ids);</span><br><span class="line">    <span class="comment">// 3.调用mapper的自定义方法，直接传递Wrapper</span></span><br><span class="line">    userMapper.deductBalanceByIds(<span class="number">200</span>, wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在 <strong>UserMapper</strong> 中定义 <strong>SQL</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;UserEntity&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalanceByIds</span><span class="params">(<span class="meta">@Param(&quot;money&quot;)</span> <span class="type">int</span> money, <span class="meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;UserEntity&gt; wrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②-多表关联"><a href="#②-多表关联" class="headerlink" title="② 多表关联"></a>② 多表关联</h3><p>理论上来说 <strong>MybatisPlus</strong> 是单表操作不支持多表关联的，不过我们可以利用 <strong>Wrapper</strong> 中自定义条件结合自定义 <strong>SQL</strong> 来实现多表查询的效果。</p><p>例如，我们要查出所有收获地址在北京并且用户 <strong>id</strong> 在 1、2、4 的用户</p><p>如果是基于 <strong>mybatis</strong> 实现 <strong>SQL</strong>：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndAddr&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class="line">      SELECT *</span><br><span class="line">      FROM user u</span><br><span class="line">      INNER JOIN address a ON u.id = a.user_id</span><br><span class="line">      WHERE u.id</span><br><span class="line">      <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;IN (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span>&gt;</span></span><br><span class="line">          #&#123;id&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">      AND a.city = #&#123;city&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们也可以使用自定义 <strong>SQL</strong> 结合 <strong>Wrapper</strong> ：</p><p>先构建查询条件：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCustomJoinWrapper</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.准备自定义查询条件</span></span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;()</span><br><span class="line">            .in(<span class="string">&quot;u.id&quot;</span>, List.of(<span class="number">1L</span>, <span class="number">2L</span>, <span class="number">4L</span>))</span><br><span class="line">            .eq(<span class="string">&quot;a.city&quot;</span>, <span class="string">&quot;北京&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.调用mapper的自定义方法</span></span><br><span class="line">    List&lt;User&gt; users = userMapper.queryUserByWrapper(wrapper);</span><br><span class="line"></span><br><span class="line">    users.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在 <strong>UserMapper</strong> 中自定义 <strong>SQL</strong> 方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;SELECT u.* FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">queryUserByWrapper</span><span class="params">(<span class="meta">@Param(&quot;ew&quot;)</span>QueryWrapper&lt;User&gt; wrapper)</span>;</span><br></pre></td></tr></table></figure><p>当然也可以在 <strong>UserMapper.xml</strong> 中写 <strong>SQL</strong>：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserByIdAndAddr&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.mp.domain.po.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user u INNER JOIN address a ON u.id = a.user_id $&#123;ew.customSqlSegment&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Ⅲ-Service-接口"><a href="#Ⅲ-Service-接口" class="headerlink" title="Ⅲ Service 接口"></a>Ⅲ Service 接口</h2><p>通用接口为 <strong>Iservice</strong> ，默认实现为 **ServiceImpl **，其中封装方法为一下几类：</p><ul><li><code>save</code>：新增</li><li><code>remove</code>：删除</li><li><code>update</code>：更新</li><li><code>get</code>：查询单个结果</li><li><code>list</code>：查询集合结果</li><li><code>count</code>：计数</li><li><code>page</code>：分页查询</li></ul><h3 id="①-CRUD"><a href="#①-CRUD" class="headerlink" title="① CRUD"></a>① CRUD</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IService</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">DEFAULT_BATCH_SIZE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save 新增</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(<span class="built_in">this</span>.getBaseMapper().insert(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.saveBatch(entityList, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.saveOrUpdateBatch(entityList, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(<span class="built_in">this</span>.getBaseMapper().deleteById(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove 删除</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id, <span class="type">boolean</span> useFill)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持的方法!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(<span class="built_in">this</span>.getBaseMapper().deleteById(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span> &#123;</span><br><span class="line">        Assert.notEmpty(columnMap, <span class="string">&quot;error: columnMap must not be empty&quot;</span>, <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(<span class="built_in">this</span>.getBaseMapper().deleteByMap(columnMap));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(<span class="built_in">this</span>.getBaseMapper().delete(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;?&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CollectionUtils.isEmpty(list) ? <span class="literal">false</span> : SqlHelper.retBool(<span class="built_in">this</span>.getBaseMapper().deleteBatchIds(list));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;?&gt; list, <span class="type">boolean</span> useFill)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(list)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> useFill ? <span class="built_in">this</span>.removeBatchByIds(list, <span class="literal">true</span>) : SqlHelper.retBool(<span class="built_in">this</span>.getBaseMapper().deleteBatchIds(list));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeBatchByIds</span><span class="params">(Collection&lt;?&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.removeBatchByIds(list, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeBatchByIds</span><span class="params">(Collection&lt;?&gt; list, <span class="type">boolean</span> useFill)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.removeBatchByIds(list, <span class="number">1000</span>, useFill);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeBatchByIds</span><span class="params">(Collection&lt;?&gt; list, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持的方法!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">removeBatchByIds</span><span class="params">(Collection&lt;?&gt; list, <span class="type">int</span> batchSize, <span class="type">boolean</span> useFill)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>(<span class="string">&quot;不支持的方法!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update 修改</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(<span class="built_in">this</span>.getBaseMapper().updateById(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Wrapper&lt;T&gt; updateWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.update((Object)<span class="literal">null</span>, updateWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(<span class="built_in">this</span>.getBaseMapper().update(entity, updateWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(</span></span><br><span class="line"><span class="meta">        rollbackFor = &#123;Exception.class&#125;</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.updateBatchById(entityList, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 查询单个结果</span></span><br><span class="line">    <span class="keyword">default</span> T <span class="title function_">getById</span><span class="params">(Serializable id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getBaseMapper().selectById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list 查询集合结果</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getBaseMapper().selectBatchIds(idList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getBaseMapper().selectByMap(columnMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get 查询单个结果对象</span></span><br><span class="line">    <span class="keyword">default</span> T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getOne(queryWrapper, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T <span class="title function_">getOne</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span>;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span>;</span><br><span class="line"></span><br><span class="line">    &lt;V&gt; V <span class="title function_">getObj</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count 计数</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count(Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retCount(<span class="built_in">this</span>.getBaseMapper().selectCount(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list 查询集合结果</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;T&gt; <span class="title function_">list</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getBaseMapper().selectList(queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;T&gt; <span class="title function_">list</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.list(Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ipage 分页</span></span><br><span class="line">    <span class="keyword">default</span> &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; E <span class="title function_">page</span><span class="params">(E page, Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getBaseMapper().selectPage(page, queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;T&gt;&gt; E <span class="title function_">page</span><span class="params">(E page)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.page(page, Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list 查询集合结果</span></span><br><span class="line">    <span class="keyword">default</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getBaseMapper().selectMaps(queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.listMaps(Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.listObjs(Function.identity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.listObjs(Wrappers.emptyWrapper(), mapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> List&lt;Object&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.listObjs(queryWrapper, Function.identity());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Wrapper&lt;T&gt; queryWrapper, Function&lt;? <span class="built_in">super</span> Object, V&gt; mapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (List)<span class="built_in">this</span>.getBaseMapper().selectObjs(queryWrapper).stream().filter(Objects::nonNull).map(mapper).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ipage 分页</span></span><br><span class="line">    <span class="keyword">default</span> &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; E <span class="title function_">pageMaps</span><span class="params">(E page, Wrapper&lt;T&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getBaseMapper().selectMapsPage(page, queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; E <span class="title function_">pageMaps</span><span class="params">(E page)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.pageMaps(page, Wrappers.emptyWrapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BaseMapper&lt;T&gt; <span class="title function_">getBaseMapper</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;T&gt; <span class="title function_">getEntityClass</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> QueryChainWrapper&lt;T&gt; <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.queryChain(<span class="built_in">this</span>.getBaseMapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> LambdaQueryChainWrapper&lt;T&gt; <span class="title function_">lambdaQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.lambdaQueryChain(<span class="built_in">this</span>.getBaseMapper(), <span class="built_in">this</span>.getEntityClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> LambdaQueryChainWrapper&lt;T&gt; <span class="title function_">lambdaQuery</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.lambdaQueryChain(<span class="built_in">this</span>.getBaseMapper(), entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> KtQueryChainWrapper&lt;T&gt; <span class="title function_">ktQuery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.ktQueryChain(<span class="built_in">this</span>.getBaseMapper(), <span class="built_in">this</span>.getEntityClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> KtUpdateChainWrapper&lt;T&gt; <span class="title function_">ktUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.ktUpdateChain(<span class="built_in">this</span>.getBaseMapper(), <span class="built_in">this</span>.getEntityClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> UpdateChainWrapper&lt;T&gt; <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.updateChain(<span class="built_in">this</span>.getBaseMapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> LambdaUpdateChainWrapper&lt;T&gt; <span class="title function_">lambdaUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.lambdaUpdateChain(<span class="built_in">this</span>.getBaseMapper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, Wrapper&lt;T&gt; updateWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.update(entity, updateWrapper) || <span class="built_in">this</span>.saveOrUpdate(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>新增：</strong></p><ul><li><code>save</code>是新增单个元素</li><li><code>saveBatch</code>是批量新增</li><li><code>saveOrUpdate</code>是根据id判断，如果数据存在就更新，不存在则新增</li><li><code>saveOrUpdateBatch</code>是批量的新增或修改</li></ul><p><strong>删除：</strong></p><ul><li><code>removeById</code>：根据id删除</li><li><code>removeByIds</code>：根据id批量删除</li><li><code>removeByMap</code>：根据Map中的键值对为条件删除</li><li><code>remove(Wrapper&lt;T&gt;)</code>：根据Wrapper条件删除</li><li><code>~~removeBatchByIds~~</code>：暂不支持</li></ul><p><strong>修改：</strong></p><ul><li><code>updateById</code>：根据id修改</li><li><code>update(Wrapper&lt;T&gt;)</code>：根据<code>UpdateWrapper</code>修改，<code>Wrapper</code>中包含<code>set</code>和<code>where</code>部分</li><li><code>update(T，Wrapper&lt;T&gt;)</code>：按照<code>T</code>内的数据修改与<code>Wrapper</code>匹配到的数据</li><li><code>updateBatchById</code>：根据id批量修改</li></ul><p><strong>Get：</strong></p><ul><li><code>getById</code>：根据id查询1条数据</li><li><code>getOne(Wrapper&lt;T&gt;)</code>：根据<code>Wrapper</code>查询1条数据</li><li><code>getBaseMapper</code>：获取<code>Service</code>内的<code>BaseMapper</code>实现，某些时候需要直接调用<code>Mapper</code>内的自定义<code>SQL</code>时可以用这个方法获取到<code>Mapper</code></li></ul><p><strong>List：</strong></p><ul><li><code>listByIds</code>：根据id批量查询</li><li><code>list(Wrapper&lt;T&gt;)</code>：根据Wrapper条件查询多条数据</li><li><code>list()</code>：查询所有</li></ul><p><strong>Count</strong>：</p><ul><li><code>count()</code>：统计所有数量</li><li><code>count(Wrapper&lt;T&gt;)</code>：统计符合<code>Wrapper</code>条件的数据数量</li></ul><p><strong>getBaseMapper</strong>：</p><ul><li>当我们在service中要调用Mapper中自定义SQL时，就必须获取service对应的Mapper，就可以通过这个方法</li></ul><h3 id="②-基本用法"><a href="#②-基本用法" class="headerlink" title="② 基本用法"></a>② 基本用法</h3><p>首先，定义 <strong>IUserService</strong> ，继承 <strong>IService</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;User&gt; &#123;</span><br><span class="line">    <span class="comment">// 拓展自定义方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，编写 <strong>UserServiceImpl</strong> 类，继承 <strong>ServiceImpl</strong> ，实现 <strong>UserService</strong>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, User&gt;<span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目结构如下：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v10.png" alt="AbstractWrapper"></p><p>接下来，我们快速实现下面4个接口：</p><table><thead><tr><th align="left"><strong>编号</strong></th><th align="left"><strong>接口</strong></th><th align="left"><strong>请求方式</strong></th><th align="left"><strong>请求路径</strong></th><th align="left"><strong>请求参数</strong></th><th align="left"><strong>返回值</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left">新增用户</td><td align="left">POST</td><td align="left">&#x2F;users</td><td align="left">用户表单实体</td><td align="left">无</td></tr><tr><td align="left">2</td><td align="left">删除用户</td><td align="left">DELETE</td><td align="left">&#x2F;users&#x2F;{id}</td><td align="left">用户id</td><td align="left">无</td></tr><tr><td align="left">3</td><td align="left">根据id查询用户</td><td align="left">GET</td><td align="left">&#x2F;users&#x2F;{id}</td><td align="left">用户id</td><td align="left">用户VO</td></tr><tr><td align="left">4</td><td align="left">根据id批量查询</td><td align="left">GET</td><td align="left">&#x2F;users</td><td align="left">用户id集合</td><td align="left">用户VO集合</td></tr></tbody></table><p>为了方便测试，引入 <strong>swagger-knife4j：</strong></p><p>依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-openapi2-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--web--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>yml</strong> 文件中 <strong>swagger</strong> 配置</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">knife4j:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">openapi:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">用户管理接口文档</span></span><br><span class="line">    <span class="attr">description:</span> <span class="string">&quot;用户管理接口文档&quot;</span></span><br><span class="line">    <span class="attr">email:</span> <span class="string">xxx@qq.com</span></span><br><span class="line">    <span class="attr">concat:</span> <span class="string">violet</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">https://violet.zeabur.app/</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">v1.0.0</span></span><br><span class="line">    <span class="attr">group:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">group-name:</span> <span class="string">default</span></span><br><span class="line">        <span class="attr">api-rule:</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">api-rule-resources:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">com.mybatisplus.controller</span></span><br></pre></td></tr></table></figure><p><strong>UserController：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户控制器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lixuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/8/7 17:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@Tag(name = &quot;用户控制器&quot;)</span></span><br><span class="line"><span class="meta">@RequiredArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(UserController.class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IUserService userService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IAddressService addressService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getUser/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;查询用户 getUser/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserVO <span class="title function_">getUser</span><span class="params">(<span class="meta">@Parameter(description = &quot;用户ID&quot;)</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">userEntity</span> <span class="operator">=</span> userService.getById(id);</span><br><span class="line">        <span class="keyword">return</span> BeanUtil.copyProperties(userEntity, UserVO.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getAllUser&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;查询所有用户 getAllUser&quot;, ignoreJsonView = true)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">getAllUser</span><span class="params">(<span class="meta">@ParameterObject</span> UserEntity userEntity)</span> &#123;</span><br><span class="line">        QueryWrapper&lt;UserEntity&gt; queryWrapper = ConditionUtil.buildQueryWrapper(userEntity, UserEntity.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;queryWrapper ===&gt; &quot;</span>+queryWrapper);</span><br><span class="line">        List&lt;UserEntity&gt; userEntityList = userService.list(queryWrapper);</span><br><span class="line">        List&lt;UserVO&gt; userVOS = BeanUtil.copyToList(userEntityList, UserVO.class);</span><br><span class="line">        userVOS.forEach(userVO -&gt; System.out.println(userVO.getUsername()));</span><br><span class="line">        <span class="keyword">return</span> BeanUtil.copyToList(userEntityList, UserVO.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getUserByPage&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;分页查询 getUserByPage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Page&lt;UserEntity&gt; <span class="title function_">getUserByPage</span><span class="params">(<span class="meta">@ParameterObject</span> UserEntity userEntity,<span class="meta">@ParameterObject</span> Query query)</span> &#123;</span><br><span class="line">        QueryWrapper&lt;UserEntity&gt; queryWrapper = ConditionUtil.buildQueryWrapper(userEntity, UserEntity.class);</span><br><span class="line">        Page&lt;UserEntity&gt; page = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(query.getCurrent(), query.getSize()), queryWrapper);</span><br><span class="line">        System.out.println(<span class="string">&quot;page ===&gt; &quot;</span>+page);</span><br><span class="line">        <span class="keyword">return</span> userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(query.getCurrent(), query.getSize()), queryWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/addUser&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;新增用户 addUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addUser</span><span class="params">(<span class="meta">@RequestBody</span> UserDTO userDTO)</span> &#123;</span><br><span class="line">        <span class="comment">//1、把DTO转换为实体Entity</span></span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">userEntity</span> <span class="operator">=</span> BeanUtil.copyProperties(userDTO, UserEntity.class);</span><br><span class="line">        <span class="keyword">return</span> userService.save(userEntity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/updateUser&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;修改用户 updateUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateUser</span><span class="params">(<span class="meta">@RequestBody</span> UserEntity userEntity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.updateById(userEntity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/deleteUser&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;删除用户 deleteUser&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteUser</span><span class="params">(<span class="meta">@RequestParam</span> Long id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.removeById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量删除用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/deleteUserBatch&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;批量删除用户 deleteUserBatch&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteUserBatch</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.removeByIds(ids);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扣减用户余额</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PutMapping(&quot;/&#123;id&#125;/deduction/&#123;money&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;扣减用户余额 &#123;id&#125;/deduction/&#123;money&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deductBalance</span><span class="params">(</span></span><br><span class="line"><span class="params">            <span class="meta">@Parameter(description = &quot;用户id&quot;)</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> Long id,</span></span><br><span class="line"><span class="params">            <span class="meta">@Parameter(description = &quot;扣减金额&quot;)</span> <span class="meta">@PathVariable(&quot;money&quot;)</span> Integer money)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userService.deductBalance(id, money);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户并且对应其地址足迹</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getUserAndAddress/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;查询用户并且对应其地址足迹 getUserAndAddress/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> UserVO <span class="title function_">getUserAndAddress</span><span class="params">(<span class="meta">@Parameter(description = &quot;用户ID&quot;)</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">        <span class="comment">//获取用户</span></span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">userEntity</span> <span class="operator">=</span> userService.getById(id);</span><br><span class="line">        <span class="keyword">if</span> (userEntity == <span class="literal">null</span> || userEntity.getStatus() == UserStatus.FREEZE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//转换Vo</span></span><br><span class="line">        <span class="type">UserVO</span> <span class="variable">userVO</span> <span class="operator">=</span> BeanUtil.copyProperties(userEntity, UserVO.class);</span><br><span class="line">        <span class="comment">//获取地址列表</span></span><br><span class="line">        List&lt;AddressEntity&gt; addressEntityList = addressService.list(Wrappers.lambdaQuery(AddressEntity.class)</span><br><span class="line">                .eq(AddressEntity::getUserId, id));</span><br><span class="line">        <span class="comment">//转换列表VO</span></span><br><span class="line">        <span class="keyword">if</span> (CollUtil.isNotEmpty(addressEntityList)) &#123;</span><br><span class="line">            List&lt;AddressVO&gt; addressVOList = BeanUtil.copyToList(addressEntityList, AddressVO.class);</span><br><span class="line">            userVO.setAddressList(addressVOList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userVO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ids批量查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/getUserByIds&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;根据ids批量查询 getUserByIds&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">getUserByIds</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">        <span class="comment">//1、查询用户</span></span><br><span class="line">        List&lt;UserEntity&gt; userEntityList = userService.listByIds(ids);</span><br><span class="line">        <span class="keyword">if</span> (CollUtil.isEmpty(userEntityList)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2查询地址列表</span></span><br><span class="line">        List&lt;AddressEntity&gt; addressEntityList = addressService.list(Wrappers.lambdaQuery(AddressEntity.class)</span><br><span class="line">                .in(AddressEntity::getUserId, ids));</span><br><span class="line">        <span class="comment">//转为Vo列表</span></span><br><span class="line">        List&lt;UserVO&gt; userVOList = BeanUtil.copyToList(userEntityList, UserVO.class);</span><br><span class="line">        <span class="comment">//根据UserId转为Map</span></span><br><span class="line">        Map&lt;Long, List&lt;AddressEntity&gt;&gt; addressEntityMap = addressEntityList.stream()</span><br><span class="line">                .collect(Collectors.groupingBy(AddressEntity::getUserId));</span><br><span class="line">        userVOList.forEach(userVO -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (userVO.getStatus() == UserStatus.FREEZE) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;用户&#123;&#125;状态异常！！&quot;</span>, userVO.getUsername());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//1、获取对应地址列表</span></span><br><span class="line">            Optional.ofNullable(addressEntityMap.get(userVO.getId()))</span><br><span class="line">                    .ifPresent(addressEntities -&gt; &#123;</span><br><span class="line">                        <span class="comment">//2、转换为Vo地址列表</span></span><br><span class="line">                        List&lt;AddressVO&gt; addressVOList = BeanUtil.copyToList(addressEntities, AddressVO.class);</span><br><span class="line">                        <span class="comment">//3、注入Vo</span></span><br><span class="line">                        userVO.setAddressList(addressVOList);</span><br><span class="line">                    &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> userVOList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询 page</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line">    <span class="meta">@Operation(summary = &quot;分页查询 page&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUsersPage</span><span class="params">(<span class="meta">@ParameterObject</span> UserQuery query)</span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;queryUsersPage ===&gt; &#123;&#125;&quot;</span>, query);</span><br><span class="line">        Page&lt;UserEntity&gt; userEntityPage = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;UserEntity&gt;(query.getPageNo(), query.getPageSize())</span><br><span class="line">                        .addOrder(ObjectUtil.isEmpty(query.getSortBy()) ?</span><br><span class="line">                                OrderItem.desc(<span class="string">&quot;update_time&quot;</span>) :</span><br><span class="line">                                (query.getIsAsc() != <span class="literal">null</span> &amp;&amp; query.getIsAsc() ?</span><br><span class="line">                                        OrderItem.asc(query.getSortBy()) :</span><br><span class="line">                                        OrderItem.desc(query.getSortBy()))),</span><br><span class="line">                Wrappers.lambdaQuery(UserEntity.class)</span><br><span class="line">                        .like(StrUtil.isNotBlank(query.getName()), UserEntity::getUsername, query.getName())</span><br><span class="line">                        .between(query.getMinBalance() != <span class="literal">null</span> &amp;&amp; query.getMaxBalance() != <span class="literal">null</span>, UserEntity::getBalance, query.getMinBalance(), query.getMaxBalance()));</span><br><span class="line">        System.out.println(<span class="string">&quot;userEntityPage = &quot;</span> + userEntityPage.getRecords());</span><br><span class="line">        <span class="comment">//转换为Vo</span></span><br><span class="line">        List&lt;UserVO&gt; userVOList = BeanUtil.copyToList(userEntityPage.getRecords(), UserVO.class);</span><br><span class="line">        PageDTO&lt;UserVO&gt; userVoPageDTO = <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(userEntityPage.getCurrent(), userEntityPage.getSize(), userVOList);</span><br><span class="line">        userVoPageDTO.setTotal(userEntityPage.getTotal());</span><br><span class="line">        System.out.println(<span class="string">&quot;userVoPageDTO = &quot;</span> + userVoPageDTO.getPages());</span><br><span class="line">        <span class="keyword">return</span> userService.queryUsersPage(query);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserVo：</strong>返回用户对象给前端</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户表VO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lixuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/8/7 17:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserVO</span> <span class="keyword">extends</span> <span class="title class_">UserEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Serial</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;地址列表&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AddressVO&gt; addressList;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IUserService：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 1045754</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span> 针对表【user(用户表)】的数据库操作Service</span></span><br><span class="line"><span class="comment">* <span class="doctag">@createDate</span> 2024-08-07 17:27:57</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IUserService</span> <span class="keyword">extends</span> <span class="title class_">IService</span>&lt;UserEntity&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span>;</span><br><span class="line"></span><br><span class="line">    PageDTO&lt;UserVO&gt; <span class="title function_">queryUsersPage</span><span class="params">(UserQuery query)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserServiceImpl：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 1045754</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span> 针对表【user(用户表)】的数据库操作Service实现</span></span><br><span class="line"><span class="comment">* <span class="doctag">@createDate</span> 2024-08-07 17:27:57</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">extends</span> <span class="title class_">ServiceImpl</span>&lt;UserMapper, UserEntity&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">IUserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">        <span class="comment">//1、查询用户</span></span><br><span class="line">        <span class="type">UserEntity</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">//2、校验用户状态</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus().getValue()== <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3、校验余额是否充足</span></span><br><span class="line">        <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;余额不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4、扣减余额</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remainBalance</span> <span class="operator">=</span> user.getBalance() - money;</span><br><span class="line">        <span class="keyword">return</span> lambdaUpdate()</span><br><span class="line">                .set(UserEntity::getBalance,remainBalance)</span><br><span class="line">                .set(remainBalance==<span class="number">0</span>,UserEntity::getStatus,<span class="number">2</span>)</span><br><span class="line">                .eq(UserEntity::getId,id)</span><br><span class="line">                <span class="comment">//乐观锁</span></span><br><span class="line">                .eq(UserEntity::getBalance,user.getBalance())</span><br><span class="line">                .update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUsersPage</span><span class="params">(UserQuery query)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.构建条件</span></span><br><span class="line">        <span class="comment">// 1.1.分页条件</span></span><br><span class="line">        Page&lt;UserEntity&gt; page = Page.of(query.getPageNo(), query.getPageSize());</span><br><span class="line">        <span class="comment">// 1.2.排序条件</span></span><br><span class="line">        <span class="keyword">if</span> (query.getSortBy() != <span class="literal">null</span>) &#123;</span><br><span class="line">            page.addOrder(query.getIsAsc()!= <span class="literal">null</span>&amp;&amp; query.getIsAsc() ? OrderItem.asc(query.getSortBy()) : OrderItem.desc(query.getSortBy()));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 默认按照更新时间排序</span></span><br><span class="line">            page.addOrder(OrderItem.desc(<span class="string">&quot;update_time&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.查询</span></span><br><span class="line">        page(page);</span><br><span class="line">        <span class="comment">// 3.数据非空校验</span></span><br><span class="line">        List&lt;UserEntity&gt; records = page.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(page.getTotal(), page.getPages(), Collections.emptyList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.有数据，转换</span></span><br><span class="line">        List&lt;UserVO&gt; list = BeanUtil.copyToList(records, UserVO.class);</span><br><span class="line">        <span class="comment">// 5.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(page.getTotal(), page.getPages(), list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>UserMapper：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 1045754</span></span><br><span class="line"><span class="comment">* <span class="doctag">@description</span> 针对表【user(用户表)】的数据库操作Mapper</span></span><br><span class="line"><span class="comment">* <span class="doctag">@createDate</span> 2024-08-07 17:27:57</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Entity</span> com.mybatisplus.domain.entity.UserEntity</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;UserEntity&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;UPDATE user SET balance = balance - #&#123;money&#125; $&#123;ew.customSqlSegment&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deductBalanceByIds</span><span class="params">(<span class="meta">@Param(&quot;money&quot;)</span> <span class="type">int</span> money, <span class="meta">@Param(&quot;ew&quot;)</span> QueryWrapper&lt;UserEntity&gt; wrapper)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上述接口，通过引入在 <strong>Controller</strong> 层就可以完成业务接口，但是为了能够更加规范，所以对于复杂的业务，我们任然会选择将业务功能放到 <strong>Service</strong> 层去进行业务实现。</p><h3 id="③-Lambda"><a href="#③-Lambda" class="headerlink" title="③ Lambda"></a>③ Lambda</h3><p><strong>IService</strong> 中还提供了 <strong>Lambda</strong> 方法来简化我们复杂的查询和更新功能。</p><p>案例一：实现一个根据复杂条件查询用户的接口，查询条件如下：</p><ul><li><strong>name</strong> ：用户关键名称，可以为空</li><li><strong>status</strong> ：用户状态，可以为空</li><li><strong>minBalance</strong> ：最小余额，可以为空</li><li><strong>maxBalance</strong> ：最大余额，可以为空</li></ul><p>首先定义查询实体，<strong>UserQuery</strong> ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;用户查询条件实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserQuery</span> &#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名关键字&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户状态：1-正常，2-冻结&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最小值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer minBalance;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;余额最大值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，在 <strong>UserController</strong> 中定义查询方法：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;User&gt;().lambda()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance);</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.list(wrapper);</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组织查询的时候，我们加入 <code>username != null</code> 这样的参数，表示只有当这个条件成立的时候才会添加到这个查询条件里，类似与 <strong>Mapper.xml</strong> 文件中的 <code>&lt;if&gt;</code>标签。这样就实现了动态查询效果。</p><p><strong>Service</strong> 中对<code>LambdaQueryWrapper</code>和<code>LambdaUpdateWrapper</code>的用法进一步做了简化，不需要使用 <strong>new</strong> 来创建 <strong>Wrapper</strong> ，而是直接调用 <strong>lambdaQuery</strong> 和 <strong>lambdaUpdate</strong> 方法：</p><p><strong>lambdaQuery</strong> ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line"><span class="meta">@ApiOperation(&quot;根据id集合查询用户&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">queryUsers</span><span class="params">(UserQuery query)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.组织条件l</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> query.getName();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">status</span> <span class="operator">=</span> query.getStatus();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">minBalance</span> <span class="operator">=</span> query.getMinBalance();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">maxBalance</span> <span class="operator">=</span> query.getMaxBalance();</span><br><span class="line">    <span class="comment">// 2.查询用户</span></span><br><span class="line">    List&lt;User&gt; users = userService.lambdaQuery()</span><br><span class="line">            .like(username != <span class="literal">null</span>, User::getUsername, username)</span><br><span class="line">            .eq(status != <span class="literal">null</span>, User::getStatus, status)</span><br><span class="line">            .ge(minBalance != <span class="literal">null</span>, User::getBalance, minBalance)</span><br><span class="line">            .le(maxBalance != <span class="literal">null</span>, User::getBalance, maxBalance)</span><br><span class="line">            .list();</span><br><span class="line">    <span class="comment">// 3.处理vo</span></span><br><span class="line">    <span class="keyword">return</span> BeanUtil.copyToList(users, UserVO.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现 <code>lambdaQuery</code> 方法中除了可以构建条件，还需要在链式编程的最后添加一个<code>list()</code>，这是在告诉 <code>MP</code> 我们的调用结果需要是一个 <code>list</code> 集合。这里不仅可以用<code>list()</code>，可选的方法有：</p><ul><li><code>.one()</code>：最多1个结果</li><li><code>.list()</code>：返回集合结果</li><li><code>.count()</code>：返回计数结果</li></ul><p><strong>lambdaUpdate</strong> ：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductBalance</span><span class="params">(Long id, Integer money)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询用户</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> getById(id);</span><br><span class="line">    <span class="comment">// 2.校验用户状态</span></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="literal">null</span> || user.getStatus() == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.校验余额是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (user.getBalance() &lt; money) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户余额不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.扣减余额 update tb_user set balance = balance - ?</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">remainBalance</span> <span class="operator">=</span> user.getBalance() - money;</span><br><span class="line">    lambdaUpdate()</span><br><span class="line">            .set(User::getBalance, remainBalance) <span class="comment">// 更新余额</span></span><br><span class="line">            .set(remainBalance == <span class="number">0</span>, User::getStatus, <span class="number">2</span>) <span class="comment">// 动态判断，是否更新status</span></span><br><span class="line">            .eq(User::getId, id)</span><br><span class="line">            .eq(User::getBalance, user.getBalance()) <span class="comment">// 乐观锁</span></span><br><span class="line">            .update();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="④-批量新增"><a href="#④-批量新增" class="headerlink" title="④ 批量新增"></a>④ 批量新增</h3><p>逐条插入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveOneByOne</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        userService.save(buildUser(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;耗时：&quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> User <span class="title function_">buildUser</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setUsername(<span class="string">&quot;user_&quot;</span> + i);</span><br><span class="line">    user.setPassword(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    user.setPhone(<span class="string">&quot;&quot;</span> + (<span class="number">18688190000L</span> + i));</span><br><span class="line">    user.setBalance(<span class="number">2000</span>);</span><br><span class="line">    user.setInfo(<span class="string">&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;female\&quot;&#125;&quot;</span>);</span><br><span class="line">    user.setCreateTime(LocalDateTime.now());</span><br><span class="line">    user.setUpdateTime(user.getCreateTime());</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>耗时长</li><li>速度慢</li></ul><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v11.png" alt="AbstractWrapper"></p><p>批量插入：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveBatch</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 准备10万条数据</span></span><br><span class="line">    List&lt;User&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">1000</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">        list.add(buildUser(i));</span><br><span class="line">        <span class="comment">// 每1000条批量插入一次</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            userService.saveBatch(list);</span><br><span class="line">            list.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">e</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;耗时：&quot;</span> + (e - b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>耗时较短</li><li>速度较快</li></ul><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v12.png" alt="AbstractWrapper"></p><p>可以看到批处理后，比逐条新增的效率提高了10倍左右，性能还是不错的。</p><p>不过我们查看 <strong>MybatisPlus</strong> 源码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sqlStatement</span> <span class="operator">=</span> getSqlStatement(SqlMethod.INSERT_ONE);</span><br><span class="line">    <span class="keyword">return</span> executeBatch(entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...SqlHelper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="type">boolean</span> <span class="title function_">executeBatch</span><span class="params">(Class&lt;?&gt; entityClass, Log log, Collection&lt;E&gt; list, <span class="type">int</span> batchSize, BiConsumer&lt;SqlSession, E&gt; consumer)</span> &#123;</span><br><span class="line">    Assert.isFalse(batchSize &lt; <span class="number">1</span>, <span class="string">&quot;batchSize must not be less than one&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> !CollectionUtils.isEmpty(list) &amp;&amp; executeBatch(entityClass, log, sqlSession -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">idxLimit</span> <span class="operator">=</span> Math.min(batchSize, size);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : list) &#123;</span><br><span class="line">            consumer.accept(sqlSession, element);</span><br><span class="line">            <span class="keyword">if</span> (i == idxLimit) &#123;</span><br><span class="line">                sqlSession.flushStatements();</span><br><span class="line">                idxLimit = Math.min(idxLimit + batchSize, size);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现其实 <strong>MybatisPlus</strong> 的批处理是基于 <strong>PrepareStatement</strong> 的预编译模式，然后批量提交，最终在数据库执行时还是会有多条 <strong>insert</strong> 语句，逐条插入数据。</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Preparing: <span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time ) <span class="keyword">VALUES</span> ( ?, ?, ?, ?, ?, ?, ? )</span><br><span class="line">Parameters: user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br><span class="line">Parameters: user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br><span class="line">Parameters: user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span></span><br></pre></td></tr></table></figure><p>而如果想要得到最佳性能，最好将多条 SQL 合并为一条：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span> ( username, password, phone, info, balance, create_time, update_time )</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(user_1, <span class="number">123</span>, <span class="number">18688190001</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_2, <span class="number">123</span>, <span class="number">18688190002</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_3, <span class="number">123</span>, <span class="number">18688190003</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>),</span><br><span class="line">(user_4, <span class="number">123</span>, <span class="number">18688190004</span>, &quot;&quot;, <span class="number">2000</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>, <span class="number">2023</span><span class="number">-07</span><span class="number">-01</span>);</span><br></pre></td></tr></table></figure><p>该怎么做呢？</p><p><strong>MySQL</strong> 的客户端连接参数中，有一个 <strong>rewriteBatchedStatements</strong> ，顾名思义，就是重写批处理 <strong>statement</strong> 语句。</p><p>修改 <code>application.yml</code> 在 <code>jdbc</code> 的 <code>url</code> 后面添加参数<code>&amp;rewriteBatchedStatements=true</code> ：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/mp?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;zeroDateTimeBehavior=convertToNull&amp;transformedBitIsBoolean=true&amp;tinyInt1isBit=false&amp;allowMultiQueries=true&amp;serverTimezone=GMT%2B8&amp;allowPublicKeyRetrieval=true&amp;rewriteBatchedStatements=true</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>再次测试插入10万条数据，可以发现速度有明显的提升：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v13.png" alt="AbstractWrapper"></p><p>在<code>ClientPreparedStatement</code>的<code>executeBatchInternal</code>中，有判断<code>rewriteBatchedStatements</code>值是否为true并重写SQL的功能：</p><p>最终，<code>SQL</code> 被重写了：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v14.png" alt="AbstractWrapper"></p><h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><h2 id="Ⅰ代码生成"><a href="#Ⅰ代码生成" class="headerlink" title="Ⅰ代码生成"></a>Ⅰ代码生成</h2><p>在使用 <strong>MybatisPlus</strong> 以后，基础的 <strong>Mapper</strong> 、<strong>Servce</strong> 、<strong>PO</strong> 代码相对固定，重复编写也比较麻烦。</p><p>推荐利用 <strong>MyBatisX</strong> 插件进行代码生成：</p><h3 id="①-插件安装"><a href="#①-插件安装" class="headerlink" title="① 插件安装"></a>① 插件安装</h3><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v15.png" alt="AbstractWrapper"></p><h3 id="②-使用"><a href="#②-使用" class="headerlink" title="② 使用"></a>② 使用</h3><h4 id="IDEA-集成数据库："><a href="#IDEA-集成数据库：" class="headerlink" title="IDEA 集成数据库："></a><strong>IDEA</strong> 集成数据库：</h4><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v19.png" alt="AbstractWrapper"></p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v20.png" alt="AbstractWrapper"></p><h4 id="选择生成数据："><a href="#选择生成数据：" class="headerlink" title="选择生成数据："></a>选择生成数据：</h4><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v16.png" alt="AbstractWrapper"></p><ol><li>点击右侧 <strong>Database</strong> 展开连接数据库</li><li>选择所需生成业务表，右键</li><li>点击 <strong>MybatisX-Generator</strong> 打开代码生成窗口</li></ol><h4 id="配置代码生成："><a href="#配置代码生成：" class="headerlink" title="配置代码生成："></a>配置代码生成：</h4><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v17.png" alt="AbstractWrapper"></p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v18.png" alt="AbstractWrapper"></p><h4 id="生成结果："><a href="#生成结果：" class="headerlink" title="生成结果："></a>生成结果：</h4><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v21.png" alt="AbstractWrapper"></p><h2 id="Ⅱ-静态工具"><a href="#Ⅱ-静态工具" class="headerlink" title="Ⅱ 静态工具"></a>Ⅱ 静态工具</h2><p>有的时候 Service 之间也会相互调用，为了避免出现循环依赖问题，MybatisPlus 提供了一个静态工具类：Db ，其中的一些静态方法与 IService 中方法签名基本一致，也可以帮助我们实现 CRUD 功能：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以静态方式调用Service中的函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> VampireAchao</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2022-05-03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Db</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">log</span> <span class="operator">=</span> LogFactory.getLog(Db.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Db</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/* Do not new me! */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入一条记录（选择字段，策略插入）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(entity)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> SqlHelper.execute(getEntityClass(entity), baseMapper -&gt; baseMapper.insert(entity));</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.retBool(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入（批量）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> saveBatch(entityList, IService.DEFAULT_BATCH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入（批量）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize  插入批次数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">saveBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(entityList)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;T&gt; entityClass = getEntityClass(entityList);</span><br><span class="line">        Class&lt;?&gt; mapperClass = ClassUtils.toClassConfident(getTableInfo(entityClass).getCurrentNamespace());</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlStatement</span> <span class="operator">=</span> SqlHelper.getSqlStatement(mapperClass, SqlMethod.INSERT_ONE);</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.executeBatch(entityClass, log, entityList, batchSize, (sqlSession, entity) -&gt; sqlSession.insert(sqlStatement, entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量修改插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> saveOrUpdateBatch(entityList, IService.DEFAULT_BATCH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量修改插入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize  每次的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">saveOrUpdateBatch</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(entityList)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;T&gt; entityClass = getEntityClass(entityList);</span><br><span class="line">        <span class="type">TableInfo</span> <span class="variable">tableInfo</span> <span class="operator">=</span> getTableInfo(entityClass);</span><br><span class="line">        Class&lt;?&gt; mapperClass = ClassUtils.toClassConfident(tableInfo.getCurrentNamespace());</span><br><span class="line">        <span class="type">String</span> <span class="variable">keyProperty</span> <span class="operator">=</span> tableInfo.getKeyProperty();</span><br><span class="line">        Assert.notEmpty(keyProperty, <span class="string">&quot;error: can not execute. because can not find column for primary key from entity!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.saveOrUpdateBatch(entityClass, mapperClass, log, entityList, batchSize, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">idVal</span> <span class="operator">=</span> tableInfo.getPropertyValue(entity, keyProperty);</span><br><span class="line">            <span class="keyword">return</span> StringUtils.checkValNull(idVal)</span><br><span class="line">                || CollectionUtils.isEmpty(sqlSession.selectList(SqlHelper.getSqlStatement(mapperClass, SqlMethod.SELECT_BY_ID), entity));</span><br><span class="line">        &#125;, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            MapperMethod.ParamMap&lt;T&gt; param = <span class="keyword">new</span> <span class="title class_">MapperMethod</span>.ParamMap&lt;&gt;();</span><br><span class="line">            param.put(Constants.ENTITY, entity);</span><br><span class="line">            sqlSession.update(SqlHelper.getSqlStatement(mapperClass, SqlMethod.UPDATE_BY_ID), param);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id          主键ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(Serializable id, Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; SqlHelper.retBool(baseMapper.deleteById(id)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据实体(ID)删除</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">removeById</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(entity)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(entity), baseMapper -&gt; SqlHelper.retBool(baseMapper.deleteById(entity)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity 条件，删除记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体包装类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(AbstractWrapper&lt;T, ?, ?&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(queryWrapper), baseMapper -&gt; SqlHelper.retBool(baseMapper.delete(queryWrapper)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 选择修改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">updateById</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(entity)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(entity), baseMapper -&gt; SqlHelper.retBool(baseMapper.updateById(entity)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 UpdateWrapper 条件，更新记录 需要设置sqlset</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(AbstractWrapper&lt;T, ?, ?&gt; updateWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> update(<span class="literal">null</span>, updateWrapper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 whereEntity 条件，更新记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity        实体对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> updateWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.update.UpdateWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(T entity, AbstractWrapper&lt;T, ?, ?&gt; updateWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(updateWrapper), baseMapper -&gt; SqlHelper.retBool(baseMapper.update(entity, updateWrapper)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID 批量更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> updateBatchById(entityList, IService.DEFAULT_BATCH_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据ID 批量更新</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体对象集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> batchSize  更新批次数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">updateBatchById</span><span class="params">(Collection&lt;T&gt; entityList, <span class="type">int</span> batchSize)</span> &#123;</span><br><span class="line">        Class&lt;T&gt; entityClass = getEntityClass(entityList);</span><br><span class="line">        <span class="type">TableInfo</span> <span class="variable">tableInfo</span> <span class="operator">=</span> getTableInfo(entityClass);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sqlStatement</span> <span class="operator">=</span> SqlHelper.getSqlStatement(ClassUtils.toClassConfident(tableInfo.getCurrentNamespace()), SqlMethod.UPDATE_BY_ID);</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.executeBatch(entityClass, log, entityList, batchSize, (sqlSession, entity) -&gt; &#123;</span><br><span class="line">            MapperMethod.ParamMap&lt;T&gt; param = <span class="keyword">new</span> <span class="title class_">MapperMethod</span>.ParamMap&lt;&gt;();</span><br><span class="line">            param.put(Constants.ENTITY, entity);</span><br><span class="line">            sqlSession.update(sqlStatement, param);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除（根据ID 批量删除）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> list        主键ID或实体列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">removeByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; list, Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; SqlHelper.retBool(baseMapper.deleteBatchIds(list)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 columnMap 条件，删除记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMap   表字段 map 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">removeByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap, Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; SqlHelper.retBool(baseMapper.deleteByMap(columnMap)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TableId 注解存在更新记录，否插入一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(entity)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;T&gt; entityClass = getEntityClass(entity);</span><br><span class="line">        <span class="type">TableInfo</span> <span class="variable">tableInfo</span> <span class="operator">=</span> TableInfoHelper.getTableInfo(entityClass);</span><br><span class="line">        Assert.notNull(tableInfo, <span class="string">&quot;error: can not execute. because can not find cache of TableInfo for entity!&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">keyProperty</span> <span class="operator">=</span> tableInfo.getKeyProperty();</span><br><span class="line">        Assert.notEmpty(keyProperty, <span class="string">&quot;error: can not execute. because can not find column for id from entity!&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">idVal</span> <span class="operator">=</span> tableInfo.getPropertyValue(entity, tableInfo.getKeyProperty());</span><br><span class="line">        <span class="keyword">return</span> StringUtils.checkValNull(idVal) || Objects.isNull(getById((Serializable) idVal, entityClass)) ? save(entity) : updateById(entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 ID 查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id          主键ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getById</span><span class="params">(Serializable id, Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; baseMapper.selectById(id));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper，查询一条记录 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getOne</span><span class="params">(AbstractWrapper&lt;T, ?, ?&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getOne(queryWrapper, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity里不为空的字段，查询一条记录 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;结果集，如果是多个会抛出异常，随机取一条加上限制条件 wrapper.last(&quot;LIMIT 1&quot;)&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getOne</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getOne(Wrappers.lambdaQuery(entity), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity里不为空的字段，查询一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity  实体对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwEx 有多个 result 是否抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getOne</span><span class="params">(T entity, <span class="type">boolean</span> throwEx)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getOne(Wrappers.lambdaQuery(entity), throwEx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> throwEx      有多个 result 是否抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getOne</span><span class="params">(AbstractWrapper&lt;T, ?, ?&gt; queryWrapper, <span class="type">boolean</span> throwEx)</span> &#123;</span><br><span class="line">        Class&lt;T&gt; entityClass = getEntityClass(queryWrapper);</span><br><span class="line">        <span class="keyword">if</span> (throwEx) &#123;</span><br><span class="line">            <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; baseMapper.selectOne(queryWrapper));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; SqlHelper.getObject(log, baseMapper.selectList(queryWrapper)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据 columnMap 条件）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> columnMap   表字段 map 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">listByMap</span><span class="params">(Map&lt;String, Object&gt; columnMap, Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; baseMapper.selectByMap(columnMap));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询（根据ID 批量查询）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> idList      主键ID列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">listByIds</span><span class="params">(Collection&lt;? extends Serializable&gt; idList, Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; baseMapper.selectBatchIds(idList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(AbstractWrapper&lt;T, ?, ?&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(queryWrapper), baseMapper -&gt; SqlHelper.getObject(log, baseMapper.selectMaps(queryWrapper)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 entity不为空条件，查询一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Map&lt;String, Object&gt; <span class="title function_">getMap</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getMap(Wrappers.lambdaQuery(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询总记录数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">long</span> <span class="title function_">count</span><span class="params">(Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; baseMapper.selectCount(<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据entity中不为空的数据查询记录数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">long</span> <span class="title function_">count</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count(Wrappers.lambdaQuery(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询总记录数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">long</span> <span class="title function_">count</span><span class="params">(AbstractWrapper&lt;T, ?, ?&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(queryWrapper), baseMapper -&gt; baseMapper.selectCount(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">list</span><span class="params">(AbstractWrapper&lt;T, ?, ?&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(queryWrapper), baseMapper -&gt; baseMapper.selectList(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         分页条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;          entity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">list</span><span class="params">(IPage&lt;T&gt; page, AbstractWrapper&lt;T, ?, ?&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(queryWrapper), baseMapper -&gt; baseMapper.selectList(page, queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">list</span><span class="params">(Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; baseMapper.selectList(<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page        分页条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;         entity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.3.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">list</span><span class="params">(IPage&lt;T&gt; page, Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; baseMapper.selectList(page, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据entity中不为空的字段进行查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">list</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list(Wrappers.lambdaQuery(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据entity中不为空的字段进行查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page   分页条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;    entity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.3.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">list</span><span class="params">(IPage&lt;T&gt; page, T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> list(page, Wrappers.lambdaQuery(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(AbstractWrapper&lt;T, ?, ?&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(queryWrapper), baseMapper -&gt; baseMapper.selectMaps(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.3.2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page 分页参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; entity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(IPage&lt;? extends Map&lt;String, Object&gt;&gt; page, AbstractWrapper&lt;T, ?, ?&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(queryWrapper), baseMapper -&gt; baseMapper.selectMaps(page, queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; baseMapper.selectMaps(<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分页查询列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page        分页条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;         entity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.3.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(IPage&lt;? extends Map&lt;String, Object&gt;&gt; page, Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; baseMapper.selectMaps(page, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据entity不为空的条件查询列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listMaps(Wrappers.lambdaQuery(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据entity不为空的条件查询列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page   分页条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity entity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;    entity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 列表数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 3.5.3.2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;Map&lt;String, Object&gt;&gt; <span class="title function_">listMaps</span><span class="params">(IPage&lt;? extends Map&lt;String, Object&gt;&gt; page, T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listMaps(page, Wrappers.lambdaQuery(entity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">listObjs</span><span class="params">(Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listObjs(entityClass, i -&gt; i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E, T&gt; List&lt;E&gt; <span class="title function_">listObjs</span><span class="params">(AbstractWrapper&lt;T, ?, ?&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(queryWrapper), baseMapper -&gt; baseMapper.selectObjs(queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper 条件，查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapper       转换函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(AbstractWrapper&lt;T, ?, ?&gt; queryWrapper, SFunction&lt;? <span class="built_in">super</span> T, V&gt; mapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(queryWrapper), baseMapper -&gt; baseMapper.selectList(queryWrapper).stream().map(mapper).collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询全部记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapper      转换函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, V&gt; List&lt;V&gt; <span class="title function_">listObjs</span><span class="params">(Class&lt;T&gt; entityClass, SFunction&lt;? <span class="built_in">super</span> T, V&gt; mapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; baseMapper.selectList(<span class="literal">null</span>).stream().map(mapper).collect(Collectors.toList()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无条件翻页查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page        翻页对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; E <span class="title function_">pageMaps</span><span class="params">(E page, Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; baseMapper.selectMapsPage(page, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻页查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         翻页对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, E <span class="keyword">extends</span> <span class="title class_">IPage</span>&lt;Map&lt;String, Object&gt;&gt;&gt; E <span class="title function_">pageMaps</span><span class="params">(E page, AbstractWrapper&lt;T, ?, ?&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(queryWrapper), baseMapper -&gt; baseMapper.selectMapsPage(page, queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无条件翻页查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page        翻页对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> Wrappers#emptyWrapper()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; IPage&lt;T&gt; <span class="title function_">page</span><span class="params">(IPage&lt;T&gt; page, Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(entityClass, baseMapper -&gt; baseMapper.selectPage(page, <span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻页查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> page         翻页对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; IPage&lt;T&gt; <span class="title function_">page</span><span class="params">(IPage&lt;T&gt; page, AbstractWrapper&lt;T, ?, ?&gt; queryWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(queryWrapper), baseMapper -&gt; baseMapper.selectPage(page, queryWrapper));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式查询 普通</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> QueryWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; QueryChainWrapper&lt;T&gt; <span class="title function_">query</span><span class="params">(Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.queryChain(entityClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * kt链式查询</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> KtQueryWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; KtQueryChainWrapper&lt;T&gt; <span class="title function_">ktQuery</span><span class="params">(Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.ktQueryChain(entityClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式查询 lambda 式</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;注意：不支持 Kotlin &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LambdaQueryWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; LambdaQueryChainWrapper&lt;T&gt; <span class="title function_">lambdaQuery</span><span class="params">(Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.lambdaQueryChain(entityClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式更改 普通</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> UpdateWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; UpdateChainWrapper&lt;T&gt; <span class="title function_">update</span><span class="params">(Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.updateChain(entityClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * kt链式更改</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> KtUpdateWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; KtUpdateChainWrapper&lt;T&gt; <span class="title function_">ktUpdate</span><span class="params">(Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.ktUpdateChain(entityClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链式更改 lambda 式</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;注意：不支持 Kotlin &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LambdaUpdateWrapper 的包装类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; LambdaUpdateChainWrapper&lt;T&gt; <span class="title function_">lambdaUpdate</span><span class="params">(Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ChainWrappers.lambdaUpdateChain(entityClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 根据updateWrapper尝试更新，否继续执行saveOrUpdate(T)方法</span></span><br><span class="line"><span class="comment">     * 此次修改主要是减少了此项业务代码的代码量（存在性验证之后的saveOrUpdate操作）</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="type">boolean</span> <span class="title function_">saveOrUpdate</span><span class="params">(T entity, AbstractWrapper&lt;T, ?, ?&gt; updateWrapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> update(entity, updateWrapper) || saveOrUpdate(entity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 Wrapper，查询一条记录</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 实体对象封装操作类 &#123;<span class="doctag">@link</span> com.baomidou.mybatisplus.core.conditions.query.QueryWrapper&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapper       转换函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, V&gt; V <span class="title function_">getObj</span><span class="params">(AbstractWrapper&lt;T, ?, ?&gt; queryWrapper, SFunction&lt;? <span class="built_in">super</span> T, V&gt; mapper)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SqlHelper.execute(getEntityClass(queryWrapper), baseMapper -&gt; mapper.apply(baseMapper.selectOne(queryWrapper)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从集合中获取实体类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityList 实体集合</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;        实体类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实体类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> &lt;T&gt; Class&lt;T&gt; <span class="title function_">getEntityClass</span><span class="params">(Collection&lt;T&gt; entityList)</span> &#123;</span><br><span class="line">        Class&lt;T&gt; entityClass = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (T entity : entityList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entity != <span class="literal">null</span> &amp;&amp; entity.getClass() != <span class="literal">null</span>) &#123;</span><br><span class="line">                entityClass = getEntityClass(entity);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Assert.notNull(entityClass, <span class="string">&quot;error: can not get entityClass from entityList&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> entityClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从wrapper中尝试获取实体类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queryWrapper 条件构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;          实体类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实体类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> &lt;T&gt; Class&lt;T&gt; <span class="title function_">getEntityClass</span><span class="params">(AbstractWrapper&lt;T, ?, ?&gt; queryWrapper)</span> &#123;</span><br><span class="line">        Class&lt;T&gt; entityClass = queryWrapper.getEntityClass();</span><br><span class="line">        <span class="keyword">if</span> (entityClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">entity</span> <span class="operator">=</span> queryWrapper.getEntity();</span><br><span class="line">            <span class="keyword">if</span> (entity != <span class="literal">null</span>) &#123;</span><br><span class="line">                entityClass = getEntityClass(entity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Assert.notNull(entityClass, <span class="string">&quot;error: can not get entityClass from wrapper&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> entityClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从entity中尝试获取实体类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entity 实体</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;    实体类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实体类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> &lt;T&gt; Class&lt;T&gt; <span class="title function_">getEntityClass</span><span class="params">(T entity)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Class&lt;T&gt;) entity.getClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取表信息，获取不到报错提示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> entityClass 实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;         实体类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应表信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> &lt;T&gt; TableInfo <span class="title function_">getTableInfo</span><span class="params">(Class&lt;T&gt; entityClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(TableInfoHelper.getTableInfo(entityClass)).orElseThrow(() -&gt; ExceptionUtils.mpe(<span class="string">&quot;error: can not find TableInfo from Class: \&quot;%s\&quot;.&quot;</span>, entityClass.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> Db.getById(<span class="number">1L</span>, User.class);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbList</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 利用Db实现复杂条件查询</span></span><br><span class="line">    List&lt;User&gt; list = Db.lambdaQuery(User.class)</span><br><span class="line">            .like(User::getUsername, <span class="string">&quot;o&quot;</span>)</span><br><span class="line">            .ge(User::getBalance, <span class="number">1000</span>)</span><br><span class="line">            .list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDbUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">    Db.lambdaUpdate(User.class)</span><br><span class="line">            .set(User::getBalance, <span class="number">2000</span>)</span><br><span class="line">            .eq(User::getUsername, <span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需求：改造根据 id 查询用户接口，查询用户的同时返回用户收获地址列表：</p><p><strong>UserVO：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户表VO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lixuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/8/7 17:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserVO</span> <span class="keyword">extends</span> <span class="title class_">UserEntity</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Serial</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Schema(description = &quot;地址列表&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;AddressVO&gt; addressList;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加一个地址列表的属性</p><p><strong>UserController：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询用户并且对应其地址足迹</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getUserAndAddress/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="meta">@Operation(summary = &quot;查询用户并且对应其地址足迹 getUserAndAddress/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> UserVO <span class="title function_">getUserAndAddress</span><span class="params">(<span class="meta">@Parameter(description = &quot;用户ID&quot;)</span> <span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;</span><br><span class="line">    <span class="comment">//获取用户</span></span><br><span class="line">    <span class="type">UserEntity</span> <span class="variable">userEntity</span> <span class="operator">=</span> userService.getById(id);</span><br><span class="line">    <span class="keyword">if</span> (userEntity == <span class="literal">null</span> || userEntity.getStatus() == UserStatus.FREEZE) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;用户状态异常！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转换Vo</span></span><br><span class="line">    <span class="type">UserVO</span> <span class="variable">userVO</span> <span class="operator">=</span> BeanUtil.copyProperties(userEntity, UserVO.class);</span><br><span class="line">    <span class="comment">//获取地址列表</span></span><br><span class="line">    List&lt;AddressEntity&gt; addressEntityList = addressService.list(Wrappers.lambdaQuery(AddressEntity.class)</span><br><span class="line">            .eq(AddressEntity::getUserId, id));</span><br><span class="line">    <span class="comment">//转换列表VO</span></span><br><span class="line">    <span class="keyword">if</span> (CollUtil.isNotEmpty(addressEntityList)) &#123;</span><br><span class="line">        List&lt;AddressVO&gt; addressVOList = BeanUtil.copyToList(addressEntityList, AddressVO.class);</span><br><span class="line">        userVO.setAddressList(addressVOList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需求：根据id批量查询用户，并查询出用户对应的所有地址</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据ids批量查询</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/getUserByIds&quot;)</span></span><br><span class="line"><span class="meta">@Operation(summary = &quot;根据ids批量查询 getUserByIds&quot;)</span></span><br><span class="line"><span class="keyword">public</span> List&lt;UserVO&gt; <span class="title function_">getUserByIds</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;Long&gt; ids)</span> &#123;</span><br><span class="line">    <span class="comment">//1、查询用户</span></span><br><span class="line">    List&lt;UserEntity&gt; userEntityList = userService.listByIds(ids);</span><br><span class="line">    <span class="keyword">if</span> (CollUtil.isEmpty(userEntityList)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2查询地址列表</span></span><br><span class="line">    List&lt;AddressEntity&gt; addressEntityList = addressService.list(Wrappers.lambdaQuery(AddressEntity.class)</span><br><span class="line">            .in(AddressEntity::getUserId, ids));</span><br><span class="line">    <span class="comment">//转为Vo列表</span></span><br><span class="line">    List&lt;UserVO&gt; userVOList = BeanUtil.copyToList(userEntityList, UserVO.class);</span><br><span class="line">    <span class="comment">//根据UserId转为Map</span></span><br><span class="line">    Map&lt;Long, List&lt;AddressEntity&gt;&gt; addressEntityMap = addressEntityList.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(AddressEntity::getUserId));</span><br><span class="line">    userVOList.forEach(userVO -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (userVO.getStatus() == UserStatus.FREEZE) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;用户&#123;&#125;状态异常！！&quot;</span>, userVO.getUsername());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、获取对应地址列表</span></span><br><span class="line">        Optional.ofNullable(addressEntityMap.get(userVO.getId()))</span><br><span class="line">                .ifPresent(addressEntities -&gt; &#123;</span><br><span class="line">                    <span class="comment">//2、转换为Vo地址列表</span></span><br><span class="line">                    List&lt;AddressVO&gt; addressVOList = BeanUtil.copyToList(addressEntities, AddressVO.class);</span><br><span class="line">                    <span class="comment">//3、注入Vo</span></span><br><span class="line">                    userVO.setAddressList(addressVOList);</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> userVOList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ⅲ-逻辑删除"><a href="#Ⅲ-逻辑删除" class="headerlink" title="Ⅲ 逻辑删除"></a>Ⅲ 逻辑删除</h2><p>对于一些比较重要的数据，我们往往会采用逻辑删除的方式，而不是直接将其冲数据库中删除。</p><ul><li>在表中添加一个字段标记数据是否被删除</li><li>当删除数据时把标记置为true</li><li>查询时过滤掉标记为true的数据</li></ul><p><strong>MybatisPlus</strong> 就添加了对逻辑删除的支持：</p><p><code>注意，只有MybatisPlus生成的SQL语句才支持自动的逻辑删除，自定义SQL需要自己手动处理逻辑删除。</code></p><p>例如，给 <strong>adress</strong> 表添加逻辑删除字段：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> address <span class="keyword">add</span> deleted bit <span class="keyword">default</span> b<span class="string">&#x27;0&#x27;</span> <span class="keyword">null</span> comment <span class="string">&#x27;逻辑删除&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>AdressEntity：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lixuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@TableName</span> address</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@TableName(value =&quot;address&quot;)</span></span><br><span class="line"><span class="meta">@Schema(description = &quot;地址表&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddressEntity</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description = &quot;id&quot;)</span></span><br><span class="line">    <span class="meta">@TableId(value = &quot;id&quot;, type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户ID</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description = &quot;用户ID&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;user_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 省</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description = &quot;省&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;province&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String province;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 市</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description = &quot;市&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;city&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 县/区</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description = &quot;县/区&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;town&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String town;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 手机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description = &quot;手机&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;mobile&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 详细地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description = &quot;详细地址&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;street&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 联系人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description = &quot;联系人&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;contact&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String contact;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否是默认 1默认 0否</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description = &quot;是否是默认 1默认 0否&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;is_default&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isDefault;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 备注</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description = &quot;备注&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;notes&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String notes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 逻辑删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Schema(description = &quot;逻辑删除&quot;)</span></span><br><span class="line">    <span class="meta">@TableField(value = &quot;deleted&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean deleted;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Serial</span></span><br><span class="line">    <span class="meta">@TableField(exist = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>application.yml：</strong></p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">deleted</span> <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure><p>方法与普通的方法一样，但是底层的逻辑已经改变了：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v22.png" alt="AbstractWrapper"></p><p>查询：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Address&gt; list = addressService.list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会发现 <strong>id</strong> 为59的确实没有查询出来，而且 <strong>SQL</strong> 中也对逻辑删除字段做了判断：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v23.png" alt="AbstractWrapper"></p><p>综上， 开启了逻辑删除功能以后，我们就可以像普通删除一样做CRUD，基本不用考虑代码逻辑问题。还是非常方便的。</p><blockquote><p><strong>注意</strong>： 逻辑删除本身也有自己的问题，比如：</p><ul><li>会导致数据库表垃圾数据越来越多，从而影响查询效率</li><li>SQL中全都需要对逻辑删除字段做判断，影响查询效率</li></ul></blockquote><h2 id="Ⅳ-通用枚举"><a href="#Ⅳ-通用枚举" class="headerlink" title="Ⅳ 通用枚举"></a>Ⅳ 通用枚举</h2><p><strong>UserEntity</strong> 中有一个用户状态</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v24.png" alt="AbstractWrapper"></p><p>像这种字段，我们一般会定义一个枚举，做业务判断的时候，就可以直接基于枚举比较，但是我们数据库采用的是 <strong>int</strong> 型，对应的 <strong>PO</strong> 也是一个 <strong>Integer</strong> 。因此业务操作时必须手动转换枚举和 <strong>Integer</strong> 。</p><p>但是 <strong>MybatisPlus</strong> 提供了一个处理枚举类型的类型转换器，可以帮我们把<code>枚举类型和数据库类型自动转换</code>。</p><h3 id="①-定义枚举"><a href="#①-定义枚举" class="headerlink" title="① 定义枚举"></a>① 定义枚举</h3><p>定义一个用户状态枚举：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v25.png" alt="AbstractWrapper"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">UserStatus</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户账号状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NORMAL(<span class="number">1</span>, <span class="string">&quot;正常&quot;</span>),</span><br><span class="line">    FREEZE(<span class="number">2</span>, <span class="string">&quot;冻结&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@EnumValue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * JSON 响应时返回的属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@JsonValue</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    UserStatus(<span class="type">int</span> value, String desc) &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后将 <code>UserEntity</code> 类中的 <code>status</code> 字段改为 <code>UserStatus</code> 类型：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v26.png" alt="AbstractWrapper"></p><p>当然，要让 <code>MybatisPlus</code> 处理枚举与数据库自动类型转换，我们必须要告诉 <code>MybatisPlus</code> ，枚举中的哪个字段值作为数据库值。</p><p><code>MybatisPlus</code> 提供了 <code>@EnumValue</code> 来标记枚举属性</p><h3 id="②-配置枚举处理器"><a href="#②-配置枚举处理器" class="headerlink" title="② 配置枚举处理器"></a>② 配置枚举处理器</h3><p>在 <strong>application.yml</strong> 中添加配置：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">default-enum-type-handler:</span> <span class="string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举处理测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testService</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;UserEntity&gt; list = userService.list();</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，查询出的<code>User</code>类的<code>status</code>字段会是枚举类型：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v27.png" alt="AbstractWrapper"></p><p>同时，为了使页面查询结果也是枚举格式，我们需要修改UserVO中的status属性</p><p>并且，在UserStatus枚举中通过<code>@JsonValue</code>注解标记JSON序列化时展示的字段：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v28.png" alt="AbstractWrapper"></p><p>最后，在页面查询，结果如下：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v29.png" alt="AbstractWrapper"></p><h2 id="Ⅴ-JSON-类型处理器"><a href="#Ⅴ-JSON-类型处理器" class="headerlink" title="Ⅴ JSON 类型处理器"></a>Ⅴ JSON 类型处理器</h2><p>数据库的user表中有一个<code>info</code>字段，是 <strong>JSON</strong> 类型：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v30.png" alt="AbstractWrapper"></p><p>格式：</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">20</span><span class="punctuation">,</span> <span class="attr">&quot;intro&quot;</span><span class="punctuation">:</span> <span class="string">&quot;佛系青年&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;gender&quot;</span><span class="punctuation">:</span> <span class="string">&quot;male&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>而目前<code>UserEntity</code>实体类中却是<code>String</code>类型：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v31.png" alt="AbstractWrapper"></p><p>这样一来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个<code>Map</code>或者实体类。</p><p>而一旦我们把<code>info</code>改为<code>对象</code>类型，就需要在写入数据库时手动转为<code>String</code>，再读取数据库时，手动转换为<code>对象</code>，这会非常麻烦。</p><p>因此MybatisPlus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理JSON就可以使用<code>JacksonTypeHandler</code>处理器。</p><h3 id="①-定义实体"><a href="#①-定义实体" class="headerlink" title="① 定义实体"></a>① 定义实体</h3><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v32.png" alt="AbstractWrapper"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Json UserInfo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lixuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/8/9 9:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor(staticName = &quot;of&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInfo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String intro;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②-使用类型处理器"><a href="#②-使用类型处理器" class="headerlink" title="② 使用类型处理器"></a>② 使用类型处理器</h3><p>将 UserEntity 类的 info 字段修改为 UserInfo 类型，并声明类型处理器：</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v33.png" alt="AbstractWrapper"></p><h1 id="插件功能"><a href="#插件功能" class="headerlink" title="插件功能"></a>插件功能</h1><p>MybatisPlus提供了很多的插件功能，进一步拓展其功能。目前已有的插件有：</p><ul><li><code>PaginationInnerInterceptor</code>：自动分页</li><li><code>TenantLineInnerInterceptor</code>：多租户</li><li><code>DynamicTableNameInnerInterceptor</code>：动态表名</li><li><code>OptimisticLockerInnerInterceptor</code>：乐观锁</li><li><code>IllegalSQLInnerInterceptor</code>：sql 性能规范</li><li><code>BlockAttackInnerInterceptor</code>：防止全表更新与删除</li></ul><blockquote><p><strong>注意：</strong> 使用多个分页插件的时候需要注意插件定义顺序，建议使用顺序如下：</p><ul><li>多租户,动态表名</li><li>分页,乐观锁</li><li>sql 性能规范,防止全表更新与删除</li></ul></blockquote><h2 id="Ⅰ分页插件"><a href="#Ⅰ分页插件" class="headerlink" title="Ⅰ分页插件"></a>Ⅰ分页插件</h2><p>在未引入分页插件的情况下，<code>MybatisPlus</code>是不支持分页功能的，<code>IService</code>和<code>BaseMapper</code>中的分页方法都无法正常起效。 所以，我们必须配置分页插件。</p><h3 id="①-配置分页插件"><a href="#①-配置分页插件" class="headerlink" title="① 配置分页插件"></a>① 配置分页插件</h3><p>在 <strong>config</strong> 下配置分页插件</p><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v34.png" alt="AbstractWrapper"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页拦截器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lixuan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/8/8 9:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义一个mybatisPlus的拦截器 再 add一个分页拦截器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1.初始化核心插件</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//2.添加分页插件</span></span><br><span class="line">        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②-分页-API"><a href="#②-分页-API" class="headerlink" title="② 分页 API"></a>② 分页 API</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageQuery</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1.分页查询，new Page()的两个参数分别是：页码、每页大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    Page&lt;UserEntity&gt; page = Page.of(current, size);</span><br><span class="line">    <span class="comment">// 1.2、排序</span></span><br><span class="line">    page.addOrder(OrderItem.asc(<span class="string">&quot;balance&quot;</span>));</span><br><span class="line">    page.addOrder(OrderItem.desc(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">    Page&lt;UserEntity&gt; p = userService.page(page);</span><br><span class="line">    <span class="comment">// 2.总条数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;total = &quot;</span> + p.getTotal());</span><br><span class="line">    <span class="comment">// 3.总页数</span></span><br><span class="line">    System.out.println(<span class="string">&quot;pages = &quot;</span> + p.getPages());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.数据</span></span><br><span class="line">    List&lt;UserEntity&gt; records = p.getRecords();</span><br><span class="line">    records.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/load.gif" data-original="/images/frameworks/Java/mybatisplus/a/v35.png" alt="AbstractWrapper"></p><p>这里用到了分页参数，<strong>Page</strong> ，即可以支持分页参数，也可以支持排序参数。常见的 <strong>API</strong> 如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 分页参数</span></span><br><span class="line">Page&lt;User&gt; page = Page.of(pageNo, pageSize);</span><br><span class="line"><span class="comment">// 排序参数, 通过OrderItem来指定</span></span><br><span class="line">page.addOrder(<span class="keyword">new</span> <span class="title class_">OrderItem</span>(<span class="string">&quot;balance&quot;</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">userService.page(page);</span><br></pre></td></tr></table></figure><h2 id="Ⅱ-通用分页实体"><a href="#Ⅱ-通用分页实体" class="headerlink" title="Ⅱ 通用分页实体"></a>Ⅱ 通用分页实体</h2><p>现在要实现一个用户分页查询的接口，接口规范如下：</p><table border="1" cellpadding="10" cellspacing="0" style="border-collapse: collapse; width: 100%; text-align: left;">  <thead>    <tr>      <th style="background-color: #e0f7fa; color: #00796b;">参数</th>      <th style="background-color: #e0f7fa; color: #00796b;">说明</th>    </tr>  </thead>  <tbody>    <tr>      <td>请求方式</td>      <td>GET</td>    </tr>    <tr>      <td>请求路径</td>      <td>/users/page</td>    </tr>    <tr>      <td>请求参数</td>      <td>        <pre style="background-color: #050917; border: 1px solid rgb(5,9,23); border-radius: 4px; padding: 10px;">{  "pageNo": 1,  "pageSize": 5,  "sortBy": "balance",  "isAsc": false,  "name": "o",  "status": 1}        </pre>      </td>    </tr>    <tr>      <td>返回值</td>      <td>        <pre style="background-color: #050917; border: 1px solid rgb(5,9,23); border-radius: 4px; padding: 10px;">{  "total": 100006,  "pages": 50003,  "list": [    {      "id": 1685100878975279298,      "username": "user_9****",      "info": {        "age": 24,        "intro": "英文老师",        "gender": "female"      },      "status": "正常",      "balance": 2000    }  ]}        </pre>      </td>    </tr>    <tr>      <td>特殊说明</td>      <td>如果排序字段为空，默认按照更新时间排序；如果排序字段不为空，则按照排序字段排序。</td>    </tr>  </tbody></table><p>这里需要定义3个实体：</p><ul><li><code>UserQuery</code>：分页查询条件的实体，包含分页、排序参数、过滤条件</li><li><code>PageDTO</code>：分页结果实体，包含总条数、总页数、当前页数据</li><li><code>UserVO</code>：用户页面视图实体</li></ul><h3 id="①-实体"><a href="#①-实体" class="headerlink" title="① 实体"></a>① 实体</h3><p><strong>UserQuery：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@EqualsAndHashCode(callSuper = true)</span></span><br><span class="line"><span class="meta">@Schema(description = &quot;用户查询条件实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserQuery</span> <span class="keyword">extends</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="meta">@Schema(description = &quot;用户名关键字&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Schema(description = &quot;用户状态：1-正常，2-冻结&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line">    <span class="meta">@Schema(description = &quot;余额最小值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer minBalance;</span><br><span class="line">    <span class="meta">@Schema(description = &quot;余额最大值&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxBalance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PageQuery：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Schema(description = &quot;分页查询实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageQuery</span> &#123;</span><br><span class="line">    <span class="meta">@Schema(description = &quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pageNo;</span><br><span class="line">    <span class="meta">@Schema(description = &quot;页码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pageSize;</span><br><span class="line">    <span class="meta">@Schema(description = &quot;排序字段&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="meta">@Schema(description = &quot;是否升序&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isAsc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(OrderItem... orders)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.分页条件</span></span><br><span class="line">        Page&lt;T&gt; p = Page.of(pageNo, pageSize);</span><br><span class="line">        <span class="comment">// 2.排序条件</span></span><br><span class="line">        <span class="comment">// 2.1.先看前端有没有传排序字段</span></span><br><span class="line">        <span class="keyword">if</span> (sortBy != <span class="literal">null</span>) &#123;</span><br><span class="line">            p.addOrder(isAsc!= <span class="literal">null</span>&amp;&amp; isAsc ? OrderItem.asc(sortBy) : OrderItem.desc(sortBy));</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.2.再看有没有手动指定排序字段</span></span><br><span class="line">        <span class="keyword">if</span>(orders != <span class="literal">null</span>)&#123;</span><br><span class="line">            p.addOrder(orders);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPage</span><span class="params">(String defaultSortBy, <span class="type">boolean</span> isAsc)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.toMpPage(isAsc ? OrderItem.asc(defaultSortBy) : OrderItem.desc(defaultSortBy));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPageDefaultSortByCreateTimeDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toMpPage(<span class="string">&quot;create_time&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">toMpPageDefaultSortByUpdateTimeDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> toMpPage(<span class="string">&quot;update_time&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PageQuery</code>是前端提交的查询参数，一般包含四个属性：</p><ul><li><code>pageNo</code>：页码</li><li><code>pageSize</code>：每页数据条数</li><li><code>sortBy</code>：排序字段</li><li><code>isAsc</code>：是否升序</li></ul><p><strong>PageDTO：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Schema(description = &quot;分页结果&quot;)</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageDTO</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Schema(description = &quot;总条数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="meta">@Schema(description = &quot;总页数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long pages;</span><br><span class="line">    <span class="meta">@Schema(description = &quot;集合&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回空分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">empty</span><span class="params">(Page&lt;P&gt; p)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), Collections.emptyList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> voClass 目标VO类型的字节码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Class&lt;V&gt; voClass)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = BeanUtil.copyToList(records, voClass);</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将MybatisPlus分页结果转为 VO分页结果，允许用户自定义PO到VO的转换方式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> p MybatisPlus的分页结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> convertor PO到VO的转换函数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 目标VO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;P&gt; 原始PO类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> VO的分页对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;V, P&gt; PageDTO&lt;V&gt; <span class="title function_">of</span><span class="params">(Page&lt;P&gt; p, Function&lt;P, V&gt; convertor)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.非空校验</span></span><br><span class="line">        List&lt;P&gt; records = p.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (records == <span class="literal">null</span> || records.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 无数据，返回空结果</span></span><br><span class="line">            <span class="keyword">return</span> empty(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2.数据转换</span></span><br><span class="line">        List&lt;V&gt; vos = records.stream().map(convertor).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 3.封装返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(p.getTotal(), p.getPages(), vos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="②-开发接口"><a href="#②-开发接口" class="headerlink" title="② 开发接口"></a>② 开发接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分页查询 page</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/page&quot;)</span></span><br><span class="line"><span class="meta">@Operation(summary = &quot;分页查询 page&quot;)</span></span><br><span class="line"><span class="keyword">public</span> PageDTO&lt;UserVO&gt; <span class="title function_">queryUsersPage</span><span class="params">(<span class="meta">@ParameterObject</span> UserQuery query)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;queryUsersPage ===&gt; &#123;&#125;&quot;</span>, query);</span><br><span class="line">    Page&lt;UserEntity&gt; userEntityPage = userService.page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;UserEntity&gt;(query.getPageNo(), query.getPageSize())</span><br><span class="line">                    .addOrder(ObjectUtil.isEmpty(query.getSortBy()) ?</span><br><span class="line">                            OrderItem.desc(<span class="string">&quot;update_time&quot;</span>) :</span><br><span class="line">                            (query.getIsAsc() != <span class="literal">null</span> &amp;&amp; query.getIsAsc() ?</span><br><span class="line">                                    OrderItem.asc(query.getSortBy()) :</span><br><span class="line">                                    OrderItem.desc(query.getSortBy()))),</span><br><span class="line">            Wrappers.lambdaQuery(UserEntity.class)</span><br><span class="line">                    .like(StrUtil.isNotBlank(query.getName()), UserEntity::getUsername, query.getName())</span><br><span class="line">                    .between(query.getMinBalance() != <span class="literal">null</span> &amp;&amp; query.getMaxBalance() != <span class="literal">null</span>, UserEntity::getBalance, query.getMinBalance(), query.getMaxBalance()));</span><br><span class="line">    System.out.println(<span class="string">&quot;userEntityPage = &quot;</span> + userEntityPage.getRecords());</span><br><span class="line">    <span class="comment">//转换为Vo</span></span><br><span class="line">    List&lt;UserVO&gt; userVOList = BeanUtil.copyToList(userEntityPage.getRecords(), UserVO.class);</span><br><span class="line">    PageDTO&lt;UserVO&gt; userVoPageDTO = <span class="keyword">new</span> <span class="title class_">PageDTO</span>&lt;&gt;(userEntityPage.getCurrent(), userEntityPage.getSize(), userVOList);</span><br><span class="line">    userVoPageDTO.setTotal(userEntityPage.getTotal());</span><br><span class="line">    System.out.println(<span class="string">&quot;userVoPageDTO = &quot;</span> + userVoPageDTO.getPages());</span><br><span class="line">    <span class="keyword">return</span> userService.queryUsersPage(query);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
          <category> 开发框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VsCode下载安装</title>
      <link href="/posts/c68db7e6.html"/>
      <url>/posts/c68db7e6.html</url>
      
        <content type="html"><![CDATA[<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VsCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea下载安装</title>
      <link href="/posts/97a0a1c6.html"/>
      <url>/posts/97a0a1c6.html</url>
      
        <content type="html"><![CDATA[<img src="/img/load.gif" data-original="https://mincong.io/assets/logo-intellij.png" alt="Idea" style="zoom: 150%;" /><h1 id="IDEA的下载"><a href="#IDEA的下载" class="headerlink" title="IDEA的下载"></a>IDEA的下载</h1><p>① 打开浏览器，访问 <strong>IDEA</strong> 官网链接：<a href="https://www.jetbrains.com/">https://www.jetbrains.com</a>，如下图所示：</p><p><img src="/img/load.gif" data-original="/images/tools/idea/a/v1.png" alt="IDEA官网"></p><p>② 点击 <strong>Developer Tools</strong> 后选择 <a href="https://www.jetbrains.com/idea/"><strong>IntelliJ IDEA</strong></a> 进入 <strong>IDEA</strong> 下载界面：</p><p><img src="/img/load.gif" data-original="/images/tools/idea/a/v2.png" alt="IntelliJ IDEA"></p><p>③ 点击 <strong>Download</strong> 后选择所处环境的 <strong>IDEA</strong> 进行 <strong>Download</strong> 下载</p><p><img src="/img/load.gif" data-original="/images/tools/idea/a/v3.png" alt="IntelliJ IDEA"></p><p><img src="/img/load.gif" data-original="/images/tools/idea/a/v4.png" alt="IntelliJ IDEA"></p><hr><h1 id="IDEA的安装"><a href="#IDEA的安装" class="headerlink" title="IDEA的安装"></a>IDEA的安装</h1><p>① 双击运行下载好的 <strong>IDEA</strong> 安装程序</p><p>② 除了选择文件安装位置，其余一律默认即可</p><p><img src="/img/load.gif" data-original="/images/tools/idea/a/v5.png" alt="IntelliJ IDEA"></p><hr><h1 id="IDEA插件"><a href="#IDEA插件" class="headerlink" title="IDEA插件"></a>IDEA插件</h1><h2 id="①-文档快速生成插件"><a href="#①-文档快速生成插件" class="headerlink" title="① 文档快速生成插件"></a>① 文档快速生成插件</h2><p><img src="/img/load.gif" data-original="/images/tools/idea/a/v6.png" alt="ApiPost-Help"></p><h2 id="②-显示代码缩略图插件"><a href="#②-显示代码缩略图插件" class="headerlink" title="② 显示代码缩略图插件"></a>② 显示代码缩略图插件</h2><p><img src="/img/load.gif" data-original="/images/tools/idea/a/v7.png" alt="CodeGlance"></p><h2 id="③-代码快速生成插件"><a href="#③-代码快速生成插件" class="headerlink" title="③ 代码快速生成插件"></a>③ 代码快速生成插件</h2><p><img src="/img/load.gif" data-original="/images/tools/idea/a/v8.png" alt="EasyCode"></p><h2 id="④-代码提交信息规范插件"><a href="#④-代码提交信息规范插件" class="headerlink" title="④ 代码提交信息规范插件"></a>④ 代码提交信息规范插件</h2><p><img src="/img/load.gif" data-original="/images/tools/idea/a/v9.png" alt="Git Commit Message Helper"></p><h2 id="⑤-Mybatis框架插件"><a href="#⑤-Mybatis框架插件" class="headerlink" title="⑤ Mybatis框架插件"></a>⑤ Mybatis框架插件</h2><p><img src="/img/load.gif" data-original="/images/tools/idea/a/v10.png" alt="MybatisX"></p><h2 id="⑥-彩虹括号插件"><a href="#⑥-彩虹括号插件" class="headerlink" title="⑥ 彩虹括号插件"></a>⑥ 彩虹括号插件</h2><p><img src="/img/load.gif" data-original="/images/tools/idea/a/v11.png" alt="Rainbow Brackets"></p><h2 id="⑦-类注释呈现插件"><a href="#⑦-类注释呈现插件" class="headerlink" title="⑦ 类注释呈现插件"></a>⑦ 类注释呈现插件</h2><p><img src="/img/load.gif" data-original="/images/tools/idea/a/v12.png" alt="Show Comment"></p><h2 id="⑧-通义智能AI插件"><a href="#⑧-通义智能AI插件" class="headerlink" title="⑧ 通义智能AI插件"></a>⑧ 通义智能AI插件</h2><p><img src="/img/load.gif" data-original="/images/tools/idea/a/v13.png" alt="TongYi"></p><h2 id="⑨-阿里巴巴规约插件"><a href="#⑨-阿里巴巴规约插件" class="headerlink" title="⑨ 阿里巴巴规约插件"></a>⑨ 阿里巴巴规约插件</h2><p><img src="/img/load.gif" data-original="/images/tools/idea/a/v14.png" alt="Alibaba Java Coding Guidenlines"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装Docker</title>
      <link href="/posts/f5f9fa9b.html"/>
      <url>/posts/f5f9fa9b.html</url>
      
        <content type="html"><![CDATA[<p><img src="/img/load.gif" data-original="https://pic.imgdb.cn/item/64c0ad651ddac507cc99ceb7.jpg" alt="docker"></p><h1 id="1-卸载旧版"><a href="#1-卸载旧版" class="headerlink" title="1.卸载旧版"></a>1.卸载旧版</h1><p>首先如果系统中已存在旧的 <strong>Docker</strong> ，则先卸载：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">    docker-client \</span><br><span class="line">    docker-client-latest \</span><br><span class="line">    docker-common \</span><br><span class="line">    docker-latest \</span><br><span class="line">    docker-latest-logrotate \</span><br><span class="line">    docker-logrotate \</span><br><span class="line">    docker-engine \</span><br><span class="line">    docker-selinux </span><br></pre></td></tr></table></figure><h1 id="2-配置-Docker-的-yum-库"><a href="#2-配置-Docker-的-yum-库" class="headerlink" title="2.配置 Docker 的 yum 库"></a>2.配置 Docker 的 yum 库</h1><p>首先要安装一个 <strong>yum</strong> 工具</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>安装成功后，执行命令，配置 <strong>Docker</strong> 的 <strong>yum</strong> 源</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> sed -i <span class="string">&#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27;</span> /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure><p>更新 <strong>yum</strong> 建立缓存</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum makecache fast</span><br></pre></td></tr></table></figure><h1 id="3-安装-Docker"><a href="#3-安装-Docker" class="headerlink" title="3.安装 Docker"></a>3.安装 Docker</h1><p>执行命令，安装 <strong>Docker</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br></pre></td></tr></table></figure><h1 id="4-启动和校验"><a href="#4-启动和校验" class="headerlink" title="4.启动和校验"></a>4.启动和校验</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动Docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止Docker</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行docker ps命令，如果不报错，说明安装启动成功</span></span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><h1 id="5-配置镜像加速"><a href="#5-配置镜像加速" class="headerlink" title="5.配置镜像加速"></a>5.配置镜像加速</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制内容，注意把其中的镜像加速地址改成你自己的</span></span><br><span class="line"><span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;http://hub-mirror.c.163.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://mirrors.sohu.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://ustc-edu-cn.mirror.aliyuncs.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://ccr.ccs.tencentyun.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.m.daocloud.io&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.awsl9527.cn&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载配置</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启Docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
          <category> 环境搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p><img src="/img/load.gif" data-original="https://wallpaperm.cmcm.com/d5930dbadd09bfeec767d7c538f92445.jpg" alt="图片"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
