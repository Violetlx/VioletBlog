<?xml version="1.0" encoding="utf-8"?>
<search>
    
    
    
    <entry>
        <title>外挂标签教程</title>
        <link href="/posts/672d1b16.html"/>
        <url>/posts/672d1b16.html</url>
        <cover>https://haowallpaper.com/link/common/file/getCroppingImg/15430251672539456</cover>
        <date>Thu Oct 10 2024 16:10:37 GMT+0800</date>
        
        <content type="html"><![CDATA[]]></content>
        
        
        <categories>
            
            <category> 学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>词</title>
        <link href="/posts/e22607b1.html"/>
        <url>/posts/e22607b1.html</url>
        <cover>https://haowallpaper.com/link/common/file/getCroppingImg/0b2413c42d15c44af877ecd4a43e80ac</cover>
        <date>Tue Oct 08 2024 16:22:02 GMT+0800</date>
        
        <content type="html"><![CDATA[]]></content>
        
        
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>诗</title>
        <link href="/posts/1f44fecb.html"/>
        <url>/posts/1f44fecb.html</url>
        <cover>https://haowallpaper.com/link/common/file/getCroppingImg/15189094385356096</cover>
        <date>Tue Oct 08 2024 16:22:01 GMT+0800</date>
        
        <content type="html"><![CDATA[]]></content>
        
        
        <categories>
            
            <category> 生活 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>SaToken鉴权框架-深入</title>
        <link href="/posts/c5b41cb.html"/>
        <url>/posts/c5b41cb.html</url>
        <cover>https://picx.zhimg.com/v2-fa9bc3ed9d6f65d08873fc8cd2eec058_720w.jpg?source=172ae18b</cover>
        <date>Tue Oct 08 2024 16:03:25 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片]]]></content>
        
        
        <categories>
            
            <category> 开发框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SaToken </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>SaToken鉴权框架-基础</title>
        <link href="/posts/fe850976.html"/>
        <url>/posts/fe850976.html</url>
        <cover>https://picx.zhimg.com/v2-fa9bc3ed9d6f65d08873fc8cd2eec058_720w.jpg?source=172ae18b</cover>
        <date>Fri Sep 27 2024 16:32:20 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片][链接]sa-token介绍sa-token是一个轻量级java权限认证框架，主要解决：登录认证、权限认证、单点登录、oauth2.0、分布式session会话、微服务网关鉴权等一系列权限相关问题。sa-token旨在以简单、优雅的方式完成系统的权限认证部分，以登录认证为例，你只需要：[代码块]无需实现任何接口，无需创建任何配置文件，只需要这一句静态代码的调用，便可以完成会话登录认证。如果一个接口需要登陆后才能访问，我们只需要调用以下代码：[代码块]在sa-token中，大多数功能都可以一行代码解决：踢人下线：[代码块]权限认证：[代码块]路由拦截鉴权：[代码块]当你受够了shiro、springsecurity等框架的三拜九叩之后，你就会明白，相对于这些传统老牌框架，sa-token的api设计是多么的简单、优雅！[链接]sa-token功能预览sa-token目前主要五大功能模块：登录认证、权限认证、单点登录、oauth2.0、微服务鉴权。登录认证——单端登录、多端登录、同端互斥登录、七天免登录。权限认证——权限认证、角色认证、会话二级认证。踢人下线——根据账号id踢人下线、根据token值踢人下线。注解式鉴权——优雅的将鉴权与业务代码分离。路由拦截式鉴权——根据项目路由拦截鉴权，可适配restful模式。session会话——全端共享session，单端独享session，自定义session，方便的存取值。持久层扩展——可集成redis，重启数据不丢失。前后台分离——app、小程序等不支持cookie的终端也可以轻松鉴权。token风格定制——内置流中token风格，还可：自定义token生成策略。记住我模式——适配[记住我]模式，重启浏览器免验证。二级认证——在已登录的基础上再次认证，保证安全性。模拟他人账号——实时操作任意用户状态数据。临时身份切换——将会话身份临时切换为其他账号。同端互斥登录——像qq一样手机电脑同时在线，但是两个手机上互斥登录。账号封禁——登录封禁、按照业务分类封禁、按照处罚阶梯封禁。密码加密——提供基础加密算法，可快速md5、sha1、sha256、aes加密。会话查询——提供方便灵活的会话查询接口。httpbasic认证——一行代码接入httpbasic、digest认证。全局侦听器——在用户登录、注销、被踢下线等关键性操作时进行一些aop操作。全局过滤器——方便的处理跨域，全局设置安全响应头等操作。多账号体系认证——一个系统多套账号分开鉴权（比如商城的user表和admin表）。单点登录——内置三种单点登录模式：同城、跨域、同redis、跨redis、前后端分离等架构都可以搞定。单点注销——任意子系统内发起注销，即可全端下线。oauth2.0认证——轻松搭建oauth2.0服务，支持openid模式。分布式会话——提供共享数据中心分布式会话方案。微服务网关鉴权——适配gateway、shenyu、zuul等常见网关的路由拦截认证。rpc调用鉴权——网关转发鉴权，rpc调用鉴权，让服务调用不再裸奔。临时token认证——解决短时间的token授权问题。独立redis——将权限缓存与业务缓存分离。quick快速登录认证——为项目零代码注入一个登录页面。标签方言——提供thymeleaf标签方言集成包，提供beetl集成示例。jwt集成——提供三种模式的jwt集成方案，提供token扩展参数能力。rpc调用状态传递——提供dubbo、grpc等集成包，在rpc调用时登陆状态不丢失。参数签名——提供跨系统api调用签名校验模块，防止参数篡改，防止请求重放。自动续签——提供两种token过期策略，灵活搭配使用，还可以自动续签。开箱即用——提供springmvc、webflus、solon等常见框架集成包，开箱即用。最新技术栈——适配最新技术栈：支持springboot3.x，jdk17。功能结构图：[图片][链接]在springboot中集成[链接]1、创建项目在ide中新建一个springboot项目，例如sa-token-demo-springboot[链接]2、添加依赖在项目中添加依赖：maven方式注：如果你使用的是springboot3.x，只需要将sa-token-spring-boot-starter修改为sa-token-spring-boot3-starter即可。[代码块][链接]3、设置配置文件你可以零配置启动项目，但同时你也可以在application.yml中增加如下配置，定制性使用框架：[代码块][链接]4、创建启动类在项目中新建包com.sa.token，在此包内新建主类satokendemoapplication.java，复制以下代码：[代码块][链接]5、创建测试controller[代码块][链接]6、运行启动代码，依次运行上述接口：[图片][图片][图片][链接]登录认证[链接]1、设计思路对于一些登录之后才能访问的接口（例如：查询我的账号资料），我们通常的做法是增加一层接口校验：如果校验通过，则：正常返回数据如果校验未通过，则：抛出异常，告知其需要先进性登录。那么，判断会话是否登录的依据是什么？我们先来简单分析一下登录访问流程：用户提交name+password参数，调用登录接口。登录成功，返回这个用户的token会话凭证。用户后续的每次请求，都携带上这个token。服务器根据token判断此会话是否登录成功。所谓登录认证，指的就是服务器校验账号密码，为用户颁发token会话凭证的过程，这个token也是我们后续判断会话是否登录的关键所在。加载动态演示图[链接]2、登录与注销根据以上思路，我们需要一个会话登录的函数：[代码块]只此一句代码，便可以使会话登录成功，实际上，sa-token在背后做了大量的工作，包括但不限于：检查此账号是否之前已有登录；为账号生成token凭证与session会话；记录token活跃时间；通知全局侦听器，xx账号登录成功；将token注入到请求上下问；你暂时不需要完整了解整个登录过程，你只需要记住关键一点：sa-token为这个账号创建了一个token凭证，且通过cookie上下文返回给了前端。所以一般情况下，我们的登录接口代码，会大致类似如下：[代码块]如果你对以上代码阅读没有压力，你可能会注意到略显奇怪的一点：此处仅仅做了会话登录，但并没有主动向前端返回token信息。是因为不需要吗？严格来讲是需要的，只不过stputil.login(id)方法利用了cookie自动注入的特性，省略了你手写返回token的代码。cookie是什么？如果你对cookie功能还不太了解，也不用担心，我们会在之后的[前后端分离]章节中详细的阐述cookie功能，现在你只需要了解最基本的两点：cookie可以从后端控制往浏览器中写入token值。cookie会在前端每次发起请求时自动提交token值。因此，在cookie功能的加持下，我们可以仅靠stputil.login(id)一句代码就完成登录认证。除了登录方法，我们还需要：[代码块]异常notloginexception代表当前会话暂未登录，可能的原因有很多：前端没有提交token、前端提交的token是无效的、前端提交的token已经过期……等等，可参照：[链接]了解如何获取未登录的场景值。[链接]3、会话查询[代码块][链接]4、token查询[代码块]有关tokeninfo参数详解，请参考：[链接][链接]5、来个小测试，加深一下理解[代码块][链接][链接]权限认证[链接]1、设计思路所谓权限认证，核心逻辑就是判断一个账号是否拥有指定权限：有，就让你通过。没有？那么禁止访问！深入到底层数据中，就是每个账号都会拥有一组权限码集合，框架来校验这个集合中是否包含指定的权限码。例如：当前账号哦拥有权限码集合[&quot;user-add&quot;,&quot;user-delete&quot;,&quot;user-get&quot;]，这时候我来校验权限&quot;user-update&quot;，则其结果就是：验证失败，禁止访问。加载动态演示图[图片]functiontogglegif(){constgif=document.getelementbyid('gifimage');if(gif.style.display==='none'||gif.style.display===''){gif.style.display='block';}else{gif.style.display='none';}}所以现在问题的核心就是两个：如何获取一个账号所拥有的权限码集合？本次操作需要验证的权限码是哪个？[链接]2、获取当前账号权限码集合因为每个项目的需求不同，其权限设计也千变万化，因此[获取当前账号权限码集合]这一操作不可能内置到框架中，所以sa-token将此操作以接口的方式暴露给你，以方便你根据自己的业务逻辑进行重写。你需要做的是新建一个类，实现stpinterface接口，例如以下代码：[代码块]参数解释：loginid：账号id，即你在调用stputil.login(id)时写入的标识值。logintype：账号体系标识，此处可以暂时忽略，在[多账户认证]章节下会对这个概念做详细的解释。有同学会产生疑问：我实现了此接口，但是程序启动时好像并没有执行，是不是我写错了？答：不执行是正常现象，程序启动时不会执行这个接口的方法，在每次调用鉴权代码时，才会执行到此。[链接]3、权限校验然后就可以用以下api来鉴权了[代码块]扩展：notpermissionexception对象可通过getlogintype()方法获取具体是哪个stplogic抛出的异常[链接]4、角色校验在sa-token中，角色和权限可以分开独立验证[代码块]扩展：notroleexception对象可通过getlogintype()方法获取具体是哪个stplogic抛出的异常[链接]5、拦截全局异常有同学要问，鉴权失败，抛出异常，然后呢？要把异常显示给用户看吗？当然不可以！你可以创建一个全局异常拦截器，统一返回给前端的格式，参考：[代码块]可参考：[链接][链接]6、权限通配符sa-token允许你根据通配符指定泛权限，例如当一个账号拥有art.*的权限时，art.add、art.delete、art.update都将匹配通过[代码块]上帝权限当一个账号拥有&quot;*&quot;权限时，他可以验证通过任何权限码（角色认证同理）[链接]7、如何把权限精确到按钮级？权限精确到按钮级的意思就是指：权限范围可以控制到页面上的每一个按钮是否显示。思路：如此精确的范围控制只依赖后端已经难以完成，此时需要前端进行一定的逻辑判断。如果是前后端一体项目，可以参考：[链接]，如果是前后端分离项目，则：在登录时，把当前账号拥有的所有权限码一次性返回给前端。前端将权限码集合保存在localstorage或其他全局状态管理对象中。在需要权限控制的按钮上，使用js进行逻辑判断，例如在vue框架中我们可以使用如下写法：[代码块]以上写法只为提供一个参考示例，不同框架有不同写法，大家可根据项目技术栈灵活封装进行调用。&gt;✍前端有了鉴权后端还需要鉴权吗？需要！前端的鉴权只是一个辅助功能，对于专业人员这些限制都是可以轻松绕过的，为保证服务器安全：无论前端是否进行了权限校验，后端接口都需要对会话请求再次进行权限校验！[链接]8、示例代码[代码块][链接][链接]踢人下线所谓踢人下线，核心操作就是找到指定loginid对应的token，并设置其失效。[图片][链接]1、强制注销[代码块][链接]2、踢人下线[代码块]强制注销和踢人下线的区别在于：强制注销等价于对方主动调用了注销方法，再次访问会提示：token无效。踢人下线不会清除token信息，而是将其打上特定标记，再次访问会提示：token已被踢下线。加载动态演示图[图片]functiontogglegif1(){constgif=document.getelementbyid('gifimage1');if(gif.style.display==='none'||gif.style.display===''){gif.style.display='block';}else{gif.style.display='none';}}[链接][链接]注解鉴权[链接]注解鉴权有同学表示：尽管使用代码鉴权非常方便，但是我们仍希望把鉴权逻辑和业务逻辑分离出来，我们可以使用注解鉴权吗？当然可以！注解鉴权——优雅的将鉴权与业务代码分离！@sachecklogin：登录校验——只有登录之后才能够进入该方法。@sacheckrole(&quot;admin&quot;)：角色校验——必须具有指定角色标识才能进入该方法。@sacheckpermission(&quot;user:add&quot;)：权限校验——必须具有指定权限才能进入该方法。@sachecksafe：二级认证校验——必须二级认证之后才能进入该方法。@sacheckhttpbasic：httpbasic校验——只有通过httpbasic认证后才能进入该方法。@sacheckhttpdigest：httpdigest校验——只有通过httpdigest认证后才能进入该方法。@saignore：忽略校验——表示被修饰的方法或类无需进行注解鉴权和路由拦截器鉴权。@sacheckdisable(&quot;comment&quot;)：账号服务封禁校验——校验当前账号指定服务是否被封禁。sa-token使用全局拦截器完成注解鉴权功能，为了不为项目带来不必要的性能负担，拦截器默认处于关闭状态因此，为了使用注解鉴权，你必须手动将sa-token的全局拦截器注册到你项目中[链接]1、注册拦截器以springboot2.0为例，新建配置类satokenconfigure.java[代码块]保证此类被springboot启动类扫描到即可[链接]2、使用注解鉴权然后我们就可以愉快的使用注解鉴权了：[代码块]注：以上注解都可以加在类上，代表为这个类所有方法进行鉴权[链接]3、设定校验模式@sacheckrole与@sacheckpermission注解可设置校验模式，例如：[代码块]mode有两种取值：samode.and，标注一组权限，会话必须全部具有才可通过校验。samode.or，标注一组权限，会话只要具有其一即可通过校验。[链接]4、角色权限双重校验“or校验”假设有以下业务场景：一个接口在具有权限user.add或角色admin时可以调通。怎么写？[代码块]orrole字段代表权限校验未通过时的次要选择，两者只要一校验成功即可进入请求方法，其有三种写法：写法一：orrole=&quot;admin&quot;，代表需要拥有角色admin。写法二：orrole=&#123;&quot;admin&quot;,&quot;manager&quot;,&quot;staff&quot;&#125;，代表具有三个角色其一即可。写法三：orrole=&#123;&quot;admin,manager,staff&quot;&#125;，代表必须同时具有三个角色。[链接]5、忽略认证使用@saignore可表示一个接口忽略认证：[代码块]如上代码表示：testcontroller中的所有方法都需要登录后才可以访问，但是getlist接口可以匿名游客访问。@saignore修饰方法时代表这个方法可以被游客访问，修饰类时代表这个类中的所有接口都可以游客访问。@saignore具有最高优先级，当@saignore和其它鉴权注解一起出现时，其它鉴权注解都将被忽略。@saignore同样可以忽略掉sa-token拦截器中的路由鉴权，在下面的[路由拦截鉴权]章节中我们会讲到。[链接]6、批量注解鉴权使用@sacheckor表示批量注解鉴权：[代码块]每一项属性都可以写成数组形式，例如：[代码块]疑问：既然有了@sacheckor，为什么没有与之对应的@sacheckand呢？因为当你写多个注解时，其天然就是and校验关系，例如：[代码块][链接]7、扩展阅读在业务逻辑层使用鉴权注解：[链接]制作自定义鉴权注解注入到框架：[链接][链接][链接]路由拦截鉴权假设我们有如下需求：🗡需求场景项目中的所有接口均需要登录认证，只有登录接口本身对外开放。我们怎么实现呢？给每个接口加上鉴权注解？手写全局拦截器？似乎都不是非常方便。在这个需求中我们真正需要的是一种基于路由拦截的鉴权模式，那么在sa-token怎么实现路由拦截鉴权呢？[链接]1、注册sa-token路由拦截器以springboot2.0为例，新建配置类satokenconfigure.java[代码块]以上代码，我们注册了一个基于stputil.checklogin()的登录校验拦截器，并且排除了/user/dologin接口用来开放登录（除了/user/dologin以外的所有接口都需要登录才能访问）。⚙版本升级sainterceptor是新版本提供的拦截器，点此[链接]。[链接]2、校验函数详解自定义认证规则：newsainterceptor(handle-&gt;stputil.checklogin())是最简单的写法，代表只进行登录校验功能。我们可以往构造函数塞一个完整的lambda表达式，来定义详细的校验规则，例如：[代码块]sarouter.match()匹配函数有两个参数：参数一：要匹配的path路由。参数二：要执行的校验参数。在校验函数内不只可以使用stputil.checkpermission(&quot;xxx&quot;)进行权限校验，你还可以写任意代码，例如：[代码块][链接]3、匹配特征详解除了上述示例的path路由匹配，还可以根据很多其它特征进行匹配，以下是所有可匹配的特征：[代码块][链接]4、提前退出匹配链使用sarouter.stop()可以提前退出匹配链，例：[代码块]如上示例，代码运行至第2条匹配链时，会在stop函数处提前退出整个匹配函数，从而忽略掉剩余的所有match匹配除了stop()函数，sarouter还提供了back()函数，用于：停止匹配，结束执行，直接向前端返回结果[代码块]stop()与back()函数的区别在于：sarouter.stop()会停止匹配，进入controllersarouter.back()会停止匹配，直接返回结果到前端[链接]5、使用free打开一个独立的作用域[代码块]free()的作用是：打开一个独立的作用域，使内部的stop()不再一次性跳出整个auth函数，而是仅仅跳出当前free作用域。[链接]6、使用注解忽略掉路由拦截校验我们可以使用@saignore注解，忽略掉路由拦截认证：1、先配置好拦截规则：[代码块]2、然后在controller里又添加忽略校验的注解[代码块]请求将会跳过拦截器的校验，直接进入controller方法中。🗡注意点注解@saignore的忽略效果只针对sainterceptor拦截器和aop注解鉴权生效，对自定义拦截器与过滤器不生效。[链接]7、关闭注解校验sainterceptor只要注册到项目中，默认就会打开注解校验，如果要关闭此能力，需要：[代码块][链接][链接]session会话[链接]1、session会话是什么？session是会话中专业的数据缓存组件，通过session我们可以很方便的缓存一些高频读写数据，提高程序性能，例如：[代码块]在sa-token中，session分为三种，分别是：account-session:指的是框架为每个账号id分配的sessiontoken-session:指的是框架为每个token分配的sessioncustom-session:指的是以一个特定的值作为sessionid，来分配的session有关account-session与token-session的详细区别，可参考：[链接][链接]2、account-session有关账号session的api如下：[代码块][链接]3、token-session有关令牌-session的api如下：[代码块][链接]4、custom-session自定义session指的是一个特定的值作为sessionid来分配的session，借助自定义session，你可以为系统中的任意元素分配相应的session例如以商品id作为key为每个商品分配一个session，以便于缓存和商品相关的数据，其相关api如下：[代码块][链接]5、在session上存取值以上三种session均为框架设计概念上的区分，实际上在获取它们时，返回的都是sasession对象，你可以使用api在sasession对象上存取值：[代码块][链接]6、其他操作[代码块][链接]7、避免与httpsession混淆使用经常有同学会把sasession与httpsession进行混淆，例如：[代码块]要点：sasession与httpsession没有任何关系，在httpsession上写入的值，在sasession中无法取出httpsession并未被框架接管，在使用sa-token时，请在任何情况下均使用sasession，不要使用httpsession[链接]8、未登录场景下获取token-session默认场景下，只有登录后才能通过stputil.gettokensession()获取token-session。如果想要在未登录场景下获取token-session，有两种方法：方法一：将全局配置项tokensessionchecklogin改为false，详见：[链接]方法二：使用匿名token-session[代码块]注意点：如果前端没有提交token，或者提交的token是一个无效token的话，框架将不会根据此token创建token-session对象，而是随机一个新的token值来创建token-session对象，此token值可以通过stputil.gettokenvalue()获取到。[链接][链接]框架配置你可以零配置启动框架，但同时你也可以通过一定的参数配置，定制性使用框架，sa-token支持多种方式配置框架信息[链接]1、配置方式方式1、在application.yml或application.properties配置yaml风格[代码块]properties风格[代码块]方式2、通过代码配置模式1：[代码块]模式2：[代码块]两者的区别在于：模式1会覆盖application.yml中的配置模式2会与application.yml中的配置合并（代码配置优先）[链接]2、核心包所有可配置项你不必立刻掌握整个表格，只需要在用到某个功能时再详细查阅它即可参数名称类型默认值说明tokennamestringsatokentoken名称（同时也是cookie名称、数据持久化前缀）timeoutlong2592000token有效期（单位：秒），默认30天，-1代表永不过期[链接]activetimeoutlong-1token最低活跃频率（单位：秒），如果token超过此时间没有访问系统就会被冻结，默认-1代表不限制，永不冻结（例如可以设置为1800代表30分钟内无操作就冻结）[链接]dynamicactivetimeoutbooleanfalse是否启用动态activetimeout功能，如不需要请设置为false，节省缓存请求次数isconcurrentbooleantrue是否允许同一账号并发登录（为true时允许一起登录，为false时新登录挤掉旧登录）issharebooleantrue在多人登录同一账号时，是否共用一个token（为true时所有登录共用一个token，为false时每次登录新建一个token，login时提供了extra数据后，即使配置了为true也不能复用旧token，必须创建新token）maxlogincountint12同一账号最大登录数量，-1代表不限（只有在isconcurrent=true，isshare=false时此配置才有效），[链接]maxtrytimesint12在每次创建token时的最高循环次数，用于保证token唯一性（-1=不循环重试，直接使用）isreadbodybooleantrue是否尝试从请求体里读取tokenisreadheaderbooleantrue是否尝试从header里读取tokenisreadcookiebooleantrue是否尝试从cookie里读取token，此值为false后，stputil.login(id)登录时也不会再往前端注入cookieiswriteheaderbooleanfalse是否在登录后将token写入到响应头tokenstylestringuuidtoken风格，[链接]datarefreshperiodint30默认数据持久组件实现类中，每次清理过期数据间隔的时间（单位:秒），默认值30秒，设置为-1代表不启动定时清理tokensessioncheckloginbooleantrue获取token-session时是否必须登录（如果配置为true，会在每次获取token-session时校验是否登录），[链接]autorenewbooleantrue是否打开自动续签（如果此值为true，框架会在每次直接或间接调用getloginid()时进行一次过期检查与续签操作），[链接]tokenprefixstringnulltoken前缀，例如填写bearer实际传参satoken:bearerxxxx-xxxx-xxxx-xxxx[链接]isprintbooleantrue是否在初始化配置时打印版本字符画islogbooleanfalse是否打印操作日志loglevelstringtrace日志等级（trace、debug、info、warn、error、fatal），此值与loglevelint联动loglevelintint1日志等级int值（1=trace、2=debug、3=info、4=warn、5=error、6=fatal），此值与loglevel联动iscolorlogbooleannull是否打印彩色日志，true=打印彩色日志，false=打印黑白日志，null=框架根据运行终端自行判断是否打印彩色日志jwtsecretkeystringnulljwt秘钥（只有集成sa-token-temp-jwt模块时此参数才会生效），[链接]sametokentimeoutlong86400same-token的有效期（单位:秒），[链接]basicstring“”httpbasic认证的账号和密码[链接]currdomainstringnull配置当前项目的网络访问地址checksametokenbooleanfalse是否校验same-token（部分rpc插件有效）cookieobjectnewsacookieconfig()cookie配置对象signobjectnewsasignconfig()api签名配置对象cookie相关配置：参数名称类型默认值说明domainstringnull作用域（写入cookie时显式指定的作用域,常用于单点登录二级域名共享cookie的场景）pathstring/路径，默认写在域名根路径下securebooleanfalse是否只在https协议下有效httponlybooleanfalse是否禁止js操作cookiesamesitestringlax第三方限制级别（strict=完全禁止，lax=部分允许，none=不限制）cookie配置示例：yaml风格[代码块]properties风格[代码块]sign参数签名相关配置：参数名称类型默认值说明secretkeystringnullapi调用签名秘钥timestampdisparitylong900000接口调用时的时间戳允许的差距（单位：ms），-1代表不校验差距，默认15分钟示例：yaml风格[代码块]properties风格[代码块][链接]3、单点登录相关配置sso-server端配置：参数名称类型默认值说明modestring指定当前系统集成sso时使用的模式（约定型配置项，不对代码逻辑产生任何影响）tickettimeoutlong300ticket有效期（单位:秒）allowurlstring*所有允许的授权回调地址，多个用逗号隔开（不在此列表中的url将禁止下放ticket），参考：[链接]homeroutestring主页路由：在/sso/auth登录后不指定redirect参数的情况下默认跳转的路由isslobooleantrue是否打开单点注销功能ishttpbooleanfalse是否打开模式三（此值为true时将使用http请求：校验ticket值、单点注销、获取userinfo），参考：[链接]autorenewtimeoutboleanfalse是否在每次下发ticket时，自动续期token的有效期（根据全局timeout值）maxregclientint32在access-session上记录client信息的最高数量（-1=无限），超过此值将进行自动清退处理，先进先出ischecksignbooleantrue是否校验参数签名（方便本地调试用的一个配置项，生产环境请务必为true）配置示例：yaml风格[代码块]properties风格[代码块]sso-client端配置：参数名称类型默认值说明modestring指定当前系统集成sso时使用的模式（约定型配置项，不对代码逻辑产生任何影响）clientstring“”当前client名称标识，用于和ticket码的互相锁定serverurlstringnull配置server端主机总地址，拼接在authurl、checkticketurl、userinfourl、slourl属性前面，用以简化各种url配置，参考：[链接]authurlstring/sso/auth配置server端单点登录授权地址checkticketurlstring/sso/checkticket配置server端的ticket校验地址getdataurlstring/sso/getdata配置server端的拉取数据地址slourlstring/sso/signout配置server端单点注销地址currssologinstringnull配置当前client端的登录地址（为空时自动获取）currssologoutcallstringnull配置当前client端的单点注销回调url（为空时自动获取）isslobooleantrue是否打开单点注销功能ishttpbooleanfalse是否打开模式三（此值为true时将使用http请求：校验ticket值、单点注销、拉取数据getdata），参考：[链接]ischecksignbooleantrue是否校验参数签名（方便本地调试用的一个配置项，生产环境请务必为true）配置示例：yaml风格[代码块]properties风格[代码块][链接]4、oauth2.0相关配置参数名称类型默认值说明enableauthorizationcodebooleantrue是否打开模式：授权码（authorizationcode）enableimplicitbooleantrue是否打开模式：隐藏式（implicit）enablepasswordbooleantrue是否打开模式：密码式（password）enableclientcredentialsbooleantrue是否打开模式：凭证式（clientcredentials）isnewrefreshbooleanfalse是否在每次refresh-token刷新access-token时，产生一个新的refresh-tokencodetimeoutlong300code授权码保存的时间（单位：秒）默认五分钟accesstokentimeoutlong7200access-token保存的时间（单位：秒）默认两个小时refreshtokentimeoutlong2592000refresh-token保存的时间（单位：秒）默认30天clienttokentimeoutlong7200client-token保存的时间（单位：秒）默认两个小时lowerclienttokentimeoutlong7200lower-client-token保存的时间（单位：秒），默认为-1，代表延续client-token的有效时间openiddigestprefixstringopenid_default_digest_prefix默认openid生成算法中使用的摘要前缀higherscopestring指定高级权限，多个用逗号隔开lowerscopestring指定低级权限，多个用逗号隔开mode4returnaccesstokenbooleanfalse模式4是否返回accesstoken字段，用于兼容oauth2标准协议hidestatusfieldbooleanfalse是否在返回值中隐藏默认的状态字段(code、msg、data)oidcsaoauth2oidcconfignewsaoauth2oidcconfig()oidc相关配置yaml风格[代码块]properties风格[代码块]oidc相关配置参数名称类型默认值说明issstringiss值，如不配置则自动计算idtokentimeoutlong600idtoken有效期（单位秒）默认十分钟yaml风格[代码块]properties风格[代码块]saclientmodel属性定义参数名称类型默认值说明clientidstringnull应用id，应该全局唯一clientsecretstringnull应用秘钥contractscopeslistnull应用签约的所有权限allowredirecturislistnull应用允许授权的所有url（可以使用*号通配符）allowgranttypeslistnewarraylist&lt;&gt;()应用允许的所有grant_typeisnewrefreshboolean取全局配置单独配置此client：是否在每次refresh-token刷新access-token时，产生一个新的refresh-token[默认取全局配置]accesstokentimeoutlong取全局配置单独配置此client：access-token保存的时间（单位：秒）[默认取全局配置]refreshtokentimeoutlong取全局配置单独配置此client：refresh-token保存的时间（单位：秒）[默认取全局配置]clienttokentimeoutlong取全局配置单独配置此client：client-token保存的时间（单位：秒）[默认取全局配置]lowerclienttokentimeoutlong取全局配置单独配置此client：lower-client-token保存的时间（单位：秒）[默认取全局配置][链接]5、部分配置项详解对部分配置项做一下详解配置项详解：maxlogincount配置含义：同一账号最大登录数量。在配置isconcurrent=true,isshare=false时，sa-token将允许同一账号并发登录，且每次登录都会产生一个新token，这些token都会以tokensign的形式记录在其account-session之上，这就造成一个问题：随着同一账号登录的次数越来越多，tokensign的列表也会越来越大，极端情况下，列表长度可能达到成百上千以上，严重拖慢数据处理速度，为此sa-token对这个tokensign列表的大小设定一个上限值，也就是maxlogincount，默认值=12。假设一个账号的登录数量超过maxlogincount后，将会主动注销第一个登录的会话（先进先出），以此保证队列中的有效会话数量始终&lt;=maxlogincount值。配置项详解：tokensessionchecklogin配置含义：获取token-session时是否必须登录（如果配置为true，会在每次获取token-session时校验是否登录）。在调用stputil.login(id)登录后，调用stputil.getsession()可以获取这个会话的account-session对象。调用stputil.gettokensession()可以获取这个会话token-session对象。关于两种session有何区别，可以参考这篇：[链接]，此处暂不赘述。从设计上讲，无论会话是否已经登录，只要前端提供了token，我们就可以找到这个token的专属token-session对象，这非常灵活但不安全，因为前端提交的token可能是任意伪造的。为了解决这个问题，stputil.gettokensession()方法在获取token-session时，会率先检测一下这个token是否是一个有效token：如果是有效token，正常返回token-session对象如果是无效token，则抛出异常。这样就保证了伪造的token是无法获取token-session对象的。但是——有的场景下我们又确实需要在登录之前就使用token-session对象，这时候就把配置项tokensessionchecklogin值改为false即可。配置项详解：ishttp配置含义：是否打开单点登录模式三。此配置项为false时，代表使用sso模式二：使用redis校验ticket值、删除redis数据做到单点注销、使用redis同步userinfo数据。此配置项为true时，代表使用sso模式三：使用http请求校验ticket值、使用http请求做到单点注销、使用http请求同步userinfo数据。[链接]]]></content>
        
        
        <categories>
            
            <category> 开发框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SaToken </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>SaToken鉴权框架</title>
        <link href="/posts/fe850976.html"/>
        <url>/posts/fe850976.html</url>
        <cover>https://picx.zhimg.com/v2-fa9bc3ed9d6f65d08873fc8cd2eec058_720w.jpg?source=172ae18b</cover>
        <date>Fri Sep 27 2024 16:32:20 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片][链接]sa-token介绍sa-token是一个轻量级java权限认证框架，主要解决：登录认证、权限认证、单点登录、oauth2.0、分布式session会话、微服务网关鉴权等一系列权限相关问题。sa-token旨在以简单、优雅的方式完成系统的权限认证部分，以登录认证为例，你只需要：[代码块]无需实现任何接口，无需创建任何配置文件，只需要这一句静态代码的调用，便可以完成会话登录认证。如果一个接口需要登陆后才能访问，我们只需要调用以下代码：[代码块]在sa-token中，大多数功能都可以一行代码解决：踢人下线：[代码块]权限认证：[代码块]路由拦截鉴权：[代码块]当你受够了shiro、springsecurity等框架的三拜九叩之后，你就会明白，相对于这些传统老牌框架，sa-token的api设计是多么的简单、优雅！[链接]sa-token功能预览sa-token目前主要五大功能模块：登录认证、权限认证、单点登录、oauth2.0、微服务鉴权。登录认证——单端登录、多端登录、同端互斥登录、七天免登录。权限认证——权限认证、角色认证、会话二级认证。踢人下线——根据账号id踢人下线、根据token值踢人下线。注解式鉴权——优雅的将鉴权与业务代码分离。路由拦截式鉴权——根据项目路由拦截鉴权，可适配restful模式。session会话——全端共享session，单端独享session，自定义session，方便的存取值。持久层扩展——可集成redis，重启数据不丢失。前后台分离——app、小程序等不支持cookie的终端也可以轻松鉴权。token风格定制——内置流中token风格，还可：自定义token生成策略。记住我模式——适配[记住我]模式，重启浏览器免验证。二级认证——在已登录的基础上再次认证，保证安全性。模拟他人账号——实时操作任意用户状态数据。临时身份切换——将会话身份临时切换为其他账号。同端互斥登录——像qq一样手机电脑同时在线，但是两个手机上互斥登录。账号封禁——登录封禁、按照业务分类封禁、按照处罚阶梯封禁。密码加密——提供基础加密算法，可快速md5、sha1、sha256、aes加密。会话查询——提供方便灵活的会话查询接口。httpbasic认证——一行代码接入httpbasic、digest认证。全局侦听器——在用户登录、注销、被踢下线等关键性操作时进行一些aop操作。全局过滤器——方便的处理跨域，全局设置安全响应头等操作。多账号体系认证——一个系统多套账号分开鉴权（比如商城的user表和admin表）。单点登录——内置三种单点登录模式：同城、跨域、同redis、跨redis、前后端分离等架构都可以搞定。单点注销——任意子系统内发起注销，即可全端下线。oauth2.0认证——轻松搭建oauth2.0服务，支持openid模式。分布式会话——提供共享数据中心分布式会话方案。微服务网关鉴权——适配gateway、shenyu、zuul等常见网关的路由拦截认证。rpc调用鉴权——网关转发鉴权，rpc调用鉴权，让服务调用不再裸奔。临时token认证——解决短时间的token授权问题。独立redis——将权限缓存与业务缓存分离。quick快速登录认证——为项目零代码注入一个登录页面。标签方言——提供thymeleaf标签方言集成包，提供beetl集成示例。jwt集成——提供三种模式的jwt集成方案，提供token扩展参数能力。rpc调用状态传递——提供dubbo、grpc等集成包，在rpc调用时登陆状态不丢失。参数签名——提供跨系统api调用签名校验模块，防止参数篡改，防止请求重放。自动续签——提供两种token过期策略，灵活搭配使用，还可以自动续签。开箱即用——提供springmvc、webflus、solon等常见框架集成包，开箱即用。最新技术栈——适配最新技术栈：支持springboot3.x，jdk17。功能结构图：[图片][链接]在springboot中集成[链接]1、创建项目在ide中新建一个springboot项目，例如sa-token-demo-springboot[链接]2、添加依赖在项目中添加依赖：maven方式注：如果你使用的是springboot3.x，只需要将sa-token-spring-boot-starter修改为sa-token-spring-boot3-starter即可。[代码块][链接]3、设置配置文件你可以零配置启动项目，但同时你也可以在application.yml中增加如下配置，定制性使用框架：[代码块][链接]4、创建启动类在项目中新建包com.sa.token，在此包内新建主类satokendemoapplication.java，复制以下代码：[代码块][链接]5、创建测试controller[代码块][链接]6、运行启动代码，依次运行上述接口：[图片][图片][图片][链接]登录认证[链接]1、设计思路对于一些登录之后才能访问的接口（例如：查询我的账号资料），我们通常的做法是增加一层接口校验：如果校验通过，则：正常返回数据如果校验未通过，则：抛出异常，告知其需要先进性登录。那么，判断会话是否登录的依据是什么？我们先来简单分析一下登录访问流程：用户提交name+password参数，调用登录接口。登录成功，返回这个用户的token会话凭证。用户后续的每次请求，都携带上这个token。服务器根据token判断此会话是否登录成功。所谓登录认证，指的就是服务器校验账号密码，为用户颁发token会话凭证的过程，这个token也是我们后续判断会话是否登录的关键所在。加载动态演示图[链接]2、登录与注销根据以上思路，我们需要一个会话登录的函数：[代码块]只此一句代码，便可以使会话登录成功，实际上，sa-token在背后做了大量的工作，包括但不限于：检查此账号是否之前已有登录；为账号生成token凭证与session会话；记录token活跃时间；通知全局侦听器，xx账号登录成功；将token注入到请求上下问；你暂时不需要完整了解整个登录过程，你只需要记住关键一点：sa-token为这个账号创建了一个token凭证，且通过cookie上下文返回给了前端。所以一般情况下，我们的登录接口代码，会大致类似如下：[代码块]如果你对以上代码阅读没有压力，你可能会注意到略显奇怪的一点：此处仅仅做了会话登录，但并没有主动向前端返回token信息。是因为不需要吗？严格来讲是需要的，只不过stputil.login(id)方法利用了cookie自动注入的特性，省略了你手写返回token的代码。cookie是什么？如果你对cookie功能还不太了解，也不用担心，我们会在之后的[前后端分离]章节中详细的阐述cookie功能，现在你只需要了解最基本的两点：cookie可以从后端控制往浏览器中写入token值。cookie会在前端每次发起请求时自动提交token值。因此，在cookie功能的加持下，我们可以仅靠stputil.login(id)一句代码就完成登录认证。除了登录方法，我们还需要：[代码块]异常notloginexception代表当前会话暂未登录，可能的原因有很多：前端没有提交token、前端提交的token是无效的、前端提交的token已经过期……等等，可参照：[链接]了解如何获取未登录的场景值。[链接]3、会话查询[代码块][链接]4、token查询[代码块]有关tokeninfo参数详解，请参考：[链接][链接]5、来个小测试，加深一下理解[代码块][链接][链接]权限认证[链接]1、设计思路所谓权限认证，核心逻辑就是判断一个账号是否拥有指定权限：有，就让你通过。没有？那么禁止访问！深入到底层数据中，就是每个账号都会拥有一组权限码集合，框架来校验这个集合中是否包含指定的权限码。例如：当前账号哦拥有权限码集合[&quot;user-add&quot;,&quot;user-delete&quot;,&quot;user-get&quot;]，这时候我来校验权限&quot;user-update&quot;，则其结果就是：验证失败，禁止访问。加载动态演示图[图片]functiontogglegif(){constgif=document.getelementbyid('gifimage');if(gif.style.display==='none'||gif.style.display===''){gif.style.display='block';}else{gif.style.display='none';}}所以现在问题的核心就是两个：如何获取一个账号所拥有的权限码集合？本次操作需要验证的权限码是哪个？[链接]2、获取当前账号权限码集合因为每个项目的需求不同，其权限设计也千变万化，因此[获取当前账号权限码集合]这一操作不可能内置到框架中，所以sa-token将此操作以接口的方式暴露给你，以方便你根据自己的业务逻辑进行重写。你需要做的是新建一个类，实现stpinterface接口，例如以下代码：[代码块]参数解释：loginid：账号id，即你在调用stputil.login(id)时写入的标识值。logintype：账号体系标识，此处可以暂时忽略，在[多账户认证]章节下会对这个概念做详细的解释。有同学会产生疑问：我实现了此接口，但是程序启动时好像并没有执行，是不是我写错了？答：不执行是正常现象，程序启动时不会执行这个接口的方法，在每次调用鉴权代码时，才会执行到此。[链接]3、权限校验然后就可以用以下api来鉴权了[代码块]扩展：notpermissionexception对象可通过getlogintype()方法获取具体是哪个stplogic抛出的异常[链接]4、角色校验在sa-token中，角色和权限可以分开独立验证[代码块]扩展：notroleexception对象可通过getlogintype()方法获取具体是哪个stplogic抛出的异常[链接]5、拦截全局异常有同学要问，鉴权失败，抛出异常，然后呢？要把异常显示给用户看吗？当然不可以！你可以创建一个全局异常拦截器，统一返回给前端的格式，参考：[代码块]可参考：[链接][链接]6、权限通配符sa-token允许你根据通配符指定泛权限，例如当一个账号拥有art.*的权限时，art.add、art.delete、art.update都将匹配通过[代码块]上帝权限当一个账号拥有&quot;*&quot;权限时，他可以验证通过任何权限码（角色认证同理）[链接]7、如何把权限精确到按钮级？权限精确到按钮级的意思就是指：权限范围可以控制到页面上的每一个按钮是否显示。思路：如此精确的范围控制只依赖后端已经难以完成，此时需要前端进行一定的逻辑判断。如果是前后端一体项目，可以参考：[链接]，如果是前后端分离项目，则：在登录时，把当前账号拥有的所有权限码一次性返回给前端。前端将权限码集合保存在localstorage或其他全局状态管理对象中。在需要权限控制的按钮上，使用js进行逻辑判断，例如在vue框架中我们可以使用如下写法：[代码块]以上写法只为提供一个参考示例，不同框架有不同写法，大家可根据项目技术栈灵活封装进行调用。&gt;✍前端有了鉴权后端还需要鉴权吗？需要！前端的鉴权只是一个辅助功能，对于专业人员这些限制都是可以轻松绕过的，为保证服务器安全：无论前端是否进行了权限校验，后端接口都需要对会话请求再次进行权限校验！[链接]8、示例代码[代码块][链接][链接]踢人下线所谓踢人下线，核心操作就是找到指定loginid对应的token，并设置其失效。[图片][链接]1、强制注销[代码块][链接]2、踢人下线[代码块]强制注销和踢人下线的区别在于：强制注销等价于对方主动调用了注销方法，再次访问会提示：token无效。踢人下线不会清除token信息，而是将其打上特定标记，再次访问会提示：token已被踢下线。加载动态演示图[图片]functiontogglegif1(){constgif=document.getelementbyid('gifimage1');if(gif.style.display==='none'||gif.style.display===''){gif.style.display='block';}else{gif.style.display='none';}}[链接][链接]注解鉴权[链接]注解鉴权有同学表示：尽管使用代码鉴权非常方便，但是我们仍希望把鉴权逻辑和业务逻辑分离出来，我们可以使用注解鉴权吗？当然可以！注解鉴权——优雅的将鉴权与业务代码分离！@sachecklogin：登录校验——只有登录之后才能够进入该方法。@sacheckrole(&quot;admin&quot;)：角色校验——必须具有指定角色标识才能进入该方法。@sacheckpermission(&quot;user:add&quot;)：权限校验——必须具有指定权限才能进入该方法。@sachecksafe：二级认证校验——必须二级认证之后才能进入该方法。@sacheckhttpbasic：httpbasic校验——只有通过httpbasic认证后才能进入该方法。@sacheckhttpdigest：httpdigest校验——只有通过httpdigest认证后才能进入该方法。@saignore：忽略校验——表示被修饰的方法或类无需进行注解鉴权和路由拦截器鉴权。@sacheckdisable(&quot;comment&quot;)：账号服务封禁校验——校验当前账号指定服务是否被封禁。sa-token使用全局拦截器完成注解鉴权功能，为了不为项目带来不必要的性能负担，拦截器默认处于关闭状态因此，为了使用注解鉴权，你必须手动将sa-token的全局拦截器注册到你项目中[链接]1、注册拦截器以springboot2.0为例，新建配置类satokenconfigure.java[代码块]保证此类被springboot启动类扫描到即可[链接]2、使用注解鉴权然后我们就可以愉快的使用注解鉴权了：[代码块]注：以上注解都可以加在类上，代表为这个类所有方法进行鉴权[链接]3、设定校验模式@sacheckrole与@sacheckpermission注解可设置校验模式，例如：[代码块]mode有两种取值：samode.and，标注一组权限，会话必须全部具有才可通过校验。samode.or，标注一组权限，会话只要具有其一即可通过校验。[链接]4、角色权限双重校验“or校验”假设有以下业务场景：一个接口在具有权限user.add或角色admin时可以调通。怎么写？[代码块]orrole字段代表权限校验未通过时的次要选择，两者只要一校验成功即可进入请求方法，其有三种写法：写法一：orrole=&quot;admin&quot;，代表需要拥有角色admin。写法二：orrole=&#123;&quot;admin&quot;,&quot;manager&quot;,&quot;staff&quot;&#125;，代表具有三个角色其一即可。写法三：orrole=&#123;&quot;admin,manager,staff&quot;&#125;，代表必须同时具有三个角色。[链接]5、忽略认证使用@saignore可表示一个接口忽略认证：[代码块]如上代码表示：testcontroller中的所有方法都需要登录后才可以访问，但是getlist接口可以匿名游客访问。@saignore修饰方法时代表这个方法可以被游客访问，修饰类时代表这个类中的所有接口都可以游客访问。@saignore具有最高优先级，当@saignore和其它鉴权注解一起出现时，其它鉴权注解都将被忽略。@saignore同样可以忽略掉sa-token拦截器中的路由鉴权，在下面的[路由拦截鉴权]章节中我们会讲到。[链接]6、批量注解鉴权使用@sacheckor表示批量注解鉴权：[代码块]每一项属性都可以写成数组形式，例如：[代码块]疑问：既然有了@sacheckor，为什么没有与之对应的@sacheckand呢？因为当你写多个注解时，其天然就是and校验关系，例如：[代码块][链接]7、扩展阅读在业务逻辑层使用鉴权注解：[链接]制作自定义鉴权注解注入到框架：[链接][链接][链接]路由拦截鉴权假设我们有如下需求：🗡需求场景项目中的所有接口均需要登录认证，只有登录接口本身对外开放。我们怎么实现呢？给每个接口加上鉴权注解？手写全局拦截器？似乎都不是非常方便。在这个需求中我们真正需要的是一种基于路由拦截的鉴权模式，那么在sa-token怎么实现路由拦截鉴权呢？[链接]1、注册sa-token路由拦截器以springboot2.0为例，新建配置类satokenconfigure.java[代码块]以上代码，我们注册了一个基于stputil.checklogin()的登录校验拦截器，并且排除了/user/dologin接口用来开放登录（除了/user/dologin以外的所有接口都需要登录才能访问）。⚙版本升级sainterceptor是新版本提供的拦截器，点此[链接]。[链接]2、校验函数详解自定义认证规则：newsainterceptor(handle-&gt;stputil.checklogin())是最简单的写法，代表只进行登录校验功能。我们可以往构造函数塞一个完整的lambda表达式，来定义详细的校验规则，例如：[代码块]sarouter.match()匹配函数有两个参数：参数一：要匹配的path路由。参数二：要执行的校验参数。在校验函数内不只可以使用stputil.checkpermission(&quot;xxx&quot;)进行权限校验，你还可以写任意代码，例如：[代码块][链接]3、匹配特征详解除了上述示例的path路由匹配，还可以根据很多其它特征进行匹配，以下是所有可匹配的特征：[代码块][链接]4、提前退出匹配链使用sarouter.stop()可以提前退出匹配链，例：[代码块]如上示例，代码运行至第2条匹配链时，会在stop函数处提前退出整个匹配函数，从而忽略掉剩余的所有match匹配除了stop()函数，sarouter还提供了back()函数，用于：停止匹配，结束执行，直接向前端返回结果[代码块]stop()与back()函数的区别在于：sarouter.stop()会停止匹配，进入controllersarouter.back()会停止匹配，直接返回结果到前端[链接]5、使用free打开一个独立的作用域[代码块]free()的作用是：打开一个独立的作用域，使内部的stop()不再一次性跳出整个auth函数，而是仅仅跳出当前free作用域。[链接]6、使用注解忽略掉路由拦截校验我们可以使用@saignore注解，忽略掉路由拦截认证：1、先配置好拦截规则：[代码块]2、然后在controller里又添加忽略校验的注解[代码块]请求将会跳过拦截器的校验，直接进入controller方法中。🗡注意点注解@saignore的忽略效果只针对sainterceptor拦截器和aop注解鉴权生效，对自定义拦截器与过滤器不生效。[链接]7、关闭注解校验sainterceptor只要注册到项目中，默认就会打开注解校验，如果要关闭此能力，需要：[代码块][链接][链接]session会话[链接]1、session会话是什么？session是会话中专业的数据缓存组件，通过session我们可以很方便的缓存一些高频读写数据，提高程序性能，例如：[代码块]在sa-token中，session分为三种，分别是：account-session:指的是框架为每个账号id分配的sessiontoken-session:指的是框架为每个token分配的sessioncustom-session:指的是以一个特定的值作为sessionid，来分配的session有关account-session与token-session的详细区别，可参考：[链接][链接]2、account-session有关账号session的api如下：[代码块][链接]3、token-session有关令牌-session的api如下：[代码块][链接]4、custom-session自定义session指的是一个特定的值作为sessionid来分配的session，借助自定义session，你可以为系统中的任意元素分配相应的session例如以商品id作为key为每个商品分配一个session，以便于缓存和商品相关的数据，其相关api如下：[代码块][链接]5、在session上存取值以上三种session均为框架设计概念上的区分，实际上在获取它们时，返回的都是sasession对象，你可以使用api在sasession对象上存取值：[代码块][链接]6、其他操作[代码块][链接]7、避免与httpsession混淆使用经常有同学会把sasession与httpsession进行混淆，例如：[代码块]要点：sasession与httpsession没有任何关系，在httpsession上写入的值，在sasession中无法取出httpsession并未被框架接管，在使用sa-token时，请在任何情况下均使用sasession，不要使用httpsession[链接]8、未登录场景下获取token-session默认场景下，只有登录后才能通过stputil.gettokensession()获取token-session。如果想要在未登录场景下获取token-session，有两种方法：方法一：将全局配置项tokensessionchecklogin改为false，详见：[链接]方法二：使用匿名token-session[代码块]注意点：如果前端没有提交token，或者提交的token是一个无效token的话，框架将不会根据此token创建token-session对象，而是随机一个新的token值来创建token-session对象，此token值可以通过stputil.gettokenvalue()获取到。[链接][链接]框架配置你可以零配置启动框架，但同时你也可以通过一定的参数配置，定制性使用框架，sa-token支持多种方式配置框架信息[链接]1、配置方式方式1、在application.yml或application.properties配置yaml风格[代码块]properties风格[代码块]方式2、通过代码配置模式1：[代码块]模式2：[代码块]两者的区别在于：模式1会覆盖application.yml中的配置模式2会与application.yml中的配置合并（代码配置优先）[链接]2、核心包所有可配置项你不必立刻掌握整个表格，只需要在用到某个功能时再详细查阅它即可参数名称类型默认值说明tokennamestringsatokentoken名称（同时也是cookie名称、数据持久化前缀）timeoutlong2592000token有效期（单位：秒），默认30天，-1代表永不过期[链接]activetimeoutlong-1token最低活跃频率（单位：秒），如果token超过此时间没有访问系统就会被冻结，默认-1代表不限制，永不冻结（例如可以设置为1800代表30分钟内无操作就冻结）[链接]dynamicactivetimeoutbooleanfalse是否启用动态activetimeout功能，如不需要请设置为false，节省缓存请求次数isconcurrentbooleantrue是否允许同一账号并发登录（为true时允许一起登录，为false时新登录挤掉旧登录）issharebooleantrue在多人登录同一账号时，是否共用一个token（为true时所有登录共用一个token，为false时每次登录新建一个token，login时提供了extra数据后，即使配置了为true也不能复用旧token，必须创建新token）maxlogincountint12同一账号最大登录数量，-1代表不限（只有在isconcurrent=true，isshare=false时此配置才有效），[链接]maxtrytimesint12在每次创建token时的最高循环次数，用于保证token唯一性（-1=不循环重试，直接使用）isreadbodybooleantrue是否尝试从请求体里读取tokenisreadheaderbooleantrue是否尝试从header里读取tokenisreadcookiebooleantrue是否尝试从cookie里读取token，此值为false后，stputil.login(id)登录时也不会再往前端注入cookieiswriteheaderbooleanfalse是否在登录后将token写入到响应头tokenstylestringuuidtoken风格，[链接]datarefreshperiodint30默认数据持久组件实现类中，每次清理过期数据间隔的时间（单位:秒），默认值30秒，设置为-1代表不启动定时清理tokensessioncheckloginbooleantrue获取token-session时是否必须登录（如果配置为true，会在每次获取token-session时校验是否登录），[链接]autorenewbooleantrue是否打开自动续签（如果此值为true，框架会在每次直接或间接调用getloginid()时进行一次过期检查与续签操作），[链接]tokenprefixstringnulltoken前缀，例如填写bearer实际传参satoken:bearerxxxx-xxxx-xxxx-xxxx[链接]isprintbooleantrue是否在初始化配置时打印版本字符画islogbooleanfalse是否打印操作日志loglevelstringtrace日志等级（trace、debug、info、warn、error、fatal），此值与loglevelint联动loglevelintint1日志等级int值（1=trace、2=debug、3=info、4=warn、5=error、6=fatal），此值与loglevel联动iscolorlogbooleannull是否打印彩色日志，true=打印彩色日志，false=打印黑白日志，null=框架根据运行终端自行判断是否打印彩色日志jwtsecretkeystringnulljwt秘钥（只有集成sa-token-temp-jwt模块时此参数才会生效），[链接]sametokentimeoutlong86400same-token的有效期（单位:秒），[链接]basicstring“”httpbasic认证的账号和密码[链接]currdomainstringnull配置当前项目的网络访问地址checksametokenbooleanfalse是否校验same-token（部分rpc插件有效）cookieobjectnewsacookieconfig()cookie配置对象signobjectnewsasignconfig()api签名配置对象cookie相关配置：参数名称类型默认值说明domainstringnull作用域（写入cookie时显式指定的作用域,常用于单点登录二级域名共享cookie的场景）pathstring/路径，默认写在域名根路径下securebooleanfalse是否只在https协议下有效httponlybooleanfalse是否禁止js操作cookiesamesitestringlax第三方限制级别（strict=完全禁止，lax=部分允许，none=不限制）cookie配置示例：yaml风格[代码块]properties风格[代码块]sign参数签名相关配置：参数名称类型默认值说明secretkeystringnullapi调用签名秘钥timestampdisparitylong900000接口调用时的时间戳允许的差距（单位：ms），-1代表不校验差距，默认15分钟示例：yaml风格[代码块]properties风格[代码块][链接]3、单点登录相关配置sso-server端配置：参数名称类型默认值说明modestring指定当前系统集成sso时使用的模式（约定型配置项，不对代码逻辑产生任何影响）tickettimeoutlong300ticket有效期（单位:秒）allowurlstring*所有允许的授权回调地址，多个用逗号隔开（不在此列表中的url将禁止下放ticket），参考：[链接]homeroutestring主页路由：在/sso/auth登录后不指定redirect参数的情况下默认跳转的路由isslobooleantrue是否打开单点注销功能ishttpbooleanfalse是否打开模式三（此值为true时将使用http请求：校验ticket值、单点注销、获取userinfo），参考：[链接]autorenewtimeoutboleanfalse是否在每次下发ticket时，自动续期token的有效期（根据全局timeout值）maxregclientint32在access-session上记录client信息的最高数量（-1=无限），超过此值将进行自动清退处理，先进先出ischecksignbooleantrue是否校验参数签名（方便本地调试用的一个配置项，生产环境请务必为true）配置示例：yaml风格[代码块]properties风格[代码块]sso-client端配置：参数名称类型默认值说明modestring指定当前系统集成sso时使用的模式（约定型配置项，不对代码逻辑产生任何影响）clientstring“”当前client名称标识，用于和ticket码的互相锁定serverurlstringnull配置server端主机总地址，拼接在authurl、checkticketurl、userinfourl、slourl属性前面，用以简化各种url配置，参考：[链接]authurlstring/sso/auth配置server端单点登录授权地址checkticketurlstring/sso/checkticket配置server端的ticket校验地址getdataurlstring/sso/getdata配置server端的拉取数据地址slourlstring/sso/signout配置server端单点注销地址currssologinstringnull配置当前client端的登录地址（为空时自动获取）currssologoutcallstringnull配置当前client端的单点注销回调url（为空时自动获取）isslobooleantrue是否打开单点注销功能ishttpbooleanfalse是否打开模式三（此值为true时将使用http请求：校验ticket值、单点注销、拉取数据getdata），参考：[链接]ischecksignbooleantrue是否校验参数签名（方便本地调试用的一个配置项，生产环境请务必为true）配置示例：yaml风格[代码块]properties风格[代码块][链接]4、oauth2.0相关配置参数名称类型默认值说明enableauthorizationcodebooleantrue是否打开模式：授权码（authorizationcode）enableimplicitbooleantrue是否打开模式：隐藏式（implicit）enablepasswordbooleantrue是否打开模式：密码式（password）enableclientcredentialsbooleantrue是否打开模式：凭证式（clientcredentials）isnewrefreshbooleanfalse是否在每次refresh-token刷新access-token时，产生一个新的refresh-tokencodetimeoutlong300code授权码保存的时间（单位：秒）默认五分钟accesstokentimeoutlong7200access-token保存的时间（单位：秒）默认两个小时refreshtokentimeoutlong2592000refresh-token保存的时间（单位：秒）默认30天clienttokentimeoutlong7200client-token保存的时间（单位：秒）默认两个小时lowerclienttokentimeoutlong7200lower-client-token保存的时间（单位：秒），默认为-1，代表延续client-token的有效时间openiddigestprefixstringopenid_default_digest_prefix默认openid生成算法中使用的摘要前缀higherscopestring指定高级权限，多个用逗号隔开lowerscopestring指定低级权限，多个用逗号隔开mode4returnaccesstokenbooleanfalse模式4是否返回accesstoken字段，用于兼容oauth2标准协议hidestatusfieldbooleanfalse是否在返回值中隐藏默认的状态字段(code、msg、data)oidcsaoauth2oidcconfignewsaoauth2oidcconfig()oidc相关配置yaml风格[代码块]properties风格[代码块]oidc相关配置参数名称类型默认值说明issstringiss值，如不配置则自动计算idtokentimeoutlong600idtoken有效期（单位秒）默认十分钟yaml风格[代码块]properties风格[代码块]saclientmodel属性定义参数名称类型默认值说明clientidstringnull应用id，应该全局唯一clientsecretstringnull应用秘钥contractscopeslistnull应用签约的所有权限allowredirecturislistnull应用允许授权的所有url（可以使用*号通配符）allowgranttypeslistnewarraylist&lt;&gt;()应用允许的所有grant_typeisnewrefreshboolean取全局配置单独配置此client：是否在每次refresh-token刷新access-token时，产生一个新的refresh-token[默认取全局配置]accesstokentimeoutlong取全局配置单独配置此client：access-token保存的时间（单位：秒）[默认取全局配置]refreshtokentimeoutlong取全局配置单独配置此client：refresh-token保存的时间（单位：秒）[默认取全局配置]clienttokentimeoutlong取全局配置单独配置此client：client-token保存的时间（单位：秒）[默认取全局配置]lowerclienttokentimeoutlong取全局配置单独配置此client：lower-client-token保存的时间（单位：秒）[默认取全局配置][链接]5、部分配置项详解对部分配置项做一下详解配置项详解：maxlogincount配置含义：同一账号最大登录数量。在配置isconcurrent=true,isshare=false时，sa-token将允许同一账号并发登录，且每次登录都会产生一个新token，这些token都会以tokensign的形式记录在其account-session之上，这就造成一个问题：随着同一账号登录的次数越来越多，tokensign的列表也会越来越大，极端情况下，列表长度可能达到成百上千以上，严重拖慢数据处理速度，为此sa-token对这个tokensign列表的大小设定一个上限值，也就是maxlogincount，默认值=12。假设一个账号的登录数量超过maxlogincount后，将会主动注销第一个登录的会话（先进先出），以此保证队列中的有效会话数量始终&lt;=maxlogincount值。配置项详解：tokensessionchecklogin配置含义：获取token-session时是否必须登录（如果配置为true，会在每次获取token-session时校验是否登录）。在调用stputil.login(id)登录后，调用stputil.getsession()可以获取这个会话的account-session对象。调用stputil.gettokensession()可以获取这个会话token-session对象。关于两种session有何区别，可以参考这篇：[链接]，此处暂不赘述。从设计上讲，无论会话是否已经登录，只要前端提供了token，我们就可以找到这个token的专属token-session对象，这非常灵活但不安全，因为前端提交的token可能是任意伪造的。为了解决这个问题，stputil.gettokensession()方法在获取token-session时，会率先检测一下这个token是否是一个有效token：如果是有效token，正常返回token-session对象如果是无效token，则抛出异常。这样就保证了伪造的token是无法获取token-session对象的。但是——有的场景下我们又确实需要在登录之前就使用token-session对象，这时候就把配置项tokensessionchecklogin值改为false即可。配置项详解：ishttp配置含义：是否打开单点登录模式三。此配置项为false时，代表使用sso模式二：使用redis校验ticket值、删除redis数据做到单点注销、使用redis同步userinfo数据。此配置项为true时，代表使用sso模式三：使用http请求校验ticket值、使用http请求做到单点注销、使用http请求同步userinfo数据。[链接]]]></content>
        
        
        <categories>
            
            <category> 开发框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SaToken </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>函数式编程</title>
        <link href="/posts/1690d21b.html"/>
        <url>/posts/1690d21b.html</url>
        <cover>https://tse2-mm.cn.bing.net/th/id/OIP-C.I-2ZrXHR3fZtG0pUgdqymQHaEL?rs=1&amp;pid=ImgDetMain</cover>
        <date>Fri Sep 27 2024 14:01:27 GMT+0800</date>
        
        <content type="html"><![CDATA[[链接]一.道之伊始宇宙初开之际，混沌之气笼罩着整个宇宙，一切模糊不清。然后，盘古开天，女娲造人：日月乃出、星辰乃现，山川蜿蜒、江河奔流、生灵万物，欣欣向荣。此日月、星辰、山川、江河、生灵万物，谓之【对象】，皆随时间而化。然而：日月之行、星汉灿烂、山川起伏、湖海汇聚，冥冥中有至理藏其中。名曰【道】，乃万物遵循之规律，亦谓之【函数】，它无问东西，亘古不变作为设计宇宙洪荒的程序员造日月、筑山川、划江河、开湖海、演化生灵万物、令其生生不息，则必用面向【对象】之手段若定规则、求本源、追纯粹，论不变，则当选【函数】编程之思想下面就让我们从【函数】开始。[链接]什么是函数什么是函数呢？函数即规则数学上：[图片]例如：inputf(x)output1?12?43?94?165?25………$f(x)=x^2$是一种规律，input按照此规律变化为output很多规律已经由人揭示，例如$e=m\cdotc^2$​程序设计中更可以自己去制定规律，一旦成为规则的制定者，你就是神[链接]大道无情[链接]无情何为无情：只要输入相同，无论多少次调用，无论什么时间调用，输出相同。[链接]佛祖成道例如[代码块]以上pray的执行结果，除了参数变化外，希望函数的执行规则永远不变[代码块]然而，由于设计上的缺陷，函数引用了外界可变的数据，如果这么使用[代码块]结果就会是[代码块]问题出在哪儿呢？函数的目的是除了参数能变化，其它部分都要不变，这样才能成为规则的一部分。佛祖要成为规则的一部分，也要保持不变改正方法[代码块]或[代码块]不是说函数不能引用外界的数据，而是它引用的数据必须也能作为规则的一部分让佛祖不变，佛祖才能成为规则[链接]函数与方法方法本质上也是函数。不过方法绑定在对象之上，它是对象个人法则函数是函数（对象数据，其它参数）而方法是对象数据.方法（其它参数）[链接]不变的好处只有不变，才能在滚滚时间洪流中屹立不倒，成为规则的一部分。多线程编程中，不变意味着线程安全[链接]合格的函数无状态[链接]大道无形[链接]函数化对象函数本无形，也就是它代表的规则：位置固定、不能传播。若要有形，让函数的规则能够传播，需要将函数化为对象。[代码块]与[代码块]区别在哪？前者是纯粹的一条两数加法规则，它的位置是固定的，要使用它，需要通过myclass.add找到它，然后执行而后者（add对象）就像长了腿，它的位置是可以变化的，想去哪里就去哪里，哪里要用到这条加法规则，把它传递过去接口的目的是为了将来用它来执行函数对象，此接口中只能有一个方法定义函数化为对象做个比喻之前是大家要统一去西天取经现在是每个菩萨、罗汉拿着经书，入世传经例如[代码块]上面的例子做了一些简单的扩展，可以看到不同的客户端可以上传自己的计算规则p.s.大部分文献都说lambda是匿名函数，但我觉得需要在这个说法上进行补充至少在java里，虽然lambda表达式本身不需要起名字，但不得提供一个对应接口嘛[链接]行为参数化已知学生类定义如下[代码块]针对一组学生集合，筛选出男学生，下面的代码实现如何，评价一下[代码块]如果需求再变动一下，要求找到18岁以下的学生，上面代码显然不能用了，改动方法如下[代码块]那么需求如果再要变动，找18岁以下男学生，怎么改？显然上述做法并不太好…更希望一个方法能处理各种情况，仔细观察以上两个方法，找不同。不同在于筛选条件部分：[代码块]和[代码块]既然它们就是不同，那么能否把它作为参数传递进来，这样处理起来不就一致了吗？[代码块]它俩要判断的逻辑不同，那这两处不同的逻辑必然要用函数来表示，将来这两个函数都需要用到student对象来判断，都应该返回一个boolean结果，怎么描述函数的长相呢？[代码块]方法可以统一成下述代码[代码块]好，最后怎么给它传递不同实现呢？[代码块]以及[代码块]还有新需求也能满足[代码块]这样就实现了以不变应万变，而变换即是一个个函数对象，也可以称之为行为参数化[链接]延迟执行在记录日志时，假设日志级别是info，debug方法会遇到下面的问题：本不需要记录日志，但expensive方法仍被执行了[代码块]改进方法1：[代码块]显然这么做，很多类似代码都要加上这样if判断，很不优雅改进方法2：在debug方法外再套一个新方法，内部逻辑大概是这样：[代码块]调用时这样：[代码块]expensive()变成了不是立刻执行，在未来if条件成立时才执行[链接]函数对象的不同类型[代码块][链接]二.函数编程语法[链接]表现形式在java语言中，lambda对象有两种形式：lambda表达式与方法引用lambda对象的类型是由它的行为决定的，如果有一些lambda对象，它们的入参类型、返回值类型都一致，那么它们可以看作是同一类的lambda对象，它们的类型，用函数式接口来表示[链接]函数类型练习：将lambda对象分类，见ppt函数接口的命名规律带有unary是一元的意思，表示一个参数带有bi或binary是二元的意思，表示两个参数ternary三元quatenary四元…方法引用也是类似，入参类型、返回值类型都一致的话，可以看作同一类的对象，也是用函数式接口表示[链接]六种方法引用[链接]1）类名::静态方法名如何理解：函数对象的逻辑部分是：调用此静态方法因此这个静态方法需要什么参数，函数对象也提供相应的参数即可[代码块]filter这个高阶函数接收的函数类型（predicate）是：一个t类型的入参，一个boolean的返回值因此我们只需要给它提供一个相符合的lambda对象即可ismale这个静态方法有入参student对应t，有返回值boolean也能对应上，所以可以直接使用输出[代码块][链接]2）类名::非静态方法名如何理解：函数对象的逻辑部分是：调用此非静态方法因此这个函数对象需要提供一个额外的对象参数，以便能够调用此非静态方法非静态方法的剩余参数，与函数对象的剩余参数一一对应例1：[代码块]上例中函数类型的参数1对应着hello方法所属类型student参数2对应着hello方法自己的参数string返回值对应着hello方法自己的返回值string输出[代码块]例2：改写之前根据性别过滤的需求[代码块]filter这个高阶函数接收的函数类型（predicate）是：一个t类型的入参，一个boolean的返回值因此我们只需要给它提供一个相符合的lambda对象即可它的入参1t对应着ismale非静态方法的所属类型student它没有其它参数，ismale方法也没有参数返回值都是boolean输出[代码块]例3：将学生对象仅保留学生的姓名[代码块]map这个高阶函数接收的函数类型是（function）是：一个t类型的参数，一个r类型的返回值它的入参1t对应着name非静态方法的所属类型student它没有剩余参数，name方法也没有参数它的返回值r对应着name方法的返回值string输出[代码块][链接]3）对象::非静态方法名如何理解：函数对象的逻辑部分是：调用此非静态方法因为对象已提供，所以不必作为函数对象参数的一部分非静态方法的剩余参数，与函数对象的剩余参数一一对应[代码块]其实较为典型的一个应用就是system.out对象中的非静态方法，最后的输出可以修改为[代码块]这是因为foreach这个高阶函数接收的函数类型（consumer）是一个t类型参数，void无返回值而system.out对象中有非静态方法voidprintln(objectx)与之一致，因此可以将此方法化为lambda对象给foreach使用[链接]4）类名::new对于构造方法，也有专门的语法把它们转换为lambda对象函数类型应满足参数部分与构造方法参数一致返回值类型与构造方法所在类一致例如：[代码块][链接]5）this::非静态方法名算是形式2的特例，只能用在类内部[代码块][链接]6）super::非静态方法名算是形式2的特例，只能用在类内部（用在要用super区分重载方法时）[代码块][链接]7）特例函数接口和方法引用之间，可以差一个返回值，例如[代码块]可以看到runnable接口不需要返回值，而实际的函数对象多出的返回值也不影响使用[链接]闭包（closure）何为闭包，闭包就是函数对象与外界变量绑定在一起，形成的整体。例如[代码块]代码中的$y\rightarrowx+y$和$x=10$，就形成了一个闭包可以想象成，函数对象有个背包，背包里可以装变量随身携带，将来函数对象甭管传递到多远的地方，包里总装着个$x=10$有个限制，局部变量x必须是final或effectivefinal的，effectivefinal意思就是，虽然没有用final修饰，但就像是用final修饰了一样，不能重新赋值，否则就语法错误。意味着闭包变量，在装进包里的那一刻，就不能变化了道理也简单，为了保证函数的不变性，防止破坏成道闭包是一种给函数执行提供数据的手段，函数执行既可以使用函数入参，还可以使用闭包变量例[代码块][链接]柯里化（carrying）柯里化的作用是让函数对象分步执行（本质上是利用多个函数对象和闭包）例如：[代码块]代码中$a\rightarrow…$是第一个函数对象，它的返回结果$b\rightarrow…$是第二个函数对象后者与前面的参数a构成了闭包step1.exec(10)确定了a的值是10，返回第二个函数对象step2，a被放入了step2对象的背包记下来了step2.exec(20)确定了b的值是20，此时可以执行a+b的操作，得到结果30step2.exec(50)分析过程类似[链接]高阶函数（higher-orderfunctions）[链接]1)内循环[链接]2)遍历二叉树[链接]3)简单流[链接]4)简单流-化简[链接]5)简单流-收集[链接]综合练习✅❌[链接]1）判断语法正确性[代码块]lambda1lambda=a,b-&gt;a-b❌lambda1lambda=(c,d)-&gt;c*d✅lambda1lambda=(inta,b)-&gt;a+b❌lambda2lambda=objecta-&gt;system.out.println(a)❌[链接]2）写出等价的lambda表达式[代码块]math::random()-&gt;math.random()math::sqrt(doublenumber)-&gt;math.sqrt(number)student::getname(studentstu)-&gt;stu.getname()student::setname(studentstu,stringnewname)-&gt;stu.setname(newname)student::hashcode(studentstu)-&gt;stu.hashcode()student::equals(studentstu,objecto)-&gt;stu.equals(o)假设已有对象studentstu=newstudent(&quot;张三&quot;);stu::getname()-&gt;stu.getname()stu::setname(stringnewname)-&gt;stu.setname(newname)student::new(stringname)-&gt;newstudent(name)[链接]3）使用函数接口解决问题把下列方法中，可能存在变化的部分，抽象为函数对象，从外界传递进来[代码块][代码块][代码块][代码块][链接]4）写出等价的方法引用[代码块][代码块][代码块][代码块][代码块][链接]5）补充代码[代码块]如果想用color::new来构造color对象，还应当补充哪些代码[链接]6）实现需求[代码块]传入参数时，分别用类名::静态方法名类名::非静态方法名来表示【学生年龄大于等于18】的条件[链接]三.streamapi[链接]过滤[代码块][图片]找到所有浆果[代码块]找到蓝色的浆果方法1：[代码块]方法2：让每个lambda只做一件事，两次filter相对于并且关系[代码块]方法3：让每个lambda只做一件事，不过比方法2强的地方可以or，and，nagate运算[代码块][链接]映射[图片][代码块][链接]降维例1[图片][代码块]这样把坚果和浆果两个集合变成了含六个元素的水果流例2：[代码块]想逐一处理每个订单中的商品[代码块]这样把一个有两个元素的订单流，变成了一个有六个元素的商品流[链接]构建根据已有的数组构建流[代码块]根据已有的collection构建流（包括list，set等）[代码块]把一个对象变成流[代码块]把多个对象变成流[代码块][链接]拼接两个流拼接[代码块][链接]截取[代码块]skip是跳过几个元素limit是限制处理的元素个数dropwhile是drop流中元素，直到条件不成立，留下剩余元素takewhile是take流中元素，直到条件不成立，舍弃剩余元素[链接]生成生成从0~9的数字[代码块]或者[代码块]如果想订制，可以用iterate方法，例如下面生成奇数序列[代码块]参数1是初始值参数2是一个特殊function，即参数类型与返回值相同，它会根据上一个元素x的值计算出当前元素需要用limit限制元素个数也可以用iterate的重载方法[代码块]参数1是初始值参数2用来限制元素个数，一旦不满足此条件，流就结束参数3相当于上个方法的参数2iterate的特点是根据上一个元素计算当前元素，如果不需要依赖上一个元素，可以改用generate方法例如下面是生成5个随机int[代码块]不过如果只是生成随机数的话，有更简单的办法[代码块]如果要指定上下限，例如下面是生成从0~9的100个随机数[代码块][链接]查找与判断下面的代码找到流中任意（any）一个偶数[代码块]注意findany返回的是optionalint对象，因为可能流中不存在偶数对于optionalint对象，一般需要用ifpresent或orelse（提供默认值）来处理与findany比较类似的是firstfirst，它俩的区别findany是找在流中任意位置的元素，不需要考虑顺序，对于上例返回6也是可以的findfirst是找第一个出现在元素，需要考虑顺序，对于上例只能返回4findany在顺序流中与findfirst表现相同，区别在于并行流下会更快判断流中是否存在任意一个偶数[代码块]它返回的是boolean值，可以直接用来判断判断流是否全部是偶数[代码块]同样，它返回的是boolean值，可以直接用来判断判断流是否全部不是偶数[代码块]nonematch与allmatch含义恰好相反[链接]排序与去重已知有数据[代码块]要求，首先按strength武力排序（逆序），武力相同的，按姓名长度排序（正序）仅用lambda来解[代码块]方法引用改写[代码块]其中：comparingint接收一个key提取器（说明按对象中哪部分来比较），返回一个比较器reversed返回一个顺序相反的比较器thencomparingint接收一个key提取器，返回一个新比较器，新比较器在原有比较器结果相等时执行新的比较逻辑增加一个辅助方法[代码块]原理：[代码块]如果不好看，改成下面的代码[代码块][链接]化简reduce(init,(p,x)-&gt;r)init代表初始值(p,x)-&gt;r是一个binaryoperator，作用是根据上次化简结果p和当前元素x，得到本次化简结果r这样两两化简，可以将流中的所有元素合并成一个结果[链接]收集collect(supplier,accumulator,combiner)supplier是描述如何创建收集容器c：()-&gt;caccumulator是描述如何向容器c添加元素x：(c,x)-&gt;voidcombiner是描述如何合并两个容器：(c1,c2)-&gt;void串行流下不需要合并容器并行流如果用的是并发容器，也不需要合并[链接]收集器collectors类中提供了很多现成的收集器，详情见网页[链接]下游收集器做groupingby分组收集时，组内可能需要进一步的数据收集，称为下游收集器，详情见网页[链接]基本流基本类型流指intstream、longstream和doublestream，它们在做数值计算时有更好的性能。转换成基本流maptointmaptolongmaptodoubleflatmaptointflatmaptolongflatmaptodoublemapmultitointmapmultitolongmapmultitodouble基本流转对象流maptoobjboxed[链接]特性一次使用：流只能使用一次（终结方法只能调用一次）两类操作：中间操作，lazy懒惰的终结操作，eager迫切的[链接]并行[代码块][链接]效率[链接]1)数组求和其中primitive用loop循环对int求和intstream用intstream对int求和boxed用loop循环对integer求和stream用stream对integer求和元素个数100benchmarkmodecntscore(ns/op)error(ns/op)unitst01sum.primitiveavgt525.424±0.782ns/opt01sum.intstreamavgt547.482±1.145ns/opt01sum.boxedavgt572.457±4.136ns/opt01sum.streamavgt5465.141±4.891ns/op元素个数1000benchmarkmodecntscore(ns/op)error(ns/op)unitst01sum.primitiveavgt5270.556±1.277ns/opt01sum.intstreamavgt5292.467±10.987ns/opt01sum.boxedavgt5583.929±57.338ns/opt01sum.streamavgt55948.294±2209.211ns/op元素个数10000benchmarkmodecntscore(ns/op)error(ns/op)unitst01sum.primitiveavgt52681.651±12.614ns/opt01sum.intstreamavgt52718.408±52.418ns/opt01sum.boxedavgt56391.285±358.154ns/opt01sum.streamavgt544414.884±3213.055ns/op结论：做数值计算，优先挑选基本流（intstream等）在数据量较大时，它的性能已经非常接近普通for循环做数值计算，应当避免普通流（stream）性能与其它几种相比，慢一个数量级[链接]2)求最大值其中（原始数据都是int，没有包装类）custom自定义多线程并行求最大值parallel并行流求最大值sequence串行流求最大值primitiveloop循环求最大值元素个数100benchmarkmodecntscore(ns/op)error(ns/op)unitst02parallel.customavgt539619.796±1263.036ns/opt02parallel.parallelavgt56754.239±79.894ns/opt02parallel.primitiveavgt529.538±3.056ns/opt02parallel.sequenceavgt580.170±1.940ns/op元素个数10000benchmarkmodecntscore(ns/op)error(ns/op)unitst02parallel.customavgt541656.093±1537.237ns/opt02parallel.parallelavgt511218.573±1994.863ns/opt02parallel.primitiveavgt52217.562±80.981ns/opt02parallel.sequenceavgt55682.482±264.645ns/op元素个数1000000benchmarkmodecntscore(ns/op)error(ns/op)unitst02parallel.customavgt5194984.564±25794.484ns/opt02parallel.parallelavgt5298940.794±31944.959ns/opt02parallel.primitiveavgt5325178.873±81314.981ns/opt02parallel.sequenceavgt5618274.062±5867.812ns/op结论：并行流相对自己用多线程实现分而治之更简洁并行流只有在数据量非常大时，才能充分发力，数据量少，还不如用串行流[链接]3)并行(发)收集元素个数100benchmarkmodecntscore(ns/op)error(ns/op)unitsloop1avgt51312.389±90.683ns/oploop2avgt51776.391±255.271ns/opsequenceavgt51727.739±28.821ns/opparallelnoconcurrentavgt527654.004±496.970ns/opparallelconcurrentavgt516320.113±344.766ns/op元素个数10000benchmarkmodecntscore(ns/op)error(ns/op)unitsloop1avgt5211526.546±13549.703ns/oploop2avgt5203794.146±3525.972ns/opsequenceavgt5237688.651±7593.483ns/opparallelnoconcurrentavgt5527203.976±3496.107ns/opparallelconcurrentavgt5369630.728±20549.731ns/op元素个数1000000benchmarkmodecntscore(ms/op)error(ms/op)unitsloop1avgt569.154±3.456ms/oploop2avgt583.815±2.307ms/opsequenceavgt5103.585±0.834ns/opparallelnoconcurrentavgt5167.032±15.406ms/opparallelconcurrentavgt552.326±1.501ms/op结论：sequence是一个容器单线程收集，数据量少时性能占优parallelnoconcurrent是多个容器多线程并行收集，时间应该花费在合并容器上，性能最差parallelconcurrent是一个容器多线程并发收集，在数据量大时性能较优[链接]4）methodhandle性能正常方法调用、反射、methodhandle、lambda的性能对比benchmarkmodecntscoreerrorunitssample2.lambdathrpt5389307532.881±332213073.039ops/ssample2.methodthrpt5157556577.611±4048306.620ops/ssample2.originthrpt5413287866.949±65182730.966ops/ssample2.reflectionthrpt591640751.456±37969233.369ops/s[链接]综合练习将filter的课堂例题修改为方法引用方式实现takewhile与filter的区别三级排序包含null值的排序二维流扁平映射三维流扁平映射用stream打印九九乘法表用stream生成斐波那契数列的前10项[代码块]自定义collector求平均[链接]四.实际应用[链接]数据统计分析[链接]1）每月的销售量结果应为[代码块]其中1970-01应该是数据的问题[代码块][链接]2）销量最高的月份结果应为[代码块][代码块][链接]3）求销量最高的商品结果应为[代码块][代码块][链接]4）下单最多的前10用户结果应为[代码块][代码块]或者[代码块][链接]5.1）每个地区下单最多的用户结果应为：[代码块][代码块][链接]5.2）每个地区下单最多的前3用户结果应为[代码块][代码块][链接]6.1）按类别统计销量结果应为[代码块][代码块][链接]6.2）按一级类别统计销量结果应为[代码块][代码块][代码块][链接]7）按价格区间统计销量p&lt;100100&lt;=p&lt;500500&lt;=p&lt;10001000&lt;=p结果应为[代码块][代码块][链接]8）不同年龄段女性所下不同类别订单a&lt;1818&lt;=a&lt;3030&lt;=a&lt;5050&lt;=a[代码块][代码块][链接]异步处理例子1:使用executorservice[代码块]例子2:使用completablefuture[代码块][链接]框架设计什么是框架？半成品软件，帮助开发者快速构建应用程序框架提供的都是固定不变的、已知的、可以重用的代码而那些每个应用不同的业务逻辑，变化的、未知的部分，则在框架外由开发者自己实现[链接]将未知交给子类spring延迟创建bean[代码块]spring中的很多类有非常复杂的继承关系，并且它们分工明确，你做什么，我做什么，职责是划分好的。例如：defaultsingletonbeanregistry是父类，它有个职责是缓存单例bean，用下面方法实现[代码块]但如何创建bean，这个父类是不知道的，创建bean是子类abstractautowirecapablebeanfactory的职责[代码块]父类中getsingleton的内部就要使用singletonfactory函数对象来获得创建好的对象[代码块]最后子类创建单例bean时，会把objectfactory这个函数对象传进去创建其它scopebean，不需要用getsingleton缓存[代码块][链接]将未知交给用户jdbctemplate[代码块]spring中jdbctemplate代码[代码块]对query来讲，建立数据库连接，创建statement对象，执行查询这些步骤都是固定的而结果要如何用java对象封装，这对框架代码是未知的，用rowmapper接口代表，将来它的lambda实现将结果转换成需要的java对象applicationlistener[代码块]对spring来讲，它并不知道如何处理事件因此可以提供一个类型为applicationlistener的lambda对象[链接]延迟拼接条件mybatis-plus[代码块]比较典型的用法有两处：第一，在调用in等方法添加条件时，第一个参数是boolean为true才会拼接sql条件，否则不拼接如何实现的呢？用dosomething类型的lambda对象来延迟拼接操作[代码块]然而，它在实现()-&gt;appendsqlsegments(...)拼接时，是不断修改一个expression状态变量，为函数编程所不齿[链接]偏门用法第二，如果用lambdaquerywrapper拼接sql条件时，为了取得列名，采用了这个办法[代码块]它要做的事很简单，但内部实现却比较复杂必须用student::getname方法引用，而不能用其它lambda对象它会实现serializable接口，序列化时会把它变成serializedlambda想办法拿到serializedlambda对象（反射调用writereplace）通过serializedlambda能够获得它对应的实际方法，也就是stringgetname()和所在类student再通过方法名推导得到属性名（去掉is，get）即name所在类student知道了，属性名name也有了，就可以进一步确定列名属性上的@tablefield指定的列名优先没有@tablefield，把属性名当作列名p.s.不是很喜欢这种做法，比较恶心但它确实是想做这么一件事：在代码中全面使用java的字段名，避免出现数据库的列名[代码块][链接]并行计算统计页面的访问次数[代码块][链接]ui事件[代码块][链接]五.实现原理[链接]lambda原理以下面代码为例[代码块]执行结果[代码块][链接]第一步，生成静态方法如何证明？用反射[代码块]输出为（去掉了包名，容易阅读）[代码块]可以看到除了我们自己写的main和test以外，多出一个名为lambda$main$0的方法这个方法是在编译期间由编译器生成的方法，是synthetic（合成）方法它的参数、内容就是lambda表达式提供的参数和内容，如下面代码片段所示[代码块][链接]第二步，生成实现类字节码如果是我自己造一个对象包含此方法，可以这么做先创建一个类[代码块]将来使用时，创建对象[代码块]只不过，jvm是在运行期间造出的这个类以及对象而已，要想查看这个类在jdk21中运行时添加虚拟机参数[代码块]早期jdk添加的参数是（没有去进行版本比对了）[代码块]若想实现在运行期间生成上述class字节码，有两种手段一是动态代理，jdk并没有采用这种办法来生成lambda类二是用lambdametafactory，它配合methodhandleapi在执行时更具性能优势[代码块]其中“apply”是接口方法名factorytype是工厂方法长相interfacemethodtype是接口方法长相implementsmethod是实现方法implementsmethodtype是实现方法长相lambdatype是实际函数对象长相callsite.gettarget()实际是调用实现类的构造方法对应的mh，最后invoke返回函数对象[链接]方法引用原理[代码块][链接]闭包原理捕获基本类型变量[代码块]生成一个带3个参数的方法，但它和binaryoperator还差一个int参数[代码块][代码块]不同之处factorytype，除了原本的接口类型之外，多了实现方法第一个参数的类型产生lambda对象的时候，通过invoke把这个参数的实际值传进去这样产生的lambdatype就是这样，并且生成lambda对象时，c的值被固定为10[代码块]捕获引用类型变量[代码块]与捕获基本类型变量类似，不过除了[代码块]还可以[代码块][链接]stream构建自定义可切分迭代器[代码块]练习：按每次切分固定大小来实现]]></content>
        
        
        <categories>
            
            <category> 程序员 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java程序员 </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>IDEA 使用 Git 详解(三)</title>
        <link href="/posts/d06fc5d7.html"/>
        <url>/posts/d06fc5d7.html</url>
        <cover>https://boosterminiclass.com/wp-content/uploads/2023/07/intellij_idea_git_2.png</cover>
        <date>Wed Sep 25 2024 14:45:04 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片][链接]管理git分支在git中，分支是一种强大的机制，它允许您偏离主开发线，例如，当您需要处理[链接]，或者冻结代码库的某个状态以进行发布等时。在intellijidea中，所有分支操作都在gitbranches弹出窗口中执行。要调用它，请在主窗口标题中单击包含当前签出的分支名称的git小部件：[图片]您还可以在git工具窗口的[链接]中管理分支并对多个分支执行批量操作。[图片]1、创建新分支从当前分支创建一个新分支在“分支”弹出窗口中，选择“新建分支”或右键单击git工具窗口的“分支”窗格中的当前分支，然后从“分支名称”中选择“新建分支”。在打开的对话框中，指定分支名称，如果要切换到该分支，请确保选择“签出分支”选项。一旦您开始为新分支输入名称，intellijidea将根据现有本地分支的名称建议相关前缀。新分支将从当前分支head开始。从选定的分支创建新分支在“分支”弹出窗口或git工具窗口的“分支”窗格中，选择要从中启动新分支的本地或远程分支，然后从“选定的”中选择“新建分支”。在打开的对话框中，指定分支名称，如果要切换到该分支，请确保选择“签出分支”选项。从选定的提交创建新分支在[链接]中，选择要充当新分支起点的提交，然后从上下文菜单中选择“新建分支”。在打开的对话框中，指定分支名称，如果要切换到该分支，请确保选择“签出分支”选项。2、重命名分支在“分支”弹出窗口或git工具窗口的“分支”窗格中，选择要重命名的分支，然后选择“重命名”。在打开的对话框中，将分支名称更改为您需要的名称。要复制分支的名称，请将鼠标悬停在该分支上并按。ctrlc3、将分支标记为收藏夹如果您有很多分支，您可能只想查看您最喜欢的分支。默认情况下，主分支被标记为收藏夹。最喜欢的分支始终显示在“分支”弹出窗口的顶部以及git工具窗口的“分支”窗格中。要将分支标记为收藏夹，请在“分支”弹出窗口中，将鼠标悬停在分支名称上，然后单击左侧显示的星形轮廓：[图片]或者，选择您想要标记为收藏的分支，然后按space。您还可以在git工具窗口的“分支”窗格中选择一个分支，然后单击工具栏上的。[图片]在搜索特定分支并导航分支列表时，按将焦点移回搜索字段。ctrlf4、集团分支机构在“分支”弹出窗口中，intellijidea将分支保留在三个节点中：最近的分支节点最多显示五个最近签出的分支。本地分支节点列出了所有本地分支。远程分支节点显示最新[链接]之后可用的所有远程分支。此外，intellijidea自动按前缀对分支进行分组并将它们存储在可扩展列表中。[图片]为了对分支进行分组，分支名称中的前缀应使用正斜杠分隔/。例如，jd/2023.1。如果您不希望按前缀对分支进行分组，请单击“分支”[图片]弹出窗口右上角的，然后取消选择“按前缀分组”选项以将其禁用。[图片]5、检查分支（git-checkout）如果您想处理其他人创建的分支，则需要将其签出以创建该分支的本地副本。要确保您拥有远程分支的完整列表，请单击“分支”[图片]弹出窗口：[图片]将分支检出为新的本地分支在“分支”弹出窗口或git工具窗口的“分支”窗格中，选择要从“远程分支”或“公共远程分支”（如果您的项目有多个根并且启用了[链接]“存储库”|远程分支（如果已禁用）。从操作列表中选择结帐。将创建、检出并设置新的本地分支以跟踪原始远程分支。您可能已经有一个与您要签出的远程分支同名的本地分支。根据具体情况，您可以通过以下方式完成结账流程：如果没有提交丢失，并且本地分支已经跟踪远程分支，intellijidea会自动将本地分支重置为远程分支，然后将其签出。如果本地分支包含可能因重置而丢失的提交，intellijidea将为您提供：删除本地提交：intellijidea将删除您的本地提交、重置本地分支并更改跟踪。变基到远程：intellijidea会将您的本地分支变基到远程分支，保留本地提交，重置本地分支并更改跟踪。分支间切换当[链接]时，您经常需要在分支之间跳转以提交不相关的更改。在“分支”弹出窗口或git工具窗口的“分支”窗格中，在“本地分支”下选择要切换到的分支，然后从可用操作列表中选择“签出”。对于多存储库项目，分支会按存储库自动分组。要检查必要的分支，请在“分支”弹出窗口中，首先选择存储库。接下来会发生什么取决于您尚未提交的本地更改与您要签出的分支之间是否存在冲突：如果你的工作树是干净的（这意味着你没有未提交的更改），或者你的本地更改与指定分支不冲突，则该分支将被签出（intellijidea右下角会弹出通知）窗户）。如果您的本地更改将被签出覆盖，intellijidea会显示阻止您签出所选分支的文件列表，并建议在forcecheckout和smartcheckout之间进行选择。如果您单击“强制签出”，您本地未提交的更改将被覆盖，并且您将丢失它们。如果您单击smartcheckout，intellijidea将[链接]未提交的更改，检出所选分支，然后取消搁置更改。如果取消搁置操作期间发生冲突，系统将提示您合并更改。有关详细信息，请参阅[链接]。[代码块]intellijidea会保存您的[链接]（一组打开的文件、当前运行配置和[链接]），前提是在“版本控制”|“设置”对话框中启用了“分支切换时恢复工作区”选项。确认。当您切换到分支时，intellijidea会自动恢复与该分支关联的上下文。ctrlalts6、比较分支机构将分支与当前分支进行比较如果你想检查一个分支与当前分支的分歧程度，你可以比较它们。从“分支”弹出窗口或git工具窗口的“分支”窗格中，选择要与当前分支进行比较的分支，然后选择“与当前比较”。git工具窗口中将添加一个新选项卡，列出所选分支中存在且当前分支中不存在的所有提交。您可以单击“交换分支”链接来更改将哪个分支视为与其他分支进行比较的基础。要查看两个分支中不同的所有文件的列表，请单击：[链接]将列出包含差异的所有文件。ctrla将分支与工作树进行比较除了将分支与当前分支进行比较之外，您还可以将其与当前分支的本地状态进行比较。如果您有本地未提交的更改，这非常有用。从“分支”弹出窗口或git工具窗口的“分支”窗格中，选择要与本地工作树进行比较的分支，然后选择“显示与工作树的差异”。打开的“更改”工具窗口显示所选分支中与当前签出的分支相比不同的所有文件的列表：[图片]所选分支中存在且当前分支中缺失的文件标记为灰色。当前分支中存在但所选分支中缺失的文件标记为绿色。包含所选分支和当前分支之间差异的文件用蓝色标记。您可以单击“交换分支”链接来更改将哪个分支视为与其他分支进行比较的基础。要查看特定文件中的差异，请选择该文件并单击[图片]工具栏上的，或按。ctrld要将整个文件内容应用到当前分支，请单击[图片]。有关详细信息，请参阅[链接]。7、删除分支将功能分支的[链接]到开发主线后，您可以删除不再需要的分支。检查您将用于进一步工作的分支。在“分支”弹出窗口中或从git工具窗口的“分支”窗格中，右键单击要删除的分支，然后选择“删除”。删除分支后，右下角会显示一条通知，您可以从中恢复已删除的分支：[图片]如果分支包含尚未合并到其上游分支或当前分支的提交，它仍然会立即删除（相当于or命令gitbranch--d）gitbranch--delete--force，但通知还将包含一个链接，允许您查看未合并的提交。如果删除的分支正在跟踪远程分支，则此通知中还会有一个用于删除远程分支的链接。[链接]中可用，直到您重新启动intellijidea。8、配置同步分支控制如果您有一个多根存储库，您可以将intellijidea配置为在所有根上同时执行所有分支操作（例如签出、合并、删除等），就像它是单个存储库一样。按打开ide设置，然后选择版本控制|吉特.ctrlalts选择“在所有根上执行分支操作”选项（请注意，此选项仅在您的项目有多个根时才可用）。如果某个操作至少在其中一个存储库中失败，intellijidea会建议您在成功的存储库中回滚此操作，从而防止分支出现分歧。如果您仅在其中一个根上检查分支，intellijidea将在“分支”弹出窗口中显示“分支已发散”警告。这意味着根项目位于不同的分支上。如果您想继续，请忽略此警告或禁用“在所有根上执行分支操作”选项。如果您仍想同时对所有根执行分支操作，请手动检查其余存储库中的同名分支。[链接]将更改从一个git分支应用到另一分支在git中，有多种方法可以将一个分支的更改集成到另一个分支：[链接][链接][链接][链接][链接]1、合并分支假设您创建了一个[链接]来处理特定任务，并希望在完成并测试功能后将工作结果集成到主代码库中：[图片]将分支合并到master是最常见的方法。当您在功能分支中工作时，您的队友会继续将他们的工作提交给master，这是很常见的情况：[图片]当您运行时merge，功能分支中的更改将集成到目标分支的head中：[图片]git创建一个新的提交(m)，称为合并提交，它是从两个分支分歧点合并来自功能分支和主分支的更改而产生的。合并分支在[链接]弹出窗口（主菜单git|分支）或git工具窗口的“分支”窗格中，选择要将更改集成到的目标分支，然后从上下文菜单中选择“签出”以切换到该分支。执行以下操作之一：如果不需要指定合并选项，请选择要合并到当前分支的分支，然后从子菜单中选择“合并到当前”。如果需要指定合并选项，请从主菜单中选择vcsgit|合并更改以打开“合并”对话框：[图片]选择要合并到当前分支的分支，单击“修改选项”并从以下选项中进行选择：[代码块]--ff-only：只有可以快进时，合并才会被解决。--squash：将在当前分支之上创建包含所有拉取更改的单个提交。-m：您将能够编辑合并提交的消息。--no-commit：将执行合并，但不会创建合并提交，以便您可以在提交之前检查合并的结果。单击“合并”。如果你的工作树是干净的（这意味着你没有未提交的更改），并且你的功能分支和目标分支之间没有发生冲突，git将合并这两个分支，并且合并提交将出现在git工具的log选项卡中窗户：alt9[图片]如果您的分支与目标分支之间发生冲突，系统会提示您解决冲突（请参阅[链接]）。如果合并后仍有未解决的冲突，则“合并冲突”节点将出现在“更改”视图的相应更改列表中，并提供解决这些冲突的链接。如果您的本地更改将被合并覆盖，intellijidea将建议执行智能合并。如果您选择此选项，intellijidea将[链接]未提交的更改，执行合并，然后取消存储更改。您可以通过从gitbranches弹出窗口中选择abort操作来取消未完成的合并操作。2、变基分支(git-rebase)当您将rebase一个分支转移到另一个分支时，您可以将第一个分支的提交应用到第二个分支中的head提交之上。假设您创建了一个功能分支来处理特定任务并向该分支进行了多次提交：[图片]当您在分支中开发时，您的队友会继续致力于掌握他们的工作：[图片]当您执行操作时，您可以通过将您的提交应用到当前head提交之上，将rebase您在功能分支中所做的更改集成到该分支中：master``master[图片]将一个分支重新建立在另一个分支之上从主菜单中选择git|变基：[图片]从列表中，选择要将当前分支变基到的目标分支：[图片]如果您需要从特定提交开始对源分支进行变基，而不是对整个分支进行变基，请单击修改选项并选择—onto。在源分支字段中，输入要将当前分支应用到新基础的提交的哈希值：[图片][链接]要复制提交哈希，请在log中选择它，右键单击它并选择copyrevisionnumber。如果您要变基的分支当前未签出，请单击“修改选项”，单击“选择另一个要变基的分支”，然后从显示的列表中选择一个分支：[图片]intellijidea将在开始变基操作之前检查此分支。如果要对分支中可访问的所有提交进行变基，请单击修改选项并选择—root（有关此选项的更多信息，请参阅[链接]）。如果您需要保留空提交（即不会从其父级更改任何内容的提交），请单击修改选项并选择—keep-empty（有关此选项的更多信息，请参阅[链接]）。如果您想在变基期间保留合并提交以便将它们保留在分支历史记录中，请单击“修改选项”并选择—preserve-merges（此选项对于interactive变基不可用）。单击变基。您可以通过从git分支弹出窗口顶部分别选择“中止”或“继续”操作来取消未完成的变基操作或恢复中断的变基操作。如果不需要指定变基选项，则可以在不调用变基对话框的情况下启动变基。在“分支”弹出窗口或[链接]工具窗口的[链接]中，选择一个分支并选择以下操作之一：使用rebase（对于远程分支）拉入current以从所选分支中[链接]检出并重新定基到当前（对于远程和本地分支）以检出所选分支并将其重新定基到当前检出的分支之上。如果远程分支本地不存在，intellijidea将静默创建一个跟踪的本地分支，检出并重新设置基准。将当前分支重新设置为所选分支（对于远程和本地分支）以将当前签出的分支重新设置为所选分支的基础。3、挑选单独的提交有时，您只需要将单个提交应用到不同的分支，而不是变基或合并整个分支。这可能很有用，例如，如果您正在一个功能分支中工作，并且想要集成在两个分支分歧后提交的master的修补程序。或者您可能想要将修复向后移植到以前的版本分支。您可以通过使用cherry-pick操作来完成此操作。挑选操作的状态显示在状态栏中。您始终可以通过在gitbranches弹出窗口中选择abortcherry-pick来中止正在进行的cherry-pick。[图片]将提交应用到另一个分支在[链接]弹出窗口（主菜单git|branches）中，选择要将更改集成到的目标分支，然后从弹出菜单中选择“签出”以切换到该分支。打开git工具窗口并切换到“日志”选项卡。alt9找到包含您要挑选的更改的提交。您可以按分支、用户或日期过滤提交。您还可以单击[图片]工具栏上的并选择突出显示|未选择的提交选项可将已应用于当前分支的提交灰显。如果您知道提交哈希，或者正在寻找标记的提交，您还可以使用“转到哈希/分支/标记”操作（按git工具窗口的“日志”选项卡，或单击工具栏上的）。ctrl0falt09[图片]选择所需的提交。使用“提交详细信息”区域中的信息来确保这些是您想要传输到另一个分支的更改。单击工具栏上的择优挑选。[图片]intellijidea将应用更改并将更改提交到目标分支。如果挑选因冲突而失败，所选更改将显示在“更改”区域中，您可以在“更改”视图中看到。您可以查看这些更改并在必要时稍后提交。如果您希望intellijidea在cherry-pick失败的情况下自动创建变更列表，请在“设置”|“设置”中打开相应的设置。版本控制|变更列表。将更改推送到目标分支。4、应用单独的更改想象一下，您对一个文件进行了一些更改，并希望将其应用到不同的分支，但这些更改是与其他修改的文件一起提交的。intellijidea允许您应用单独的更改，而不是挑选整个提交。在[链接]弹出窗口（主菜单git|branches）中，选择要将更改集成到的目标分支，然后从弹出菜单中选择“签出”以切换到该分支。打开git工具窗口并切换到“日志”选项卡。alt09找到包含您要应用的更改的提交。您可以按分支、用户或日期过滤提交。您还可以单击[图片]工具栏上的并选择突出显示|未选择的提交选项可将已应用于当前分支的提交灰显。如果您知道提交哈希，或者正在寻找标记的提交，您还可以使用“转到哈希/分支/标记”操作（按git工具窗口的“日志”选项卡，或单击工具栏上的）。ctrlfalt9[图片]在右侧的“提交详细信息”窗格中，选择包含要应用到目标分支的更改的文件，然后从上下文菜单中选择“cherry-pickselectedchanges”。在打开的对话框中，选择现有变更列表或输入新变更列表的名称，然后单击“确定”。提交更改，然后将其推送到目标分支。5、应用单独的文件除了对单个文件应用单独的更改之外，您还可以将整个文件的内容复制到不同的分支。例如，如果目标分支中不存在要应用的文件，或者在多次提交中对其进行了更改，这可能很有用。[链接]到将应用更改的分支。在[链接]弹出窗口（主菜单git|branches）或git工具窗口的“分支”窗格中，选择包含要应用的文件的分支，然后从上下文菜单中选择“显示与工作树的差异”。打开的“更改”工具窗口显示所选分支中与当前签出的分支相比不同的所有文件的列表：[图片]所选分支中存在且当前分支中缺失的文件标记为灰色。当前分支中存在但所选分支中缺失的文件标记为绿色。包含所选分支和当前分支之间差异的文件用蓝色标记。您可以单击“交换分支”链接来更改将哪个分支视为与其他分支进行比较的基础。选择要应用到当前分支的文件，然后从上下文菜单中选择“从分支获取”[图片]或单击工具栏上的。提交并推动更改。intellijidea会将文件的全部内容复制到当前分支。您还可以从“项目”视图将文件应用到另一个分支：选择包含要复制的文件的文件夹，然后选择“git|”。与分支比较|从上下文菜单中选择，然后单击工具栏上的“获取”图标。[图片][链接]解决git冲突当您在团队中工作时，您可能会遇到有人将更改推送到您当前正在处理的文件的情况。如果这些更改不重叠（即，对不同的代码行进行了更改），则会自动合并冲突的文件。但是，如果相同的行受到影响，git无法随机选择一侧而不是另一侧，并要求您解决冲突。在git中，当您尝试执行以下操作之一时可能会出现冲突：[链接]、[链接]、[链接]、[链接]、[链接]或[链接]。如果存在冲突，这些操作将失败，并且系统将提示您接受上游版本、首选您的版本或合并更改：[图片]当在git级别检测到冲突时，会自动触发“冲突”对话框。如果您在此对话框中单击“关闭”或从命令行调用导致合并冲突的git操作，则“本地更改”视图中将出现“合并冲突”节点，并提供用于解决这些问题的链接：[图片]intellijidea提供了一个在本地解决冲突的工具。该工具由三个窗格组成：左侧窗格显示只读本地副本右窗格显示签入存储库的只读版本。中央窗格是一个功能齐全的编辑器，其中显示解决冲突的结果。最初，此窗格的内容与文件的基本修订版本相同，即派生两个冲突版本的修订版本。[图片]解决冲突单击“冲突”对话框中的“合并”、“本地更改”视图中的“解决”链接，或在编辑器中选择冲突文件并选择“vcs|”。git|git从主菜单解决冲突。要自动合并所有不冲突的更改，请单击工具栏上的[图片](应用所有不冲突的更改)。您还可以使用[图片]（从左侧应用非冲突更改）和[图片]（从右侧应用非冲突更改）分别合并对话框左/右部分的非冲突更改。要解决冲突，您需要选择对左侧（本地）和右侧（存储库）版本应用哪个操作（接受[图片]或忽略），并在中央窗格中检查生成的代码：[图片][图片]您还可以右键单击中央窗格中突出显示的冲突，然后使用上下文菜单中的命令。使用左侧解决和使用右侧解决命令分别提供了从一侧接受更改并从另一侧忽略更改的快捷方式：[图片]对于简单冲突（例如，如果同一行的开头和结尾已在不同的文件修订版中修改），可以使用“解决简单冲突”[图片]按钮，该按钮允许一键合并更改。[图片]此类冲突无法通过“应用所有非冲突更改”操作来解决，因为您必须确保它们得到正确解决。[链接]请注意，中央窗格是一个功能齐全的编辑器，因此您可以直接在此对话框中更改结果代码。比较不同版本以解决冲突也可能很有用。使用[图片]工具栏按钮调用选项列表。请注意，base是指本地版本和存储库版本源自的文件版本（最初显示在中间窗格中），而middle是指结果版本。在中央窗格中查看合并结果，然后单击“应用”。1、生产力技巧自动应用不冲突的更改您可以将intellijidea配置为始终自动应用不冲突的更改，而不是从“合并”对话框中告诉它这样做。为此，请选择“工具”|“自动应用不冲突的更改”选项。ide设置的diffmerge页面。ctrlalts在中央窗格中管理更改您可以使用将鼠标悬停在装订线中的更改标记上然后单击它时出现的工具栏来管理中央窗格中的更改。工具栏与一个框架一起显示，该框架显示修改行的先前内容：[图片]例如，当存在多个不冲突的更改时，您只需跳过其中一两个更改，则可以更轻松地使用“应用所有不冲突的更改”操作同时应用所有更改，然后使用“还原”撤消不需要的更改。从此工具栏执行操作。2、处理与lf和crlf行结尾相关的冲突通常，在团队中工作并为同一存储库做出贡献的人们使用不同的操作系统。这可能会导致行结束问题，因为unix、linux和macos使用lf，而windows使用crlf来标记行结束。intellijidea在差异查看器中显示行结尾的差异，以便您可以手动修复它们。如果您希望git自动解决此类冲突，则需要在windows上将该core.autocrlf属性设置为to，在linux和macos上则需要将该属性设置为to（更多详细信息，请参阅[链接]）。您可以通过在windows或linux和macos上运行来手动更改配置。true``input``gitconfig--globalcore.autocrlftrue``gitconfig--globalcore.autocrlfinput但是，intellijidea可以自动分析您的配置，在您要提交crlf到远程存储库时发出警告，并建议将设置设置core.autocrlf为true或input取决于您的操作系统。要启用对lf和crlf行分隔符的智能处理，请打开“设置”对话框，然后选择“版本控制”|“版本控制”|“版本控制”。左侧的git节点。启用“如果将要提交crlf行分隔符则发出警告”选项。ctrlalt0s启用此选项后，每次您要提交带有分隔符的文件时，intellijidea都会显示行分隔符警告对话框，除非您在受影响的文件中crlf设置了任何相关的[链接]（在这种情况下，intellijidea假设您清楚地了解您在做什么并从分析中排除该文件）。在“行分隔符警告”对话框中，单击以下选项之一：按原样提交忽略警告并提交带有crlf分隔符的文件。修复并提交以将core.autocrlf属性设置为true或input取决于您的操作系统。因此，行分隔符将在提交之前crlf被替换。lf如果稍后您需要查看合并过程中冲突的具体解决情况，可以在git工具窗口的“日志”选项卡中找到所需的合并提交，然后在右侧的“提交详细信息”窗格中选择有冲突的文件，然后单击或按。有关详细信息，请参阅[链接]。alt9[图片]ctrld[链接]使用git同时处理多个功能有时，您需要在未完成的任务之间切换，然后再返回。intellijidea为您提供了几种方法来方便地处理多种不同的功能，而不会丢失您的工作：您可以[链接]或[链接]待处理的更改。隐藏更改与搁置非常相似。唯一的区别在于补丁的生成和应用方式。存储由git生成，可以从intellijidea内部或外部应用。搁置更改的补丁由intellijidea生成，也通过ide应用。此外，存储涉及所有未提交的更改，而当您将更改放入搁置时，您可以选择一些本地更改，而不是搁置所有更改。您可以[链接]。您可以创建[链接]。1、搁置变更搁置是暂时存储您尚未提交的待处理更改。例如，如果您需要切换到另一个任务，并且希望将更改放在一边以供稍后处理，则这非常有用。使用intellijidea，您可以搁置单独的文件和整个变更列表。您无法搁置未版本化的文件，即尚未[链接]文件。搁置后，可以根据需要多次应用更改。搁置变更在“提交”工具窗口中，右键单击要搁置的文件或更改列表，然后从上下文菜单中选择“搁置更改”。alt0[图片]在“搁置更改”对话框中，查看已修改文件的列表。在“提交消息”字段中，输入要创建的架子的名称，然后单击“架子更改”按钮。您还可以静默搁置更改，而不显示“搁置更改”对话框。为此，请选择要搁置的文件或更改列表，然后单击工具栏上的“静默搁置”图标或按。包含要搁置的更改的更改列表的名称将用作搁置名称。[图片]ctrlshifth为了避免出现多个同名的架子（例如default），您可以将文件或更改列表从“提交到”选项卡拖到“提交”工具窗口的“架子”选项卡，稍等片刻直到它被激活，释放鼠标按钮后编辑新的架子名称。如果您需要将更改复制到架子而不重置本地更改，请按并查找“保存到架子”操作。ctrlshifta取消搁置变更取消搁置是将推迟的更改从搁架移动到待处理的更改列表。未搁置的更改可以从视图中过滤掉或从搁置中删除。在[链接]选项卡中，选择更改列表或要取消搁置的文件。按或从所选内容的上下文菜单中选择“取消搁置”。ctrlshiftu[图片]在“取消搁置更改”对话框中，在“名称”字段中指定要将未搁置的更改恢复到的更改列表。您可以从列表中选择现有变更列表或输入要创建的新变更列表的名称。您可以在注释字段中输入新变更列表的描述（可选）。如果您想让新的更改列表处于活动状态，请选择“设置活动”。否则，当前活动变更列表保持活动状态。如果您希望intellijidea在停用时保存与新变更列表关联的任务的上下文，并在变更列表变为活动状态时恢复上下文，请选择“跟踪上下文”选项（有关详细信息，请参阅[链接]如果要删除要取消搁置的更改，请选择“从搁置中删除已成功应用的文件”选项。未搁置的文件将从该搁置中删除，添加到另一个更改列表中，并标记为已应用。[图片]只有通过单击工具栏上的或从上下文菜单中选择清理已取消搁置来明确删除它们，它们才会被完全删除。如果您意外删除了未搁置的文件，您可以从“最近删除”节点查看和恢复它们。单击“确定”。如果修补版本与当前版本发生冲突，请按照[链接]中的说明进行解决。您还可以静默取消搁置更改，而不显示“取消搁置更改”对话框。为此，请选择要取消搁置的文件或更改列表，然后单击工具栏上的“静默取消搁置”图标或按。未搁置的文件将移至活动的挂起更改列表。[图片]ctrlaltu您还可以将文件或更改列表从“搁置”选项卡拖到“提交到”选项卡以静默取消搁置。如果按住键拖动它，它将被复制到“提交到分支”选项卡，但也会保留在架子中。ctrl放弃搁置的更改在“书架”视图中，选择包含您不想再保留的更改的更改列表。右键单击更改列表，然后从上下文菜单中选择“删除”或按。delete恢复未搁置的更改intellijidea允许您在必要时重新应用未搁置的更改。所有未搁置的更改都可以重复使用，直到通过单击[图片]工具栏上的图标或从上下文菜单中选择“清理已未搁置”来明确删除它们为止。确保已启用显示已取消搁置的工具栏选项。[图片]选择要恢复的文件或架子。从所选内容的上下文菜单中，选择“恢复”。应用外部补丁您可以导入在intellijidea内部或外部创建的补丁，并将它们作为搁置的更改应用。在shelf视图中，从上下文菜单中选择importpatches。在打开的对话框中，选择要应用的补丁文件。选定的补丁将在“shelf”选项卡中显示为“shelf”。选择新添加的带有补丁的架子，然后从所选内容的上下文菜单中选择“取消搁置更改”。自动搁置基础修订将intellijidea配置为始终搁置受git版本控制的文件的基本修订版本可能很有用。按打开ide设置，然后选择版本控制|架子。ctrlalts选择“在分布式版本控制系统下搁置文件的基本修订版本”选项。如果启用此选项，文件的基本修订版本将保存到架子上，如果应用架子导致冲突，则该架子将在[链接]#three-way_merge)期间使用。如果禁用，intellijidea将在项目历史记录中查找基础修订版，这可能需要一段时间；此外，冲突架所基于的修订可能会丢失（例如，如果历史记录因变基操作而更改）。更改默认架子位置默认情况下，shelf目录位于您的项目目录下。但是，您可能想要更改默认的架子位置。例如，如果您想避免在清理工作副本时意外删除架子，或者希望将它们存储在单独的存储库中，以便在团队成员之间共享架子，这可能很有用。按打开ide设置，然后选择版本控制|架子。ctrlalts单击更改书架位置并在打开的对话框中指定新位置。如有必要，选择将架子移动到新位置以将现有架子移动到新目录。2、隐藏更改有时可能需要恢复工作副本以匹配head提交，但您不想丢失已经完成的工作。如果您了解到存在可能与您正在做的事情相关的上游更改，或者您需要进行一些紧急修复，则可能会发生这种情况。存储涉及记录head提交和工作目录当前状态（存储）之间的差异。对索引的更改也可以被隐藏。取消存储涉及将存储的存储应用到分支。您可以将存储应用到现有分支或在其基础上创建新分支。存储可以根据需要多次应用到您需要的任何分支，只需[链接]即可。请记住：在一系列提交后应用存储会导致需要解决的冲突。您不能将存储应用到“脏”工作副本，即具有未提交更改的工作副本。将更改保存到存储中转到git|未提交的更改|隐藏更改。在打开的“存储”对话框中，选择适当的git根目录并确保签出正确的分支。在“消息”字段中描述您要存储的更改。要存储本地更改并将索引中暂存的更改引入工作树以进行检查和测试，请选择“保留索引”选项。单击创建存储。应用隐藏转到git|未提交的更改|取消隐藏更改。选择要应用存储的git根目录，并确保签出正确的分支。从列表中选择您想要应用的存储。如果您想检查所选存储中哪些文件受到影响，请单击“查看”。要在应用所选存储后将其删除，请选择“弹出存储”选项。要同时应用隐藏的索引修改，请选择“恢复索引”选项。如果您想基于所选存储创建新分支，而不是将其应用到当前签出的分支，请在作为新分支字段中输入该分支的名称。要删除存储，请在列表中选择它，然后单击“删除”。要删除所有隐藏内容，请单击“清除”。3、将更改分组到不同的更改列表中当您正在开发多个相关功能时，您可能会发现将更改分组到不同的[链接]中很方便。与使用[链接]来处理多个任务相比，这种方法有其优点和缺点。优点：您可以轻松地在不同的逻辑更改集之间切换，并分别提交它们。与出于相同目的使用分支不同，您可以随时进行所有更改，而无需在分支之间切换，如果您的项目非常大，这可能需要一段时间。测试不同功能如何协同工作很方便。您可以在构建服务器上远程运行更改列表。缺点：虽然与分支相比，使用更改列表似乎是一个更轻量级的选项，但它并不安全，因为在提交并推送更改之前，没有更改的备份。如果您的本地工作副本发生问题，您的所有更改都将丢失，因为它们不属于git项目历史记录。不可能对功能进行原子测试。不可能就同一功能进行协作。此外，除非您通过电子邮件发送包含更改的补丁，否则您无法从不同的计算机进行贡献，这可能不是很方便。所有更改列表都显示在“提交到”选项卡的“更改”视图中。所有修改的文件都会自动放置在活动变更列表中，即“更改”变更列表，除非您创建了不同的变更列表并将其激活。更改列表显示在“更改”视图中。最初，有一个名为changes的默认更改列表。所有新更改都会自动放入更改更改列表中。还有一个未版本控制的文件更改列表，用于对尚未[链接]新创建的文件进行分组。[图片]您可以根据需要[链接]，并随时[链接]您可以[链接]任何未提交的更改移至任何更改列表。创建新的变更列表在“本地更改”视图中，单击[图片]工具栏上的并选择“新建更改列表”。在“新建更改列表”对话框中，指定新更改列表的名称，并添加说明（可选）。设置活动变更列表在“本地更改”视图中，选择一个非活动更改列表，然后按或右键单击它，然后从上下文菜单中选择“设置活动更改列表”。所有新的更改都会自动放入此更改列表中。ctrlspace[链接]在更改列表之间移动更改在“本地更改”视图中，选择要移动到另一个更改列表的更改。右键单击所选内容或单击[图片]工具栏上的并选择“移动到另一个更改列表”。altshiftm在打开的对话框中，选择现有变更列表或输入新变更列表的名称。您可以选择使目标更改列表处于活动状态并跟踪其上下文（intellijidea将保存与此更改列表关联的上下文，并在该更改列表变为活动状态时恢复它）。您还可以在更改列表之间拖动文件。有关将一个文件中的更改放入git中的不同更改列表的更多信息，请参阅将[链接]。删除变更列表右键单击更改列表，然后从上下文菜单中选择“删除更改列表”。4、使用功能分支git中的分支代表独立的开发线，因此，如果您正在开发一个单独的功能，并且希望在准备好共享工作结果并将其集成到中之前完成并测试该功能，那么在功能分支中执行此操作master是最好的解决方案。通过这种方式，您可以确保不稳定的代码不会提交到项目的主代码库，并且如果需要，您可以轻松切换到其他任务。优点：与使用变更列表对变更进行分组相反，使用功能分支是安全的。在您向git提交更改后，它们将成为git项目历史记录的一部分，因此即使您损坏了工作树，您也始终可以通过[链接]恢复您的提交。推送更改后，它们就会被备份。您可以开发并行的不相关功能并以原子方式测试它们。当您完成分支中的开发后，您可以[链接]，以便您的历史记录是线性且干净的。可以轻松地就您的功能进行协作，或者从不同的机器上进行开发。缺点：在非常大的项目上切换分支可能需要时间。一起测试相关功能不太方便。您必须学习[链接]并将更改集成到主代码库中的工作流程。使用功能分支并将更改集成到主代码库中有两种主要方法：[链接]选项[链接]选项①、使用合并来集成功能分支中的更改合并选项的主要好处是完全可追溯性，因为合并到主代码库中的提交保留了其原始哈希值和作者，并且属于一项功能的所有提交都可以分组在一起。此工作流程适用于向主代码库提交更改涉及[链接]或分层审批程序的项目，因为现有分支不会以任何方式更改。这种方法的主要缺点是，每次需要合并更改时都会创建无关的合并提交，这会严重污染项目历史记录并使其难以阅读。为您单独的开发线[链接][链接]更改。[链接]送到远程存储库。这样做是为了备份，以便您可以在不同的计算机上进行协作或工作。当您需要执行与您的功能无关的工作时，请切换到不同的分支。对您的功能进行审查和测试，并进行必要的修复。当您准备好将工作结果集成到主分支中时（例如master），请执行以下操作：[链接]您的功能分支合并到主代码库中。[链接]。推。②、使用rebase集成功能分支中的更改此选项的主要好处是您可以获得清晰的项目历史记录，易于其他人阅读和理解。您的日志不包含操作产生的不必要的合并提交merge，并且您可以获得易于导航和搜索的线性历史记录。然而，当决定采用此工作流程时，您应该记住，这会rebase重写项目历史记录，因为它会为原始功能分支中的每个提交创建新的提交，因此它们将具有不同的哈希值，这会阻碍可追溯性。为您单独的开发线[链接][链接]更改。[链接]送到远程存储库。这样做是为了备份，以便您可以在不同的计算机上进行协作或工作。master时不时地[链接]你的功能分支。仅当您的功能分支很长时才有意义。这对于：确保你的功能分支master不会相距太远。当您最终将更改集成到主代码库中时，避免解决大量冲突。当您定期进行变基时，您可以迭代地解决冲突，并且不会最终因长期差异而苦苦挣扎。加快检查分支的速度，因为一旦分支足够分散，分支之间的切换就会变慢。变基涉及以下步骤：从远程[链接]更改，或将更改[链接]master入分支。将您的分支[链接]master到.[链接]操作结果推rebase送到您的功能分支。master当您需要执行与您的功能无关的工作时切换到。当您返回到功能分支时，执行checkout并rebase到current。对您的功能进行审查和测试，并进行必要的修复。当您的功能完成后，执行交互式变基。这允许您[链接]提交，以使您的功能分支历史记录看起来干净整洁。当您准备好将工作结果集成到主分支中时（例如master），请执行以下操作：[链接]分行看看master吧[链接]您的分支与master.由于master没有分歧，git只会将指针向前移动到功能分支的最新提交，而不是创建新的合并提交（这称为快进合并）。[链接]。[链接]。使用您的姓名缩写或昵称（如果很短）作为功能分支名称的前缀是有意义的。这样，您始终可以使用“分支机构”菜单中的快速搜索轻松找到所有分支机构。[链接]撤消git存储库中的更改恢复未提交的更改在提交之前，您始终可以在本地撤消所做的更改：在“提交”工具窗口中，选择一个或多个要还原的文件，然后从上下文菜单中选择“回滚”，或按。alt0ctrlaltz自上次提交以来对所选文件所做的所有更改都将被丢弃，并且它们将从活动更改列表中消失。取消暂存文件默认情况下，intellijidea使用[链接]概念，其中修改的文件会自动暂存。如果文件已处于版本控制之下，并且您不想提交它，您可以：[链接]：不要在提交工具窗口的更改区域中选择它。[链接]。如果您更习惯暂存概念，请选择版本控制|中的启用暂存区域选项。ide设置的git页面。ctrlalts此外，默认情况下intellijidea建议将每个新创建的文件添加到版本控制下。您可以在“设置”|“设置”中更改此行为。版本控制|分别使用“创建文件时”和“删除文件时”设置进行确认。撤消最后一次提交intellijidea允许您撤消当前分支中的最后一次提交。如果提交被推送到受保护的分支，则无法撤消该提交，即不允许使用[链接]的分支（在ide设置的版本控制|git页面中配置受保护的分支）请注意，如果分支被标记由于github上受保护，当您签出时，intellijidea会自动将其标记为受保护。ctrlalts打开git工具窗口并切换到“日志”选项卡。alt9选择当前分支中的最后一次提交，然后从上下文菜单中选择“撤消提交”。在打开的对话框中，选择一个更改列表，您要放弃的更改将移至其中。您可以从名称列表中选择现有变更列表，也可以指定新变更列表的名称（默认情况下使用提交消息）。如果您想要使用要放弃活动更改列表的更改来创建更改列表，请选择“设置活动”选项。如果您希望intellijidea记住您的上下文并在此更改列表变为活动状态时重新加载编辑器中当前打开的文件，请选择“跟踪上下文”选项。恢复推送的提交如果您发现已推送的特定提交中有错误，您可以恢复该提交。此操作会产生一个新的提交，该提交会逆转您要撤消的提交的效果。因此，项目历史记录被保留，因为原始提交保持不变。在git工具窗口的“日志”选项卡中找到要还原的提交，右键单击它并从上下文菜单中选择“还原提交”。也可以从文件[链接]视图中提交的上下文菜单中使用此选项。“提交更改”对话框将打开，其中包含自动生成的提交消息。alt9如果将此操作应用于“日志”视图中选择的多个提交，则会创建一个单独的提交来还原每个提交。如果所选提交包含多个文件，并且您只需要恢复其中一些文件，请取消选择您不想触及的文件。单击“提交”以提交更改集，该更改集将还原对此特定提交中所选文件的更改。恢复选定的更改如果此提交包含多个文件并且您只需要恢复其中一些文件，则intellijidea允许您撤消推送提交中选定的更改。在日志视图中，选择包含要放弃的更改的提交。在[链接]窗格中，右键单击要还原的文件，然后从上下文菜单中选择“还原选定的更改”。这会产生一个新的提交，该提交会撤销您想要撤消的更改。删除提交与反映在分支历史记录中的[链接]不同，您可以丢弃当前分支中推送的提交，而不会留下任何操作痕迹。[链接]历史记录的操作一样，删除提交需要[链接]，并且不能在受保护的分支中执行（这些可以在ide设置的版本控制|git页面中进行配置）。ctrlalts在日志视图中选择要放弃的提交，然后从上下文菜单中选择“删除提交”。将分支重置为特定提交如果您发现最近的一组提交中存在错误并想要重做该部分，则可以将存储库回滚到特定状态。这是通过将当前分支head重置为指定的提交来完成的（如果您不想在历史记录中反映撤消，则可以选择重置索引和工作树）。打开版本控制工具窗口并切换到日志选项卡。alt09选择要将head移至的提交，然后从上下文菜单中选择将当前分支重置到此处。在打开的gitreset对话框中，选择您希望如何更新工作树和索引，然后单击reset：soft：所选提交之后所做的所有更改都将暂存（这意味着它们将被移动到“更改”视图，以便您可以查看它们并在必要时稍后提交）。混合：将保留所选提交后所做的更改，但不会暂存提交。hard：所选提交后所做的所有更改都将被丢弃（暂存和提交）。keep：所选提交后所做的已提交更改将被丢弃，但本地更改将保持不变。获取文件的先前修订版本如果您需要恢复单个文件而不是丢弃包含对多个文件的更改的整个提交，您可以返回到该文件的特定版本：在任何视图（项目工具窗口、编辑器、更改视图等）中选择必要的文件。选择git|从vcs主菜单或选择的上下文菜单显示历史记录。“历史记录”选项卡已添加到git工具窗口，显示所选文件的历史记录，并允许您查看和比较其修订版本。确定要回滚到的修订版本后，在列表中选择它，然后从上下文菜单中选择“获取”。[链接]使用标签来标记特定的git提交git允许您将标签附加到提交中，以标记项目历史记录中的某些点，以便您将来可以引用它们。例如，您可以标记与发布版本相对应的提交，而不是创建路径来捕获发布[链接]。为提交分配标签打开git工具窗口并切换到“日志”选项卡。alt09找到所需的提交，右键单击它并从上面菜单中的“新建标签”。输入新标签的名称并单击“确定”。该标签将显示在git工具窗口的“日志”选项卡中：alt09[图片]将带注释的标签分配给提交带注释标签的元数据包含创建用户的名称，因此允许您检查谁放置了它们。转到git|新标签。在打开的“标签”对话框中，在“gitroot”下，选择要在其中标记提交的本地存储库的路径，并指定新标签的名称。在“提交”字段中，指定要标记的提交。您可以输入提交哈希值，或使用表达式，例如：&lt;branch&gt;~&lt;numberofcommitsbackwardsbetweenthelatestcommit(head)andtherequiredcommit&gt;。有关更多信息，请参阅git[链接]。在消息字段中输入一些注释以创建带注释的标签（如果为空，则将创建常规标签）。点击“创建标签”。如果在“日志”工具栏的“快速设置”下启用“简洁引用视图”选项，则标记名称将隐藏在分支名称后面并且不可见。如果您不需要指定任何其他选项，还可以右键单击版本控制工具窗口的“日志”选项卡中的提交，然后从上下文菜单中选择“新建标签”。alt9分配重新现有标签如果您在错误的提交上放置了标签，并且想要重新分配它（例如，指示发布版本的提交），请执行以下操作：转到git|新标签。在“标签”对话框的“标签名称”字段中指定要重新分配的现有标签的名称。选择强制选项。在提交字段中，指定标签移动到提交位置，然后单击创建标签。跳转到标记的工作打开git工具窗口并切换到“日志”选项卡。alt9单击工具栏上的“转到分区/分支/标签”图标，或按。[图片]ctrlf[图片]输入标签名称（[链接]在您键入时建议标签名称）并按。enter查看标记的提交假设您使用标签标记了与发布版本相对应的作业，现在您想要查看项目在该时间点的快照。您可以通过检查标记的作业来实现这一点。执行以下操作之一：[链接]要签出的标记提交，右键单击它并从上下文菜单中选择“签出修订”。[链接]，单击“签出标签”或“修订版本”，然后输入标签名称（intellijidea在您输入时提供匹配标签和修订版本的列表）。请注意，此操作会导致[链接]，这意味着您不再位于任何分支中。您可以使用此快照进行检查和实验。但是，如果您想在此快照上面提交更改，则需要[链接]。积极标签默认情况下，当您执行push操作时，标签不会发送到远程存储库。在“积极作业”活动中，选中左下角的“积极活动标签”。[图片]在下拉菜单中，选择您要锻炼的标签：如果您想要人群的所有标签，包括不属于您想要的人群的选定主题的标签，请选择“全部”（第三方）push--tags。如果您的人群属于您要人群的选定分支的标签，请选择当前push--follow-tags路径（路径）。单击“全民”。删除标签[链接]标记的提交，右键单击它并选择标记|从上下文菜单中删除。[链接]编辑git项目历史记录git允许您编辑项目历史记录。当您正在处理功能分支并希望在与其他人[链接]之前清理它并使其看起来像您想要的方式时，这非常有用。例如，您可以编辑提交消息，将与相同功能相关的较小提交压缩在一起，或者将包含不相关更改的提交拆分为单独的提交，将更改添加到先前的提交等。除非绝对必要，否则请避免修改具有多个贡献者的远程分支的历史记录，例如，如果您不小心推送了一些敏感数据。为了防止数据丢失，将拒绝将重写分支历史记录的修改推送到远程存储库，因此您必须强制[链接]更改。您无法在不允许的情况下修改受保护分支的历史记录（在ide设置的版本控制|git页面中配置受保护分支）。请注意，如果分支在github上标记为受保护，则intellijidea会在您修改时自动将其标记为受保护。一探究竟。push--force``ctrlalts此外，您无法执行修改当前签出分支中未包含的提交的分支历史记录的操作。1、编辑提交消息如果您唯一需要更改的是提交消息，则可以在推送此提交之前对其进行编辑。在git工具窗口的“日志”选项卡中右键单击要编辑其消息的提交，然后从上下文菜单中选择“编辑提交消息”，或按。alt9f2在打开的对话框中，输入新的提交消息并单击“确定”。2、修改之前的commit有时，您可能会过早提交并忘记添加一些文件，或者注意到上次提交中存在错误，您希望在不创建单独提交的情况下修复该错误。您可以通过使用“修改提交”选项来执行此操作，该选项将分阶段更改附加到先前的提交。因此，您最终会得到一次提交，而不是两次不同的提交。在提交工具窗口中，选择包含要添加到先前提交的更改的修改文件。alt0选中“修改”复选框，使“提交”按钮更改为“修改提交”并单击它。3、修改任何先前的提交如果您需要向任何早期提交添加更改而不是单独提交它们，则可以使用fixup或squash操作来完成此操作。这两个命令都将分阶段更改附加到所选提交，但处理提交消息的方式不同：squash将新的提交消息添加到原始提交中fixup丢弃新的提交消息，仅保留原始提交的消息这两个命令都需要变[链接]，因为它们更改了提交哈希值。在提交工具窗口中，选择包含要附加到早期提交的更改的修改文件。alt0在git工具窗口的“日志”选项卡中，右键单击要使用本地更改进行修改的提交，然后从上下文菜单中选择“修复”或“压缩到”。alt9如果您选择压缩更改，请修改提交消息。单击commit按钮上的箭头并选择commit和rebase。4、壁球提交如果您需要合并与相同功能相关的任何两个提交，您可以将它们压缩为一个，以便更清晰的分支历史记录。在git工具窗口的“日志”选项卡中，选择要合并为一个的提交，然后从上下文菜单中选择“压缩提交”。alt9在打开的对话框中，编辑提交消息（默认情况下，它包含来自两次提交的消息），然后单击“确定”。将更改推送到远程分支。ctrlshiftk5、删除提交您可以放弃当前分支中推送的提交，而无需[链接]。在日志视图中选择要放弃的提交，然后从上下文菜单中选择“删除提交”。6、通过执行交互式变基来编辑项目历史记录通过intellijidea中的git集成，您可以通过执行交互式rebase来编辑项目历史记录，使其线性且有意义。[链接][链接]无关更改的提交等来清理提交历史记录。编辑当前分支的历史记录intellijidea允许您在将更改应用到不同分支之前编辑当前分支中的提交历史记录。打开git工具窗口并切换到“日志”选项卡。alt9过滤日志，使其仅显示当前分支的提交：[图片]选择要编辑的一系列提交中最旧的提交，右键单击它并选择interactivelyrebasefromhere。将显示“交互式变基”对话框，其中包含当前分支中在选定提交之后进行的所有提交的列表：[图片]如果“从此处交互式变基”选项被禁用，则可能是由于以下原因之一造成的：所选提交有多个父项所选提交不在当前分支中选定的提交被推送到[链接]要确定原因，请将鼠标悬停在上下文菜单中的操作上，然后在状态栏中查找消息：[图片]您可以对分支历史记录执行以下更改：更改应应用提交的顺序[图片]：使用和[图片]按钮在列表中上下移动提交。选择一个提交：这是所有提交的默认状态。如果您需要撤消已对提交执行的操作，请单击“选择”[图片]，以便按原样应用此提交。编辑：单击“停止”进行编辑[图片]，以便当您启动变基时，您可以在此提交处停止以便能够对其进行编辑。当变基在提交时停止时，intellijidea窗口的右下角会弹出一条通知，让您继续或中止变基：[图片]在继续变基之前，您可以使用上下文操作（例如revert、undo、amend等）修改此提交。如果您不执行任何操作，则此提交将按原样应用。如果您已关闭通知，请从主菜单中选择git|继续变基以恢复它。重写提交消息：单击重写或双击提交并在打开的迷你编辑器中编辑文本。将两个提交合并为一个：选择要合并到前一个提交中的提交，然后单击“squash”或“squash”按钮旁边的箭头，然后单击“fixup”。如果您单击squash，默认情况下，来自两个提交的消息将被合并，因此，如果您不修改生成的提交消息，此操作将反映在分支历史记录中。如果单击fixup，则修复提交的提交消息将被丢弃，因此此更改将在分支历史记录中不可见。在这两种情况下，您都可以在应用这些操作之一时打开的迷你编辑器中编辑提交消息。忽略提交：单击“删除”，以便不应用所选提交的更改。撤消所有更改：单击“重置”以放弃已应用于提交的所有操作。因此，“变基提交”对话框会显示一个图表，说明您应用于分支中提交的所有操作，以便您可以在开始变基之前查看它们：[图片]单击开始变基。编辑分支历史并将其集成到另一个分支intellijidea允许您在另一个分支之上对一个分支[链接]从主菜单中选择git|变基：[图片]单击修改选项并选择—interactive。从列表中，选择要将当前分支变基到的目标分支：[图片]如果您需要从特定提交开始对源分支进行变基，而不是对整个分支进行变基，请单击修改选项并选择—onto。在源分支字段中，输入要将当前分支应用到新基础的提交的哈希值：[图片][链接]要复制提交哈希，请在log中选择它，右键单击它并选择copyrevisionnumber。如果您要变基的分支当前未签出，请单击“修改选项”，单击“选择另一个要变基的分支”，然后从显示的列表中选择一个分支：[图片]intellijidea将在开始变基操作之前检查此分支。如果要对分支中可访问的所有提交进行变基，请单击修改选项并选择—root（有关此选项的更多信息，请参阅[链接]）。如果您需要保留空提交（即不会从其父级更改任何内容的提交），请单击修改选项并选择—keep-empty（有关此选项的更多信息，请参阅[链接]）。单击变基。将显示“交互式变基”对话框，其中包含当前分支中在选定提交之后进行的所有提交的列表。[图片]您可以对分支历史记录执行以下更改：更改应应用提交的顺序[图片]：使用和[图片]按钮在列表中上下移动提交。选择一个提交：这是所有提交的默认状态。如果您需要撤消已对提交执行的操作，请单击“选择”[图片]，以便按原样应用此提交。编辑：单击“停止”进行编辑[图片]，以便当您启动变基时，您可以在此提交处停止以便能够对其进行编辑。当变基在提交时停止时，intellijidea窗口的右下角会弹出一条通知，让您继续或中止变基：[图片]在继续变基之前，您可以使用上下文操作（例如revert、undo、amend等）修改此提交。如果您不执行任何操作，则此提交将按原样应用。如果您已关闭通知，请从主菜单中选择git|继续变基以恢复它。重写提交消息：单击重写或双击提交并在打开的迷你编辑器中编辑文本。将两个提交合并为一个：选择要合并到前一个提交中的提交，然后单击“squash”或“squash”按钮旁边的箭头，然后单击“fixup”。如果您单击squash，默认情况下，来自两个提交的消息将被合并，因此，如果您不修改生成的提交消息，此操作将反映在分支历史记录中。如果单击fixup，则修复提交的提交消息将被丢弃，因此此更改将在分支历史记录中不可见。在这两种情况下，您都可以在应用这些操作之一时打开的迷你编辑器中编辑提交消息。忽略提交：单击“删除”，以便不应用所选提交的更改。撤消所有更改：单击“重置”以放弃已应用于提交的所有操作。因此，“变基提交”对话框会显示一个图表，说明您应用于分支中提交的所有操作，以便您可以在开始变基之前查看它们：[图片]单击开始变基。]]></content>
        
        
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>IDEA 使用 Git 详解(二)</title>
        <link href="/posts/ae9ce5fc.html"/>
        <url>/posts/ae9ce5fc.html</url>
        <cover>https://boosterminiclass.com/wp-content/uploads/2023/07/intellij_idea_git_2.png</cover>
        <date>Wed Sep 25 2024 14:45:03 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片][链接]gitgit设置：设置|版本控制|git所需插件：git（默认捆绑并启用）[链接]为git远程设置密码每次与远程git存储库交互时（例如，在pull、update或push操作期间），都需要授权。你可以将intellijidea配置为记住你的密码。这样你就不必再每次需要授权时指定你的凭据了。配置密码策略在设置对话框中，选择外观和行为|系统设置|密码在左边。ctrlalts选择你希望intellijidea如何处理git远程存储仓库的密码：在本机钥匙串中：选择此项可使用本机钥匙串来存储你的密码。此设置仅适用于macos和linux。在keepass中：选择此选项可使用[链接]来存储您的密码。当您使用keepass密码管理器时，将使用主密码来访问存储个人密码的文件。一旦intellijidea记住您的密码，除非您需要访问密码数据库，否则它不会询问您的密码。在masterpassword字段中输入将用于访问c.kdbx文件的密码。您可以在“数据库”字段中更改c.kdbx文件的默认位置。要导入c.kdbx文件，请单击并从下拉菜单中[图片]选择“导入”[图片]，或者单击并指定包含密码的本地文件的路径。如果您想从数据库中删除现有密码，请选择“清除”。重新启动后不保存，忘记密码：如果您希望在关闭intellijidea后重置密码，请选择此选项。[链接]设置git存储库当您[链接]现有的git存储库或[链接]，intellijidea会自动检测您的计算机上是否安装了git。如果ide找不到git可执行文件，则建议下载它。intellijidea支持来自windowssubsystemforlinux2(wsl2)的git，该子系统在[链接]中提供。如果windows上未安装git，intellijidea会在wsl中搜索git并从那里使用它。此外，对于使用\\wsl$路径打开的项目，intellijidea会自动从wsl切换到git。如果您需要手动配置intellijidea以从wsl使用git，请转到版本控制|ide设置的git页面，单击git可执行文件路径字段中的浏览图标，然后通过路径选择gitfromwsl，例如。ctrlalts\wsl$\\wsl$\debian\usr\bin\git1、从远程主机检出项目（gitclone）intellijidea允许你签出（用git术语来说，克隆）现有存储库并根据你下载的数据创建新项目。要开始克隆git存储库，请执行以下操作之一：如果版本控制集成已启用，请转至git|克隆。如果尚未启用版本控制集成，请转至vcs|从版本控制获取。或者，转到文件|新|来自版本控制的项目。如果当前没有打开的项目，请单击“欢迎”屏幕上的“从vcs获取”。在“从版本控制获取”对话框中，指定要克隆的远程存储库的url，或选择左侧的vcs托管服务之一。如果您已经登录到所选的托管服务，完成后将建议您可以克隆的可用存储库列表。[图片]单击“克隆”。如果要基于已克隆的源创建项目，请在确认对话框中单击“是”。git根映射将自动设置为项目根目录。如果您的项目包含[链接]，它们也将被克隆并自动注册为项目根。在信任和开放项目“”中？[链接]，选择您想要打开项目的方式：信任项目或在安全模式下预览。当您第一次导入或克隆项目时，intellijidea会对其进行分析。如果ide检测到多个配置（例如eclipse和gradle），它会提示您选择要使用的配置。如果您要导入的项目使用构建工具，例如[链接]或[链接]，我们建议您选择构建工具配置。选择必要的配置并单击“确定”。[图片]ide根据您的选择预先配置项目。例如，如果您选择gradle，intellijidea将执行其构建脚本、加载依赖项等。2、将现有项目置于git版本控制之下①、将整个项目与单个git存储库关联打开您想要放入git下的项目。按打开vcs操作弹出窗口并选择启用版本控制集成。alt~或者，转到vcs|启用版本控制集成。选择git作为版本控制系统，然后单击“确定”。然后，整个项目将与单个git目录关联，因此无需将每个文件单独添加到git目录。启用vcs集成后，intellijidea会询问您是否要通过vcs共享项目设置文件。您可以选择始终添加以与使用intellijidea的其他存储库用户同步项目设置。[图片]如果vcsoperations弹出窗口中没有可用的“启用版本控制集成”选项，则表示已为该项目启用了git版本控制。②、将项目内的不同目录与不同的git存储库关联打开您想要放入git下的项目。前往vcs|创建git存储库。在打开的对话框中，指定将在其中创建新git存储库的目录。git不支持外部路径，因此如果您选择项目根目录之外的目录，请确保要创建存储库的文件夹也包含项目根目录。如果您要在项目结构内创建多个git存储库，请对每个目录重复前面的步骤。为项目[链接]后，您需要将项目文件添加到存储库。3、添加文件到本地存储库在“提交”工具窗口中，展开“未版本化文件”节点。alt0选择要添加到git或整个更改列表的文件，然后按或从上下文菜单中选择“添加到vcs”。ctrlalta您还可以从“项目”工具窗口将文件添加到本地git存储库：选择要添加的文件，然后按或选择“git|git”。从上下文菜单添加。ctrlalta在项目中启用git集成时，intellijidea建议在git下添加每个新创建的文件，即使它是从intellijidea外部添加的。您可以在版本控制|中更改此行为。ide设置的确认页面。如果您希望某些文件始终保持未版本化，则可以[链接]。ctrlalts如果您尝试添加.gitignore列表中的文件，intellijidea将建议强制添加它。在确认对话框中单击“取消”只会取消强制添加忽略的文件-所有其他文件都将添加到git存储库。4、从版本控制中排除文件（忽略）有时您可能需要保留某些文件未版本化。这些可以是vcs管理文件、实用程序工件、备份副本等。您可以通过intellijidea忽略文件，ide不会建议将它们添加到git并将它们突出显示为忽略。您只能忽略未版本化的文件，即您在未版本化文件更改列表中看到的文件。如果文件已[链接]但未[链接]“更改”视图中右键单击该文件并选择“回滚”。git允许您在两种配置文件中列出忽略的文件模式：.git/info/排除文件。此文件中列出的模式仅适用于存储库的本地副本。当您初始化或签出git存储库时，会自动创建此文件。vcs根目录及其子目录中的一个或多个.gitignore文件。这些文件被签入存储库，以便整个团队都可以使用其中的忽略模式。因此，它是存储被忽略的文件模式的最常见位置。如果vcs根目录下没有.gitignore文件，可以在project工具窗口任意位置右键，选择new|文件，然后在“新建文件”对话框中键入.gitignore。要在windows资源管理器中创建.gitignore文件，请创建一个名为.gitignore的文件。windows会自动将其重命名为.gitignore。5、将文件添加到.gitignore或.git/info/exclude决定要使用哪种[链接]如果有疑问，请使用.gitignore。在“更改”视图或“项目”工具窗口中找到要忽略的未版本控制的文件或文件夹。[链接]可帮助您识别文件的状态。右键单击所选内容并选择git|添加到.gitignore或git|添加到.git/info/exclude。[链接]可帮助您识别文件的状态。如果需要按某种模式或类型排除文件，可以直接编辑.gitignore或文件。.git/info/exclude请参阅[链接]。如果您希望[链接]也显示在“更改”视图中，请单击[图片]工具栏上的并选择“显示忽略的文件”。6、添加远程存储库如果您基于本地源[链接]，则需要添加远程存储库以便能够在git项目上进行协作，并消除在本地存储整个代码库的风险。当您需要共享您的工作并从中提取数据以将其他贡献者所做的更改集成到本地存储库版本时，您可以将更改推送到[链接]存储[链接]。如果您已[链接]（例如，从[链接]），则远程会自动配置，并且当您想要与其[链接]时不必指定它。git为您克隆的远程服务器提供的默认名称是origin。有关共享不同项目格式的项目设置的更多信息，请参阅[链接]。7、定义一个远程在任何git托管上创建一个空存储库，例如[链接]或[链接]。您可以在github上创建存储库，而无需离开intellijidea：请参阅[链接]。当您准备好通过选择git|推送提交时，调用“推送”对话框从主菜单按下，或按。ctrlshiftk如果您到目前为止尚未添加任何遥控器，则会显示“定义远程”链接而不是遥控器名称。单击它以添加遥控器。在打开的对话框中，指定远程名称和托管它的url，然后单击“确定”。8、添加第二个遥控器在某些情况下，您还需要添加第二个远程存储库。例如，如果您克隆了一个没有写访问权限的存储库，并且要将更改推送到您自己的原始项目[链接]另一个常见的情况是，您克隆了自己的存储库，这是其他人的项目分支，您需要与原始项目同步并从中获取更改。转到git|管理遥控器。git远程对话框将打开。单击工具栏上的“添加”按钮或按。[图片]altinsert在打开的对话框中，指定远程名称和url，然后单击“确定”。要编辑远程（例如，更改已克隆的原始项目的名称），请右键单击[链接]中的远程分支，然后从上下文菜单中选择“编辑远程”。您还可以通过单击遥控器的名称，从[链接]中编辑遥控器。要删除不再有效的存储库，请在[链接]中右键单击它，然后从上下文菜单中选择“删除远程”。[链接]将文件添加到git并跟踪更改1、将文件添加到git打开提交工具窗口。alt0通过按或从上下文菜单中选择“添加到vcs”，将“无版本控制文件”更改列表中的任何文件置于版本控制之下。您可以添加整个更改列表或选择单独的文件。ctrlalta如果您已为项目启用git集成，intellijidea建议将每个新创建的文件添加到版本控制下。您可以在“版本控制”|“设置”对话框中更改此行为。确认。如果您希望某些文件始终保持未版本化，您可以将git配置为忽略它们。ctrlalts您还可以从项目工具窗口将文件添加到本地存储库。选择要添加的文件，然后按或选择git|从上下文菜单添加。ctrlalta2、检查项目文件状态ntellijidea允许您检查本地工作副本与项目的存储库版本相比的状态。它可以让您查看哪些文件已被修改、哪些新文件已添加到git以及哪些文件未被git跟踪。打开提交工具窗口。alt0[图片]更改更改列表显示自上次与远程存储库同步以来已修改的所有文件（以蓝色突出显示），以及已添加到git但尚未提交的所有新文件（以绿色突出显示）。unversionedfiles更改列表显示已添加到项目中但git未跟踪的所有文件。如果您希望忽略的文件也显示在“更改”视图中，请单击[图片]工具栏上的并选择“显示忽略的文件”。3、在编辑器中跟踪文件的更改您还可以在编辑器中修改文件时跟踪文件的更改。所有更改均通过更改标记突出显示，这些标记出现在已修改行旁边的装订线中，并显示自上次[链接]以来引入的更改类型。当您将更改提交到存储库时，更改标记就会消失。您对文本所做的更改是用颜色编码的：[图片]已添加行。[图片]线路改变了。[图片]行已删除。您可以在编辑器|上自定义线路状态的默认颜色。配色方案|ide设置的vcs页面。ctrlalts要禁用装订线中的vcs标记，请取消选择“版本控制”|“装订线”中的“突出显示装订线中已修改的行”选项。ide设置的确认页面。ctrlalts您可以使用将鼠标悬停在更改标记上然后单击它时出现的工具栏来管理更改。工具栏与一个框架一起显示，该框架显示修改行的先前内容：[图片]您可以通过单击回滚更改[图片]，并通过单击探索当前行的当前版本和存储库版本之间的差异[图片]。要突出显示已更改的片段，请单击[图片]。您可以复制此弹出窗口内容的任何部分并将其粘贴到编辑器中，而不是恢复整个文件。4、从存储库中删除文件如果您删除受版本控制的文件，它仍然存在于存储库中，直到您提交更改为止。已删除的文件将放置在活动更改列表中并以灰色突出显示。在“项目”工具窗口中选择一个文件，然后按或从上下文菜单中选择“删除”。delete在打开的对话框中，您可以选择是要删除该文件而不搜索用途，还是通过选中“安全删除”选项来执行安全删除（以确保删除未使用的文件）。如果发现任何用法，将弹出“检测到用法”对话框，列出它们。您可以在删除该文件之前查看这些用法并删除对此文件的引用。将更改提交到存储库。[链接]与远程git存储库同步（获取、拉取、更新）[链接]共享工作结果之前，您需要与远程存储库同步以确保项目的本地副本是最新的。您可以通过以下方式之一执行此操作：[链接]、[链接]或[链接]。git分支弹出窗口指示分支是否有尚未获取的传入提交：[图片]1、获取更改当您从上游获取更改时，自上次与远程存储库同步以来提交的所有新数据都会下载到本地副本中。这些新数据不会集成到您的本地文件中，并且更改不会应用于您的代码。获取的更改存储为远程分支，这使您有机会在将它们与文件[链接]由于fetch不会影响你本地的开发环境。这是获取远程存储库所有更改更新的安全方法。有两种方法可以从上游获取更改：选择git|在主菜单中获取。或者，打开“分支”弹出窗口并单击[图片]右上角。[图片][链接]可更好地了解ide中如何执行获取操作。2、更新分支如果您需要将特定分支与其远程跟踪分支同步，请使用更新。[链接]并随后将更改应用到所选分支的便捷快捷方式。在“分支”弹出窗口或版本控制工具窗口的“分支”窗格中，选择一个分支并从上下文菜单中选择“更新”。intellijidea将从远程分支中[链接]更改，并将它们[链接]或[链接]到本地分支，具体取决于在设置|中选择的更新方法。版本控制|吉特.3、拉动变更如果您需要从另一个分支而不是其远程跟踪分支获取对当前分支的更改，请使用pull。当您拉取时，您不仅下载新数据，还将其集成到项目的本地工作副本中。转到git|拉。“拉取更改”对话框打开：[图片]如果您有一个多存储库项目，则会出现一个附加下拉列表，供您选择存储库。如果您为项目定义了多个遥控器，请从列表中选择一个遥控器（默认情况下为origin）。选择要将更改拉取到当前签出的分支的分支。默认情况下，选择当前本地分支跟踪的远程分支。如果您指定不同的分支，intellijidea将记住您的选择并在将来默认显示该分支。如果您需要使用选项拉取，请单击“修改选项”并从以下选项中进行选择：--rebase：从远程分支[链接]更改后，intellijidea会将本地未推送的更改[链接]为已获取的更改。--ff-only：只有可以快进时，合并才会被解决。--no-ff：在所有情况下都会创建合并提交，即使可以将合并解析为快进。--squash：将在当前分支之上创建包含所有拉取更改的单个提交。--no-commit：将执行合并，但不会创建合并提交，以便您可以在提交之前检查合并的结果。有关pull选项的更多信息，请参阅[链接]单击“拉动”。4、更新您的项目如果您有多个项目根目录，或者希望每次与远程存储库同步时从所有分支获取更改，您可能会发现更新项目是更方便的选择。当您执行更新操作时，intellijidea会从所有项目根和分支中[链接]更改，并将跟踪的远程分支[链接]到本地工作副本中（相当于pull）。如果您的项目包含[链接]，并且它们位于分支上，它们也会自动更新。如果子模块处于分离的head状态，intellijidea将调用gitsubmoduleupdate，这将检查根存储库中引用的提交。这意味着仅当根存储库中的子模块引用发生更改或添加新的子模块时才会执行更新。前往vcs|更新项目或按。“更新项目”对话框打开。ctrlt选择更新类型（此策略将应用于git版本控制下的所有根）：将传入的更改合并到当前分支：选择此选项可在更新期间执行[链接]这相当于运行gitfetch然后gitmerge,或gitpull--no-rebase。在传入更改之上对当前分支进行变基：选择此选项可在更新期间执行[链接]这相当于运行gitfetch然后gitrebase，或者gitpull--rebase（所有本地提交都将放在更新的上游头之上）。如果您选择以后不显示“更新项目”对话框，然后想要稍后修改默认更新策略，请转到“版本控制”|“更新项目”对话框。ide设置的确认页面，在调用这些命令时显示选项对话框下选择更新，并在下次执行更新时修改更新策略。ctrlalt0s更新操作完成后，git工具窗口中将添加[链接]选项卡。[链接]中相同的方式查看更改。alt9如果您想查看自上次更新以来修改的所有文件的完整列表，请将插入符号放在提交列表中的任意位置，然后按。您可以禁用分组以查看平面列表：单击“更改的文件”窗格中的工具栏。ctrla[图片][链接]提交更改并将其推送到git存储库配置提交选项：设置|版本控制|犯罪提交工具窗口alt0犯罪ctrlk提交和推送ctrlaltk推ctrlshiftk将[链接]，或修改已在git版本控制下的文件，并且您对它们的当前状态感到满意后，您可以共享您的工作结果。这涉及到在本地[链接]它们以将存储库的快照记录到项目历史记录中，然后将它们[链接]送到远程存储库以便其他人可以使用它们。1、设置您的git用户名git需要知道您的用户名才能将提交与身份关联起来。如果您尚未设置用户名，intellijidea将在您首次尝试提交更改时提示您指定用户名。打开[链接]并执行以下命令之一：要为计算机上的每个git存储库设置名称，请使用$gitconfig--globaluser.name&quot;johnsmith&quot;要为单个存储库设置名称，请使用$gitconfiguser.name&quot;johnsmith&quot;2、在本地提交更改打开位于左侧的垂直提交工具窗口：alt0[图片]当您的更改准备好提交时，选择相应的文件或整个更改列表。如果按，将选择整个活动更改列表。ctrlk您还可以选择unversionedfiles节点下的文件-intellijidea将一步暂存并提交这些文件。如果要将[链接]而不是创建单独的提交，请选择“修改”选项。输入提交消息。您可以单击[图片]以从最近提交消息的列表中进行选择。您还可以稍后在推送提交之前[链接]您可以在版本控制|上自定义提交消息规则。ide设置的提交页面。还有一个快速修复和重新格式化操作，可以换行长行或重新格式化消息。ctrlalt0s您还可以定义将用作默认提交消息的提交模板。指定要在.txt文件中使用的样板文本，并在终端中执行以下命令将其添加到git配置中：gitconfig--localcommit.template&lt;path_to_template_file&gt;如果您需要执行提交检查、提交后将文件上传到服务器或使用高级选项提交，请单击[图片]右下角的：[图片]可以使用以下选项：作者：如果您要提交其他人所做的更改，您可以指定这些更改的作者。签署提交：选择是否要签署提交以证明您要签入的更改是由您做出的，或者您对所提交的代码负责。启用此选项后，将以下行自动添加到提交消息的末尾：签署人：&lt;用户名&gt;在提交检查区域中，选择您希望intellijidea在将所选文件提交到本地存储库时执行的操作。可以使用以下选项：重新格式化代码：根据[链接]设置执行代码格式化。重新排列代码：根据[链接]重新排列您的代码。优化导入：删除多余的导入语句。分析代码：在提交修改的文件时分析它们。单击选择配置文件以选择ide将运行检查的检查[链接]检查todo(&lt;过滤器名称&gt;)：查看与指定过滤器匹配的[链接]单击“配置”以选择[链接]，或打开[链接]并定义要应用的新过滤器。清理：批量应用代码清理检查中的快速修复。单击选择配置文件以选择ide将运行检查的[链接]运行测试：[链接]。单击运行测试附近的选择配置，然后选择要运行的配置。更新版权：根据所选的版权配置文件-范围组合添加或更新版权声明。在“提交后”区域中，您可以选择用于将提交的文件上传到本地或远程主机、已安装的磁盘或目录的[链接]访问配置或[链接]有关更多信息，请参阅[链接]。可以使用以下选项：运行工具：选择您希望intellijidea在提交所选更改后启动的[链接]您可以从列表中选择一个工具，或者单击“浏览”按钮并在打开的[链接][图片]对话框中配置外部工具。将文件上传到：选择[链接]或[链接]，用于将提交的文件上传到本地或远程主机、已安装的磁盘或目录。要禁止上传，请选择none。要将服务器配置添加到列表中，请单击[图片]并填写打开的“添加服务器”对话框中的必填字段。仅当启用ftp/sftp/webdav连接插件时，该列表才可用。始终使用选定的服务器或服务器组：始终将文件上传到选定的[链接]或[链接]。仅当启用ftp/sftp/webdav连接插件时，该复选框才可用。准备就绪后，单击“提交”或“提交并推送”()在提交后立即将更改推送到远程存储库。您将能够在将当前提交以及所有其他提交推送到远程之前查看它们。ctrlaltk3、提交文件的一部分有时，当您进行与特定任务相关的更改时，您还会应用影响同一文件的其他不相关的代码修改。[链接]、[链接]它们等会更加困难。intellijidea允许您通过以下方式之一单独提交此类更改：在“提交更改”对话框中选择要包含在提交中的修改后的[链接]，并将其他更改保留为待处理状态，以便稍后可以提交它们。当您编辑代码时，将不同的代码块即时[链接]您还可以创建一个新的更改列表并[链接]，然后您之后所做的所有更改都将落入该更改列表中，而您之前所做的任何修改都将保留在原处。4、选择要提交的块和特定行打开提交工具窗口。alt0要显示所选文件的存储库版本和本地版本之间的差异，请在提交工具窗口中单击工具栏上的或按。alt0[图片]ctrld选中要提交的每个已修改或新添加的代码块旁边的复选框，并保留其他更改未选中：[图片]您还可以从已修改块的上下文菜单中选择移动到另一个更改列表，以在可以单独提交的不同更改列表之间拆分更改。要为此操作分配自定义快捷方式，请在ide设置的“键盘映射”页面上的“版本控制系统”下查找“将行移至另一个更改列表”操作。ctrlalts如果您只想提交块中的特定行，请右键单击要包含的行，然后选择“拆分块”和“将所选行包含到提交中”。[图片]或者，将鼠标悬停在装订线上，然后选择或清除要包含在提交中或从中排除的行旁边的复选框。单击“提交”。未选定的更改将保留在当前更改列表中，以便您可以单独提交它们。5、将更改放入不同的更改列表中当您在编辑器中对文件进行更改时，请单击装订线中相应的[链接]如果装订线中没有更改标记，请确保在编辑器|装订线中启用突出显示装订线中修改的行选项。ide设置的常规页面。ctrlalts在出现的工具栏中，选择已修改代码块的目标变更列表（或创建新的变更列表）：[图片]单独提交每个变更列表。6、使用git暂存区提交更改[链接]更改的暂存概念，而不是使用自动暂存修改文件的[链接]，请按打开ide设置并选择版本控制|git，然后选择启用暂存区域复选框。ctrlalts提交工具窗口现在如下所示：[图片]使用暂存区域可以让您轻松地分别提交对同一文件的更改（包括重叠更改），并查看哪些更改已经暂存，而无需从编辑器切换焦点。当您从使用更改列表切换到git暂存区域时，所有现有更改列表都会保存。您可以在两种模式之间切换，而不会丢失所做的更改。7、提交的阶段更改执行以下操作之一：要暂存整个文件，请在“提交”工具窗口中选择该文件并单击其右侧的或按。alt0[图片]ctrlalta[图片]要暂存文件中的特定块，请在编辑器中单击已修改块旁边的装订线中的[链接]暂存。[图片]暂存的更改（包括从intellijidea外部暂存的更改）在编辑器中用边框形状的更改标记进行标记：[图片]要暂存粒度更改，例如单行而不是代码块，甚至是对单行的多个更改之一，请在“提交”工具窗口中，选择包含更改的文件，然后从上下文菜单中选择“比较head”、“暂存版本”和“本地版本”。alt0这将打开一个三向[链接]，其中左窗格显示存储库版本，右窗格显示本地版本，中央窗格是一个功能齐全的编辑器，您可以在其中进行想要暂存的更改。[图片][链接]中所述提交更改。8、将更改推送到远程存储库在推送更改之前，[链接]并确保存储库的本地副本是最新的以避免冲突。intellijidea允许您将更改从任何分支上传到其[链接]或任何其他远程分支。执行以下操作之一：要从当前分支推送更改，请按或选择git|从主菜单推送。ctrlshift0k要从任何具有远程分支的本地分支推送更改，请在“分支”弹出窗口中选择该分支，然后从操作列表中选择“推送”。“推送提交”对话框将打开，显示所有git存储库（对于多存储库项目）并列出自上次推送以来在每个存储库的当前分支中进行的所有提交。如果您的项目使用多个非同步控制的存储库，则默认情况下仅选择当前存储库（有关启用同步存储库控制的更多信息，请参阅[链接]）。您可以按所选提交来显示额外信息，例如提交作者、时间、哈希值和提交消息。ctrl0q如果存储库中没有遥控器，则会显示“定义远程”链接。单击此链接并在打开的对话框中指定远程名称和url。它将被保存，您可以稍后通过git进行编辑|管理远程（有关更多信息，请参阅[链接]）。如果你想修改要推送的目标分支，可以点击分支名称。该标签会变成一个文本字段，您可以在其中键入现有分支名称或创建新分支。您还可以单击右下角的编辑所有目标链接来同时编辑所有分支名称。请注意，您无法更改本地分支：将推送每个选定存储库的当前分支。您还可以通过按所选元素的或切换到编辑模式。enterf2如果您已经进行了一些提交但还不想推送到远程分支，请在git工具窗口的“日志”选项卡中选择要推送的最后一个提交，然后从列表中选择“将所有内容推送到此处…”选项行动。“推送提交”对话框将打开，显示直到所选提交哈希的所有提交。如果您想在推送更改之前预览更改，请选择所需的提交。右侧窗格显示所选提交中包含的更改。您可以使用工具栏按钮检查提交详细信息。如果提交的作者与当前用户不同，则该提交将标有星号。[链接]如果您选择整个存储库，所有提交的所有文件将在右窗格中列出。如果在多次提交中修改了同一文件，则当您选择这些提交或整个存储库时，该文件只会列出一次，并且如果您为此文件调用[链接]准备好后单击“推送”按钮，然后从下拉菜单中选择要执行的操作：“推送”或“强制推送”（相当于push--force-with-lease）。仅当当前分支未在受保护的分支字段中列出时（请参阅[链接]），这些选择选项才可用，否则，您只能执行该push操作。9、如果推送被拒绝，请更新您的工作副本如果由于工作副本已过时而拒绝推送，intellijidea将显示“推送被拒绝”对话框，前提是未选择“设置”对话框的[链接]页面中的“如果当前分支的推送被拒绝则自动更新”选项。请执行下列操作：如果您的项目使用多个git存储库，请指定要更新其中的哪个。如果您想要更新所有存储库，无论推送是否被拒绝，请选择更新所有存储库选项。如果清除此选项，则仅更新受影响的存储库。如果您希望intellijidea在下次使用您在此对话框中选择的更新方法拒绝推送时静默应用更新过程，请选择记住更新方法选择并在将来静默更新选项。离开此对话框后，“设置”对话框的[链接]页面中的“如果当前分支的推送被拒绝，则自动更新”复选框将被选中，并且应用的更新方法将成为默认方法。要更改更新策略，请取消选择此选项以在下次当前分支的推送被拒绝时调用“推送被拒绝”对话框，应用不同的更新过程，然后再次选择“记住更新方法选择”选项。通过分别单击[链接]或“合并”按钮来选择更新方法（“变基”或“[链接]10、什么时候需要使用强制推送？当您运行push时，如果远程存储库中有您丢失的更改并且您将用存储库的本地副本覆盖，git将拒绝完成操作。通常，您需要执行[链接]以与远程同步，然后再使用更改进行更新。该--forcepush命令禁用此检查并允许您覆盖远程存储库，从而擦除其历史记录并导致数据丢失。在幕后，当您选择强制推送时，intellijidea会执行该push--force-with-lease操作，这是一个更安全的选项，可帮助您确保不会覆盖其他人的提交（有关推送选项的更多详细信息，请参阅[链接]您可能仍需要执行的一种可能情况--forcepush是，您对推送的分支进行变基，然后想要将其推送到远程服务器。在这种情况下，当您尝试推送时，git将拒绝您的更改，因为远程引用不是本地引用的祖先。如果您在这种情况下执行拉取，您最终将得到分支的两个副本，然后需要合并它们。[链接]比较文件和文件夹版本intellijidea允许您检查文件/文件夹的两个修订版之间或其当前本地副本与存储库版本之间的差异。差异显示在差异查看器中。有关在差异查看器中过滤、导航和应用更改的更多信息，请参阅[链接]。1、将修改后的文件与其git存储库版本进行比较打开提交工具窗口。alt00在更改列表中找到所需的文件并执行以下操作之一：右键单击该文件并选择git|显示差异。选择文件并按。ctrl0d双击该文件。将打开差异视图，其中突出显示对文件的更改。右窗格包含文件的修改版本。您可以在差异视图中对其进行编辑。左窗格包含文件的初始版本。它是只读的。您可以单击[图片](恢复)来撤消更改。2、将文件或文件夹的当前版本与同一git分支中的版本进行比较在“项目”工具窗口中选择一个文件或文件夹，然后选择“git|git”。从上下文菜单中与修订版进行比较。从打开的对话框中选择要与当前文件或文件夹版本进行比较的修订版本。3、将文件或文件夹的当前版本与另一个git分支进行比较在“项目”工具窗口中选择一个文件或文件夹，然后选择“git|git”。从上下文菜单中与分支进行比较。从打开的对话框中选择要与当前文件或文件夹版本进行比较的分支。[链接]调查git存储库中的更改在intellijidea中，您可以追溯项目中的所有更改&gt;。这可以帮助您[链接][链接]或提交之间的差异，并在必要时[链接]更改。1、回顾项目历史您可以查看对与指定过滤器匹配的项目源所做的所有更改。要查看项目历史记录，请打开git工具窗口的“日志”选项卡。它显示了提交给所有分支和远程存储库的所有更改alt9：[图片]在多存储库项目中，左侧的彩色条纹指示所选提交属于哪个根（每个根都标有自己的颜色）。将鼠标悬停在彩色条纹上可调用显示根路径的提示：[图片]2、浏览和搜索项目历史记录通过输入完整的提交名称或消息或其片段、修订号或正则表达式来搜索提交列表。按分支或最喜欢的分支、用户、日期和文件夹（或多根项目的根和文件夹）过滤提交。单击工具栏上的“转到哈希/分支/标签”图标，或按并指定提交哈希、[链接]或要跳转到的分支的名称（您将被带到该分支中的最新提交）。[图片]ctrlf单击箭头跳转到长分支中的下一个提交：[图片]按和键跳转到父/子提交。如果您在git工具窗口的“日志”选项卡中混合了对不同存储库和多个分支的提交，这尤其有用。←→alt9按将焦点切换到搜索字段。ctrl0l为了避免来回设置过滤器，请单击[图片]工具栏上的来打开与您的过滤器匹配的新选项卡。要自定义日期格式，请转至设置|外观和行为|系统设置|日期格式。有关git工具窗口的“日志”选项卡的更多信息，请参阅[链接]。alt93、查看特定修订版的项目快照intellijidea允许您在选定的修订版本中查看项目的状态。打开git工具窗口并切换到“日志”选项卡。alt9选择一个提交，然后从上下文菜单中选择“显示修订版本的存储库”。将打开“存储库”工具窗口，其中包含所选版本的项目快照。4、查看两次提交之间的差异intellijidea允许您检查两次提交之间修改了哪些文件，而不必浏览两次提交之间的更改。在git工具窗口的“日志”选项卡中选择任意两个提交，然后从上下文菜单中选择“比较版本”。alt9将打开“更改”工具窗口，其中包含所选提交之间修改的文件列表。[图片]您可以通过单击或按来查看任何文件的差异。ctrld5、查看文件历史记录您可以查看对特定文件所做的所有更改，并查找每个版本中具体修改的内容。在任何视图（项目工具窗口、编辑器、更改视图等）中选择必要的文件。选择git|从vcs主菜单或选择的上下文菜单显示历史记录。“历史记录”选项卡已添加到git工具窗口，显示所选文件的历史记录，并允许您查看和比较其修订版本。要确定特定修订版中引入了哪些更改，请在列表中选择它。在面板的右侧立即显示差异。要在专用差异查看器中查看整个文件的差异，请在列表中选择它，然后按或单击工具栏上的按钮。[链接]将打开，显示此版本中的更改。ctrld[图片]6、查看本地和提交的文件版本之间的差异您可以检查提交的文件修订与其本地版本有何不同：打开git工具窗口并切换到“日志”选项卡。alt9选择您感兴趣的提交，然后在右侧窗格中选择文件。单击[图片]工具栏上的按钮。7、查看更改的合并方式intellijidea允许您查看如何将更改[链接]，以及在合并期间如何[链接]在git工具窗口的“日志”选项卡中，选择您感兴趣的合并提交。alt9如果在合并过程中未检测到并解决任何冲突，intellijidea将在“更改的文件”窗格中显示相应的消息，并建议检查源自父级的更改：[图片]从节点之一选择所需的文件，然后单击工具栏上的“显示差异”图标或按。[链接]将显示两个面板的差异，允许您将当前版本与选定的父版本进行比较。[图片]ctrld如果合并期间发生冲突，“更改的文件”窗格将显示合并有冲突的文件列表。选择所需的文件，然后单击工具栏上的“显示差异”图标或按。[链接]将显示一个三面板差异，允许您将当前版本与其每个父版本进行比较，并查看冲突是如何解决的。[图片]ctrld8、找到代码作者（使用gitblame进行注释）您可以使用vcs注释（对应于[链接]）找出谁对文件引入了哪些更改。带注释的视图显示了每行代码的详细信息：[图片]当前版本中修改的行的注释用粗体和星号标记。默认情况下，不同的提交以不同的颜色突出显示（请参阅[链接]）。从注释视图，您可以跳转到：git工具窗口的“日志”选项卡中的相应提交：单击注释或将鼠标悬停在其上，然后单击弹出窗口中包含详细信息的提交哈希。alt9[图片]行的差异：将鼠标悬停在注释上。ide将突出显示该行以及相应提交的更改。[图片][链接]上的相应提交：使用openongithub上下文菜单选项。如果启用了[链接]，则错误跟踪系统中的相关问题：将鼠标悬停在注释上，然后单击问题链接（如果提交消息中包含该链接）启用注释右键单击编辑器或[链接]中的装订线，然后从上下文菜单中选择使用gitblame进行注释。您可以为“注释”命令分配自定义快捷方式：转到ide设置的“键盘映射”页面，然后查找“版本控制系统”|“版本控制系统”。git|git注释。ctrlalt0s要关闭注释，请右键单击编辑器或[链接]中的装订线，然后从上下文菜单中选择“关闭注释”。配置注释中显示的信息量您可以选择要在注释视图中查看的信息量。右键单击注释装订线，选择“查看”并选择要查看的信息类型，包括此更改源自的修订版、日期、不同格式的作者姓名以及提交号。您还可以在“颜色”下设置突出显示。配置注释选项右键单击注释装订线并从上下文菜单中选择选项：忽略空格：空格将被忽略（gitblame-w）。这意味着注释将指向先前有意义的提交。检测文件内的移动：当提交在同一文件中移动或复制行时，此类更改将被忽略（gitblame-m）。这意味着注释将指向先前有意义的提交。检测跨文件的移动：当提交移动或复制在同一提交中修改的其他文件中的行时，此类更改将被忽略（gitblame-c）。这意味着注释将指向先前有意义的提交。显示提交时间戳：如果您希望intellijidea在注释视图中显示提交时间戳而不是创作更改的时间，请选择此选项。自定义日期格式按打开ide设置，然后选择外观和行为|系统设置|日期格式。ctrlalts单击“vcs注释”旁边的“日期时间模式”字段，并指定要用于vcs注释的日期格式。请参阅[链接]。在编辑器中显示更改的作者[链接]中显示对元素（方法或类）的最后更改的作者。要打开它们：按打开ide设置，然后选择编辑器|镶嵌提示|代码愿景。ctrlalt0s选择代码作者选项。选择显示作者姓名的位置：在线顶部（默认）[图片]在右侧[图片]启用此选项后，您可以单击编辑器中的作者姓名提示来打开带注释的视图。隐藏更改的作者要在编辑器中隐藏代码作者的姓名，请执行以下操作之一：打开编辑器|镶嵌提示|ide设置的“代码视觉”页面并禁用“代码作者”选项。ctrlalt0s右键单击编辑器中的作者姓名提示，然后选择hidecodevision:codeauthorinlayhints。9、注释以前的修订intellijidea不仅允许您注释当前文件修订版本，还可以注释其先前的修订版本。注释装订线的上下文菜单提供以下选项：注释修订：如果您想检查提交特定更改后文件的外观，此选项非常有用。注释以前的修订：如果您发现自己处于特定行中的最后更改毫无意义的情况（例如，如果所有更改都是代码格式），则此选项很有用。在这种情况下，您可以检查该文件的先前版本是什么样子。隐藏修订：此选项有助于避免看到不相关或管理更改。这些通常是由低级迁移或格式化操作引入的。当这些更改影响整个根时，它们会在“注释”对话框中造成混乱，因此可能需要从视图和“注释”列中排除更改。“隐藏修订”操作允许您从注释结果中就地排除修订，并在编辑器和装订线中显示结果。可以使用相反的操作“恢复隐藏修订”来恢复排除的修订。有关隐藏修订的信息显示在编辑器顶部的通知面板中。还可以通过单击通知面板中的相应链接来恢复隐藏的修订。您还可以从“历史记录”视图中注释特定文件。在“历史记录”选项卡中，选择要查看的文件版本，右键单击相应行并从上下文菜单中选择“注释”。]]></content>
        
        
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>IDEA 使用 Git 详解(一)</title>
        <link href="/posts/7f7493d0.html"/>
        <url>/posts/7f7493d0.html</url>
        <cover>https://boosterminiclass.com/wp-content/uploads/2023/07/intellij_idea_git_2.png</cover>
        <date>Wed Sep 25 2024 14:45:02 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片][链接]版本控制使用vsc操作弹出窗口或vsc|vsc操作弹出窗口可快速调用任何vsc相关命令。alt~弹出窗口中的操作列表取决于当前启用的vsc。[图片]vsc操作弹出命令列表是可配置的-你可以在外观和行为|上添加或删除它们。ide设置的菜单和工具栏页面。ctrlalts你还可以使用以下快捷键方式调用全局版本控制命令：vcs操作弹出窗口…alt~[链接]ctrlk[链接]ctrlt[链接]ctrlaltz[链接]ctrlshiftk[链接]ctrlaltshift↓[链接]ctrlaltshift↑显示版本控制窗口alt9[链接]alt0[链接]启用版本控制intellijidea支持两个级别的版本控制集成：在ide级别，vsc集成是通过一组默认启用的捆绑插件提供的。在项目级别，通过将项目文件夹与一个或多个版本控制系统关联来启用vsc集成。[链接]将项目根与版本控制系统关联intellijidea允许快速启用项目与版本控制系统的集成，并将其与项目根相关联。有关将单独的项目目录与不同版本控制系统关联的更多关系，请参阅[链接]。按打开vsc操作弹出窗口并选择启用版本控制集成。alt~在打开的启用版本控制集成对话框中，要选择要与项目根关联的版本控制系统。启用vsc集成后，intellijidea会询问你是否要通过vsc共享项目设置文件。你可以选择始终添加以与使用intellijidea的其他存储用户同步项目设置。[图片]请注意，这仅适用于git和mercurial。[链接]将目录与版本控制系统关联intellijidea支持基于目录的版本控制模型，这意味着每个项目目录都可以与不同的版本控制系统关联。按打开ide设置，然后选择版本控制|目录映射。ctrlalts目录映射页面显示项目目录和与其关联的版本控制系统的列表（如果未添加目录，则该列表仅包含项目根目录）。单机右侧的添加按钮。+在打开的添加vsc目录映射对话框中，选择目录选项。输入要与版本控制系统关联的目录的路径，或者单机浏览按钮📂并在打开的对话框中选择目录。从vsc列表中，选择将用于控制此目录中的文件的版本控制系统。请注意，此列表仅包含当前启用相应插件的版本控制系统。单机确定保存映射并返回目录映射页面。管理未注册的目录对于启用了git或mercurial集成的项目，intellijidea会扫描项目目录以检查是否存在不受ide控制的git/mercurial存储库。如果检测到此类存储库，intellijidea会显示一条通知。要添加未注册的根，请单击通知中的添加根链接。或者，打开版本控制设置页面，选择要添加的未注册根（他们标记为灰色），然后按照将目录与版本控制系统关联的过程进行操作。如果你不想再次收到有关这些根的通知，请单机通知中的忽略链接。请注意，如果将新的未注册存储添加到项目中，intellijidea将通知你。更改vcs关联按打开ide设置，然后选择版本控制|目录映射。ctrlalts目录映射页面显示项目目录和与其关联的版本控制系统的列表（如果未添加目录，则该列表仅包含项目根目录）。找到与要置于另一个版本控制系统下的目录相对应的行。单机vsc列。从出现的列表中，选择新的版本控制系统。如果你选择none，则将禁用所选目录的vsc集成。单机确定保存映射并返回目录映射页面。[链接]解决冲突根据你的版本控制系统，在不同情况下可能会出现冲突。当你在团队中工作时，你可能会遇到有人对你当前正在处理的文件提交更改的情况。如果这些更改不重叠（即，对不同的代码进行了更改），则会自动合并冲突。但是，如果相同的行受到影响，你的版本控制系统无法随机选择一侧而不是另一侧，并要求你解决冲突。合并、变基或挑选分支时也可能会出现冲突。[链接]非分布式版本控制系统当你尝试变基服务器上具有较新版本的文件时，intellijidea会通知你，并在编辑器中显示一条弹出消息：[图片]在这种情况下，你应该在更改文件之前更新本地版本或稍后合并更改。如果你尝试提交具有较新存储库版本的文件，则会提交失败，并且右下角会显示一条错误，告诉你尝试提交的文件已过期。[链接]“在失败的提交列表上创建更改列表”控制。[链接]对话框的[链接]页面。如果将已进行本地更改的文件与其他人提交的较新存储库版本进行同步，则会发生冲突。冲突文件将获得“已合并冲突”状态。该文件保留在“更改”视图中的同一更改列表中，但其名称以红色突出显示。如果文件当前在编辑器中打开，选项卡标题上的文件名也会以红色突出显示。[链接]分布式版本控制系统在分布式版本控制系统（例如git和mercurial）下，当您在本地提交的文件对与最新上游版本相同的代码行进行更改时，以及当您尝试执行以下操作之一时，就会出现冲突：[链接]、[链接]、[链接]、[链接]、[链接]或[链接]。如果存在冲突，这些操作将失败，并且系统将提示您接受上游版本、首选您的版本或手动合并更改：[图片]当在版本控制级别检测到冲突时，会自动触发“冲突”对话框。如果您在此对话框中单击“关闭”或从命令行调用导致合并冲突的git操作，则“本地更改”视图中将出现“合并冲突”节点，并提供用于解决这些问题的链接：[图片]intellijidea提供了一个在本地解决冲突的工具。该工具由三个窗格组成：左侧窗格显示只读本地副本右窗格显示签入存储库的只读版本中央窗格显示一个功能齐全的编辑器，其中显示合并和冲突解决的结果。最初，此窗格的内容与文件的基本修订版本相同，即派生两个冲突版本的修订版本。[图片]1、解决冲突单击“冲突”对话框中的“合并”、“本地更改”视图中的“解决”链接，或在编辑器中选择冲突文件并选择“vcs|”。&lt;您的vcs&gt;|从主菜单解决冲突。要自动合并所有不冲突的更改，请单击工具栏上的[图片](应用所有不冲突的更改)。您还可以使用[图片]（从左侧应用非冲突更改）和[图片]（从右侧应用非冲突更改）分别合并对话框左/右部分的非冲突更改。要解决冲突，您需要选择对左侧（本地）和右侧（存储库）版本应用哪个操作（接受[图片]或忽略），并在中央窗格中检查生成的代码：[图片][图片]您还可以右键单击中央窗格中突出显示的冲突，然后使用上下文菜单中的命令。使用左侧解决和使用右侧解决命令分别提供了从一侧接受更改并从另一侧忽略更改的快捷方式：[图片]对于简单冲突（例如，如果同一行的开头和结尾已在不同的文件修订版中修改），可以使用“解决简单冲突”[图片]按钮，该按钮允许一键合并更改。[图片]此类冲突无法通过“应用所有非冲突更改”操作来解决，因为您必须确保它们得到正确解决。[链接]请注意，中央窗格是一个功能齐全的编辑器，因此您可以直接在此对话框中更改结果代码。比较不同版本以解决冲突也可能很有用。使用[图片]工具栏按钮调用选项列表。请注意，base是指本地版本和存储库版本源自的文件版本（最初显示在中间窗格中），而middle是指结果版本。在中央窗格中查看合并结果，然后单击“应用”。2、生产力技巧自动应用不冲突的更改您可以将intellijidea配置为始终自动应用不冲突的更改，而不是从“合并”对话框中告诉它这样做。为此，请选择“工具”|“自动应用不冲突的更改”选项。ide设置的diffmerge页面。ctrlalts在中央窗格中管理更改您可以使用将鼠标悬停在装订线中的更改标记上然后单击它时出现的工具栏来管理中央窗格中的更改。工具栏与一个框架一起显示，该框架显示修改行的先前内容：[图片]例如，当存在多个不冲突的更改时，您只需跳过其中一两个更改，则可以更轻松地使用“应用所有不冲突的更改”操作同时应用所有更改，然后使用“还原”撤消不需要的更改。从此工具栏执行操作。[链接]vcs与问题跟踪器集成借助intellijidea，您可以将提交消息与错误跟踪器或问题数据库连接起来，并从vcs日志中的提交导航到与这些提交相关的问题。1、启用从提交消息到问题的导航按打开ide设置，然后选择版本控制|问题导航。ctrlalts通过将提交消息中的问题模式与引用问题的url地址进行映射来配置问题导航模式列表。如果您使用[链接]或[链接]，请单击工具栏上的“添加jira模式”[图片]或“添加youtrack模式”，然后键入安装错误跟踪系统的url。[图片]intellijidea将自动添加定义导航模式的正则表达式。对于其他问题跟踪系统，单击添加按钮[图片]创建新条目或选择现有条目并单击编辑按钮。在打开的“添加问题导航链接”对话框中，指定以下正则表达式：提交消息中[链接]模式定义用于访问相应引用问题的url的[链接]表达式2、例子问题id定义提交消息中问题引用格式的[链接]。[a-z]+\-\d+此正则表达式匹配由n破折号字符分隔的两个子字符串组成的所有字符串：子字符串1：无限数量的大写字母字符。子字符串2：无限数量的数字字符。问题链接问题跟踪系统的url地址和标识其中问题的正则表达式的组合。http://&lt;mytracker&gt;/issue/$0这里$0表示对整个比赛的反向引用。这意味着，一旦intellijidea检测到提交消息中的匹配项，它就会按原样添加到跟踪器的url地址中。匹配问题idintellijidea在感兴趣的提交消息中检测到以下对问题的引用：myproject-110组成的问题链接根据上述问题导航模式，检测到的匹配引用按原样添加到跟踪器的url中，因此指向引用问题的链接组成如下：http://mytracker/issue/myproject-110[链接]管理变更列表更改列表是一组尚未提交到vcs存储库的本地更改。使用变更列表，你可以对与不同任务相关的变更进行分组，并独立提交这些变更集。有关更多信息，请参阅[链接]。如果您使用git，变更列表只是[链接]方法之一。更改列表显示在更改视图中。最初，有一个名为changes的默认更改列表。所有新更改都会自动放入更改更改列表中。还有一个未版本控制的文件更改列表，用于对尚未添加到vcs中的新创建的文件进行分组。[图片]你可以根据需要创建任意数量的更改列表，并随时使其中任何一个更改列表处于活动状态。你可以将任何未提交的更改移至任何更改列表。1、创建新的变更列表在“本地更改”视图中，单击[图片]工具栏上的并选择“新建更改列表”。在“新建更改列表”对话框中，指定新更改列表的名称，并添加说明（可选）。2、设置活动变更列表在“本地更改”视图中，选择一个非活动更改列表，然后按或右键单击它，然后从上下文菜单中选择“设置活动更改列表”。所有新的更改都会自动放入此更改列表中。ctrlspace3、在更改列表之间移动更改在“本地更改”视图中，选择要移动到另一个更改列表的更改。右键单击所选内容或单击[图片]工具栏上的并选择“移动到另一个更改列表”。altshiftm在打开的对话框中，选择现有变更列表或输入新变更列表的名称。您可以选择使目标更改列表处于活动状态并跟踪其上下文（intellijidea将保存与此更改列表关联的上下文，并在该更改列表变为活动状态时恢复它）。您还可以在更改列表之间拖动文件。有关将一个文件中的更改放入git中的不同更改列表的更多信息，请参阅将[链接]。4、删除变更列表右键单击更改列表，然后从上下文菜单中选择“删除更改列表”。[链接]搁置和取消搁置更改取消搁置更改：ctrlshiftu搁置是暂时存储您尚未提交的待处理更改。例如，如果您需要切换到另一个任务，并且希望将更改放在一边以供稍后处理，则这非常有用。使用intellijidea，您可以搁置单独的文件和整个变更列表。您无法搁置未版本化的文件，即尚未[链接]文件。搁置后，可以根据需要多次应用更改。[链接]搁置变更在“提交”工具窗口中，右键单击要搁置的文件或更改列表，然后从上下文菜单中选择“搁置更改”。alt0[图片]在“搁置更改”对话框中，查看已修改文件的列表。在“提交消息”字段中，输入要创建的架子的名称，然后单击“架子更改”按钮。您还可以静默搁置更改，而不显示“搁置更改”对话框。为此，请选择要搁置的文件或更改列表，然后单击工具栏上的“静默搁置”图标或按。包含要搁置的更改的更改列表的名称将用作搁置名称。[图片]ctrlshifth为了避免出现多个同名的架子（例如default），您可以将文件或更改列表从“提交到”选项卡拖到“提交”工具窗口的“架子”选项卡，稍等片刻直到它被激活，释放鼠标按钮后编辑新的架子名称。如果您需要将更改复制到架子而不重置本地更改，请按并查找“保存到架子”操作。ctrlshifta[链接]取消搁置变更取消搁置是将推迟的更改从搁架移动到待处理的更改列表。未搁置的更改可以从视图中过滤掉或从搁置中删除。在[链接]选项卡中，选择更改列表或要取消搁置的文件。按或从所选内容的上下文菜单中选择“取消搁置”。ctrlshiftu[图片]在“取消搁置更改”对话框中，在“名称”字段中指定要将未搁置的更改恢复到的更改列表。您可以从列表中选择现有变更列表或输入要创建的新变更列表的名称。您可以在注释字段中输入新变更列表的描述（可选）。如果您想让新的更改列表处于活动状态，请选择“设置活动”。否则，当前活动变更列表保持活动状态。如果您希望intellijidea在停用时保存与新变更列表关联的任务的上下文，并在变更列表变为活动状态时恢复上下文，请选择“跟踪上下文”选项（有关详细信息，请参阅[链接]如果要删除要取消搁置的更改，请选择“从搁置中删除已成功应用的文件”选项。未搁置的文件将从该搁置中删除，添加到另一个更改列表中，并标记为已应用。[图片]只有通过单击工具栏上的或从上下文菜单中选择清理已取消搁置来明确删除它们，它们才会被完全删除。如果您意外删除了未搁置的文件，您可以从“最近删除”节点查看和恢复它们。单击“确定”。如果修补版本与当前版本发生冲突，请按照[链接]中的说明进行解决。您还可以静默取消搁置更改，而不显示“取消搁置更改”对话框。为此，请选择要取消搁置的文件或更改列表，然后单击工具栏上的“静默取消搁置”图标或按。未搁置的文件将移至活动的挂起更改列表。[图片]ctrlaltu您还可以将文件或更改列表从“搁置”选项卡拖到“提交到”选项卡以静默取消搁置。如果按住键拖动它，它将被复制到“提交到分支”选项卡，但也会保留在架子中。ctrl[链接]放弃搁置的更改在“书架”视图中，选择包含您不想再保留的更改的更改列表。右键单击更改列表，然后从上下文菜单中选择“删除”或按。delete[链接]恢复未搁置的更改intellijidea允许您在必要时重新应用未搁置的更改。所有未搁置的更改都可以重复使用，直到通过单击[图片]工具栏上的图标或从上下文菜单中选择“清理已未搁置”来明确删除它们为止。确保已启用显示已取消搁置的工具栏选项。[图片]选择要恢复的文件或架子。从所选内容的上下文菜单中，选择“恢复”。[链接]应用外部补丁您可以导入在intellijidea内部或外部创建的补丁，并将它们作为搁置的更改应用。在shelf视图中，从上下文菜单中选择importpatches。在打开的对话框中，选择要应用的补丁文件。选定的补丁将在“shelf”选项卡中显示为“shelf”。选择新添加的带有补丁的架子，然后从所选内容的上下文菜单中选择“取消搁置更改”。[链接]自动搁置基础修订将intellijidea配置为始终搁置受git版本控制的文件的基本修订版本可能很有用。按打开ide设置，然后选择版本控制|架子。ctrlalts选择“在分布式版本控制系统下搁置文件的基本修订版本”选项。如果启用此选项，文件的基本修订版本将保存到架子上，如果应用架子导致冲突，则该架子将在[链接]#three-way_merge)期间使用。如果禁用，intellijidea将在项目历史记录中查找基础修订版，这可能需要一段时间；此外，冲突架所基于的修订可能会丢失（例如，如果历史记录因变基操作而更改）。[链接]更改默认架子位置默认情况下，shelf目录位于您的项目目录下。但是，您可能想要更改默认的架子位置。例如，如果您想避免在清理工作副本时意外删除架子，或者希望将它们存储在单独的存储库中，以便在团队成员之间共享架子，这可能很有用。按打开ide设置，然后选择版本控制|架子。ctrlalts单击更改书架位置并在打开的对话框中指定新位置。如有必要，选择将架子移动到新位置以将现有架子移动到新目录。[链接]使用补丁您可以将其放入.patch文件中，而不是提交本地更改，您可以稍后将其应用到源、通过电子邮件发送等。使用补丁是一种共享更改的便捷机制，无需在vcs存储库中检查它们。[链接]从未提交的更改创建补丁在“本地更改”视图中，选择要包含在补丁中的文件或更改列表，然后从上下文菜单中选择“从本地更改创建补丁”。您还可以选择提交更改：单击“提交”按钮旁边的箭头，然后选择“创建补丁”。在打开的对话框中，确保选择要包含在补丁中的所有更改，输入提交注释（可选），然后单击“创建补丁”。在“修补程序文件设置”对话框中，根据需要修改默认修补程序文件位置，然后单击“确定”。如果您不需要将补丁保存到文件中（例如，您想通过电子邮件发送补丁），请在“更改”视图中右键单击必要的文件，然后从上下文菜单中选择“复制为补丁到剪贴板”。[链接]从整个提交创建补丁在版本控制工具窗口的“日志”选项卡中，找到包含要包含在补丁中的更改的提交，然后从上下文菜单中选择“创建补丁”。alt9在“修补程序文件设置”对话框中，根据需要修改默认修补程序文件位置，然后单击“确定”。[链接]从文件创建补丁在任何视图（项目工具窗口、编辑器、更改视图等）中选择必要的文件。选择git|从vcs主菜单或选择的上下文菜单显示历史记录。“历史记录”选项卡已添加到git工具窗口，显示所选文件的历史记录，并允许您查看和比较其修订版本。右键单击修订版本并从上下文菜单中选择“创建补丁”或单击工具栏上的“创建补丁”图标。[图片][链接]应用补丁选择vcs|补丁|从主菜单应用补丁。在打开的“应用补丁”对话框中，指定要应用的.patch文件的路径。您可以将文件或电子邮件附件拖到编辑器中的任何位置。如有必要，单击[图片]并选择“映射基本目录”以指定相对于补丁文件中的文件名进行解释的目录。您可以将基本目录映射到单个文件、目录或选择。如果在创建补丁后编辑源代码，可能会出现冲突。要检查您的补丁是否可以在不发生冲突的情况下应用，请单击“显示差异”。如果存在冲突，相应的行将以红色突出显示。[图片]ctrld如果您想要将更改应用于存储在补丁中指定位置以外的位置的文件，您可以通过单击并[图片]选择“删除所有前导目录”来去除前导目录。选择要应用补丁的变更列表，或在“名称”字段中指定新变更列表的名称，然后为此变更列表输入注释（可选）。如果您想让此更改列表处于活动状态，请选择“设置为活动”选项。如果您希望intellijidea在停用时保存与新变更列表关联的任务的上下文，并在变更列表变为活动状态时恢复上下文，请选择“跟踪上下文”选项（有关详细信息，请参阅[链接]如果您想在应用补丁之前将其移动到临时存储（搁架），请单击导入到搁架（有关详细信息，请参阅[链接]）。否则，请单击“确定”。您还可以通过选择vcs|复制补丁文件的内容并应用它。从主菜单应用剪贴板补丁。例如，当您通过电子邮件收到补丁但不想保存它时，这会很方便。对于[链接]补丁，intellijidea会提取提交消息和作者，并自动填充commit工具窗口中的相应字段。alt0[链接]审查变更本主题说明如何跟踪您和您的团队成员对源代码所做的更改。[链接]回顾项目历史intellijidea允许您查看对与指定过滤器匹配的项目源所做的所有更改。对于分布式版本控制系统，例如git和mercurial，您可以在版本控制工具窗口的日志选项卡中查看项目历史记录（请参阅[链接]）。alt9对于集中式版本控制系统，例如subversion、perforce和clearcase，项目历史记录可在版本控制工具窗口的[链接]中找到。alt9[链接]在编辑器中跟踪文件的更改当您修改受版本控制的文件时，所有更改都会在编辑器中突出显示，并带有更改标记，这些标记出现在修改行旁边的装订线中，并显示自上次与存储库同步以来引入的更改类型。当您将修改后的文件提交到存储库时，更改标记就会消失。您对文本所做的更改是用颜色编码的：[图片]已添加行。[图片]线路改变了。[图片]行已删除。您可以在编辑器|上自定义线路状态的默认颜色。配色方案|ide设置的vcs页面。ctrlalts要禁用装订线中的vcs标记，请取消选择“版本控制”|“装订线”中的“突出显示装订线中已修改的行”选项。ide设置的确认页面。ctrlalts您可以使用专用工具栏管理更改。要调用它，请将鼠标悬停在更改标记上，然后单击它。工具栏与一个框架一起显示，该框架显示修改行的先前内容：[图片]工具栏中的操作可让您导航到下一个或上一个更改、回滚更改、查看当前版本与存储库版本之间的差异、将修改行的先前版本复制到剪贴板，或者打开突出显示代码中的差异。如果要关闭突出显示更改，请取消选中版本控制|上的突出显示装订线中修改的行选项。ide设置的确认页面。ctrlalts[链接]将本地更改与存储库版本进行比较除了在编辑器中[链接]文件中的本地更改之外，您还可以将这些更改与文件的基本修订版进行比较。要预览差异，请在“提交”工具窗口中选择修改后的文件，然后单击[图片]工具栏上的。左侧窗格显示基本修订版中受影响的代码，右侧页面显示您在本地进行更改后受影响的代码。[图片]使用工具栏按钮和控件在更改之间导航并配置更改详细信息窗格或差异查看器的外观：物品工具提示和快捷方式描述[图片]/[图片]上一个差异/下一个差异shiftf7f7跳转到下一个或上一个差异。当达到最后一个或第一个差异时，intellijidea建议单击箭头按钮或再次按/并比较本地修改的其他文件。此行为取决于[链接][链接]选项。f7shiftf7[图片]跳转至源代码f4在编辑器中打开选定的文件。插入符号的位置与差异查看器中的位置相同。[图片][图片]比较上一个/下一个文件alt←alt→将上一个或下一个文件的本地副本与其来自服务器的更新进行比较。仅当本地修改了多个文件时，这些控件才可用。[图片]转到已更改的文件ctrl0n显示当前更改集中所有已更改的文件并导航到它们。仅当您查看对多个文件的更改时，此操作才可用。观众选择查看器模式：并排或统一。并排模式有两个面板，统一模式有一个面板。您可以在两个查看器中编辑代码并执行accept、append、revert操作。您只能更改并排查看器的右侧部分或统一查看器的下一行中的文本。您只能编辑文件的本地版本。您无法编辑具有只读状态的文件。空白定义差异查看器应如何处理空格。不要忽视：空白很重要，并且所有差异都会突出显示。默认情况下选择此选项。修剪空白：修剪出现在行尾和行首的空白((&quot;\t&quot;,&quot;&quot;))。如果两行仅尾随空格不同，则这些行被视为相等。如果两行不同，则在[链接]模式下不会突出显示尾随空格。忽略空格：空格并不重要，无论它们在源代码中的位置如何。忽略空格和空行：忽略空格和空行。以下实体将被忽略：所有空格（如“忽略空格”选项中所示）所有添加或删除的行仅由空格组成所有由分割或连接行组成的更改，而不更改非空白部分。例如，在此模式下不会突出显示abc和之间的差异。a\nbc忽略导入和格式设置：导入语句中的更改和空格将被忽略（但会考虑字符串文字中的空格）。突出显示模式选择突出显示差异粒度的方式。可用的选项有：高亮单词：修改后的单词高亮显示高亮行：修改的行高亮显示突出显示拆分更改：如果选择此选项，则大更改将拆分为较小的更改。例如，a\nb和ax\nbx被视为两项更改而不是一项。高亮字符：修改后的符号高亮显示不突出显示：如果选择此选项，则根本不突出显示差异。当您处理经过重大修改的文件时，请使用“不突出显示”选项。在这种情况下，突出显示可能会在审核过程中带来额外的困难。[图片]折叠未更改的片段折叠两个文件中所有未更改的片段。不可折叠的未更改行的数量可在“差异和合并”设置页面上进行配置。要打开“差异和合并”页面，请按打开设置，然后导航到“工具”\“差异与合并。ctrlalt0s[图片]同步滚动单击此按钮可同时滚动两个差异窗格。如果释放此按钮，每个窗格都可以独立滚动。[图片]设置打开可用设置的列表。也可以从差异查看器装订线的上下文菜单中使用这些命令。[图片]在外部工具中显示差异调用外部差异[链接]设置页面上指定的外部差异查看器。仅当在外部比较工具设置页面上启用使用外部[链接]工具选项时，此按钮才在工具栏上可用。[图片]帮助f1打开浏览器并显示相应的帮助页面。使用gitblame进行注释此选项只能从装订线的上下文菜单中使用。使用此选项可以探索谁对文件的存储库版本进行了哪些更改以及何时进行。通过注释视图，您可以查看每行代码的详细信息，例如该行源自的版本、提交该行的用户的id以及提交日期。有关注释的更多信息，请参阅[链接]。最有用的快捷键如下：捷径描述ctrlshiftd使用此键盘快捷键可显示最常用的diff命令的弹出菜单。ctrlshifttab使用此键盘快捷键可在左窗格和右窗格之间切换。ctrlz/ctrlshiftz使用此键盘快捷键可撤消/重做合并操作。冲突将与文本保持同步。[链接]查看文件或选择的更改历史记录intellijidea允许您查看对文件甚至源代码片段所做的更改。“显示历史记录”和“显示选择历史记录”命令可从vcs主菜单和文件的上下文菜单中使用。文件的更改历史记录显示在版本控制工具窗口的专用[链接]中。alt9[链接]的形式显示在单独的窗口中。1、查看文件历史记录在编辑器中打开文件或在项目工具窗口中选择它并选择|从上下文菜单中显示历史记录。所选文件的[链接]选项卡出现在版本控制工具窗口中，文件名显示在选项卡的标题栏上。alt9您可以使用[链接]按钮将所选版本与本地版本进行比较、比较所选版本中的类、从vcs中检出所选版本、注释所选版本等：物品工具提示和快捷方式描述[图片]刷新单击此按钮可刷新当前信息。[图片]显示差异ctrld单击此按钮可将文件的选定版本与[链接]中的先前版本进行比较。[图片]显示所有受影响的文件altshifta单击此按钮可打开“修订版中受影响的路径”对话框，您可以在其中查看在选定修订版中修改的所有文件。[图片]显示所有分行单击此按钮可显示当前分支以外的分支的更改。[图片]演示设置单击以选择您想要在“历史记录”视图中查看的信息量。如果您希望intellijidea显示提交时间戳而不是创作更改的时间，您还可以选择“显示提交时间戳”选项。[图片]配置布局单击以选择您要查看的信息类型：显示详细信息以显示所选修订的提交消息。显示差异预览以打开所选版本的差异预览。[图片]在github中打开[链接]上所选提交对应的页面。2、查看选择的历史记录在编辑器中，选择必要的源代码片段或将插入符号放在相应的行上。选择|从主vcs菜单或选择的上下文菜单显示选择的历史记录。所选片段的历史记录将在单独的窗口中打开。如果未选择任何内容，将显示当前行的历史记录。[链接]检查文件状态intellijidea允许您检查项目文件相对于存储库的状态。文件状态显示自上次与存储库同步以来已对文件执行了哪些操作。您可以通过用于突出显示文件名的颜色在任何界面元素（例如编辑器或工具窗口）中检查文件的状态。[链接]设置页面中自定义文件状态的默认颜色。您可以在版本控制|配置vcs文件状态颜色ide设置的文件状态颜色页面。ctrlalts要同时突出显示包含已修改内容的文件夹和包，请在版本控制|项目树中选择突出显示包含已修改文件的目录。ide设置的确认页面。ctrlalt0s下表列出了默认文件状态颜色及其在某些[链接]中的含义。浅色主题颜色文件状态描述[图片]#0a7700添加[链接]中的文件计划添加到存储库中。[图片]#0eaa00添加到非活动变更列表中非活动更改列表中的文件计划添加到存储库中。如果在“设置”\“突出显示非活动更改列表中的文件”选项已启用，则此文件状态可用。版本控制\变更列表。[图片]#ff0000变更列表冲突非活动变更列表中的文件已在活动变更列表中被修改。在这种情况下，将打开一个新对话框，提示您解决[链接]。如果在“设置”\“设置”中启用了所有选项，则此文件状态可用。版本控制\变更列表。[图片]#0a7700已复制如果一个文件是另一个文件的副本，则会跟踪其元数据，并将此类文件标记为已复制。[图片]#616161已删除该文件计划从存储库中删除。[图片]#773895从文件系统中删除该文件已在本地删除，但尚未计划删除，并且仍然存在于存储库中。[图片]#8aa4c8改变了后代如果文件被修改，ide将递归突出显示包含该文件的所有目录。如果在“设置”\“项目树”中启用“突出显示项目树中包含已修改文件的目录”选项，则此状态可用。版本控制\确认。[图片]#3264b4立即改变孩子如果文件被修改，ide将突出显示其父目录。如果在“设置”\“项目树”中启用“突出显示项目树中包含已修改文件的目录”选项，则此状态可用。版本控制\确认。[图片]#b28c00被劫持[perforce、clearcase、vss]文件被[链接][图片]#727238被忽略vcs故意取消跟踪文件。[图片]第7503章dc合并作为更新的结果，该文件由您的vcs合并。[图片]#ff0000与冲突合并在上次更新期间，该文件已合并并存在冲突。[图片]#ff0000合并财产冲突在上次更新期间，ide检测到本地文件的属性与其服务器版本之间存在差异。[图片]#ff0000合并文本和属性冲突当两个或多个开发人员修改文件的相同行和相同的文件属性时，就会发生文本和属性冲突。[图片]#0032a0修改的自上次同步以来该文件已更改。[图片]#0047e4在非活动变更列表中修改非活动更改列表中的文件已被修改。如果在“设置”\“突出显示非活动更改列表中的文件”选项已启用，则此文件状态可用。版本控制\变更列表。[图片]#7c7c00过时的该文件不应再位于存储库的工作副本中。[图片]#007c7c更名自上次更新以来，该文件已被重命名。[图片]#08978f已切换[svn]该文件取自与整个项目不同的分支。[图片]#993300（未知）未版本化该文件存在于本地，但不在存储库中，并且未计划添加。[图片]无（默认颜色）最新该文件尚未更改。达库拉主题颜色文件状态描述[图片]#629755添加[链接]中的文件计划添加到存储库中。[图片]#629755添加到非活动变更列表中非活动更改列表中的文件计划添加到存储库中。如果在“设置”\“突出显示非活动更改列表中的文件”选项已启用，则此文件状态可用。版本控制\变更列表。[图片]#d5756c变更列表冲突非活动变更列表中的文件已在活动变更列表中被修改。在这种情况下，将打开一个新对话框，提示您解决[链接]。如果在“设置”\“设置”中启用了所有选项，则此文件状态可用。版本控制\变更列表。[图片]#0a7700已复制如果一个文件是另一个文件的副本，则会跟踪其元数据，并将此类文件标记为已复制。[图片]#6c6c6c已删除该文件计划从存储库中删除。[图片]#6c6c6c从文件系统中删除该文件已在本地删除，但尚未计划删除，并且仍然存在于存储库中。[图片]#6897bb改变了后代如果文件被修改，ide将递归突出显示包含该文件的所有目录。如果在“设置”\“项目树”中启用“突出显示项目树中包含已修改文件的目录”选项，则此状态可用。版本控制\确认。[图片]#6897bb立即改变孩子如果文件被修改，ide将突出显示其父目录。如果在“设置”\“项目树”中启用“突出显示项目树中包含已修改文件的目录”选项，则此状态可用。版本控制\确认。[图片]无（默认颜色）被劫持[perforce、clearcase、vss]文件被[链接][图片]#848504被忽略vcs故意取消跟踪文件。[图片]#9876aa合并作为更新的结果，该文件由您的vcs合并。[图片]#d5756c与冲突合并在上次更新期间，该文件已合并并存在冲突。[图片]#d5756c合并财产冲突在上次更新期间，ide检测到本地文件的属性与其服务器版本之间存在差异。[图片]#d5756c合并文本和属性冲突textandpropertyconflictshappenwhentwoormoredevelopersmodifythesamelinesofafileandthesamefileproperties.[图片]#6897bbmodifiedthefilehaschangedsincethelastsynchronization.[图片]#6897bbmodifiedinnotactivechangelistthefileinaninactivechangelisthasbeenmodified.thisfilestatusisavailableifthehighlightfilesfromnon-activechangelistsoptionisenabledinsettings\versioncontrol\changelists.[图片]none(defaultcolor)obsoletethefileshouldnolongerbeinyourworkingcopyoftherepository.[图片]#3a8484renamedsincethelastupdate,thefilehasbeenrenamed.[图片]none(defaultcolor)switched[svn]thefileistakenfromadifferentbranchthanthewholeproject.[图片]#d1675a(unknown)unversionedthefileexistslocallybutisnotintherepositoryandisnotscheduledforaddition.[图片]none(defaultcolor)uptodatethefilehasn’tbeenchanged.高对比度主题colorfilestatusdescription[图片]#62cc47addedthefileintheactive[链接]isscheduledforadditiontotherepository.[图片]#62cc47addedinnotactivechangelistthefileinaninactivechangelistisscheduledforadditiontotherepository.thisfilestatusisavailableifthehighlightfilesfromnon-activechangelistsoptionisenabledinsettings\versioncontrol\changelists.[图片]#ff6666changelistconflictthefileinaninactivechangelisthasbeenmodifiedintheactivechangelist.inthiscase,anewdialogwillopen,promptingyoutoresolvethe[链接].thisfilestatusisavailableifalloptionsareenabledinsettings\versioncontrol\changelists.[图片]#62cc47copiedifafileisacopyofanotherfile,itsmetadataistracked,andsuchafileismarkedascopied.[图片]#ed864adeletedthefileisscheduledfordeletionfromtherepository.[图片]#ed864adeletedfromfilesystemthefilehasbeendeletedlocallybuthasn’tbeenscheduledfordeletion,anditstillexistsintherepository.[图片]#4ff0ffhavechangeddescendantsifafileismodified,theidewillrecursivelyhighlightalldirectoriescontainingthatfile.thisstatusisavailableifthehighlightdirectoriesthatcontainmodifiedfilesintheprojecttreeoptionisenabledinsettings\versioncontrol\confirmation.[图片]#4ff0ffhaveimmediatechangedchildrenifafileismodified,theidewillhighlightitsparentdirectory.thisstatusisavailableifthehighlightdirectoriesthatcontainmodifiedfilesintheprojecttreeoptionisenabledinsettings\versioncontrol\confirmation.[图片]none(defaultcolor)hijacked[perforce,clearcase,vss]thefileis[链接][图片]#a9b837ignoredafileisintentionallyuntrackedbyvcs.[图片]#ed94ffmergedthefileismergedbyyourvcsasaresultofanupdate.[图片]#ff6666mergedwithconflictsduringthelastupdate,thefilehasbeenmergedwithconflicts.[图片]#ff6666mergedwithpropertyconflictsduringthelastupdate,theidehasdetecteddifferencesbetweenthepropertiesofthelocalfileanditsserverversion.[图片]#ff6666mergedwithtextandpropertyconflictstextandpropertyconflictshappenwhentwoormoredevelopersmodifythesamelinesofafileandthesamefileproperties.[图片]#4ff0ffmodifiedthefilehaschangedsincethelastsynchronization.[图片]#4ff0ffmodifiedinnotactivechangelistthefileinaninactivechangelisthasbeenmodified.thisfilestatusisavailableifthehighlightfilesfromnon-activechangelistsoptionisenabledinsettings\versioncontrol\changelists.[图片]none(defaultcolor)obsoletethefileshouldnolongerbeinyourworkingcopyoftherepository.[图片]#4ff0ffrenamedsincethelastupdate,thefilehasbeenrenamed.[图片]none(defaultcolor)switched[svn]thefileistakenfromadifferentbranchthanthewholeproject.[图片]d1675a(unknown)unversionedthefileexistslocallybutisnotintherepositoryandisnotscheduledforaddition.[图片]none(defaultcolor)uptodatethefilehasn’tbeenchanged.本章介绍vcs文件状态颜色。如果您需要设置颜色来区分特定范围的项目文件，请参考[链接]。[链接]版本控制系统注释1、什么是vcs注释？注释是一种文件表示形式，显示每行代码的详细信息。特别是，对于每一行，您可以查看该行的起源版本、提交该行的人员的用户id以及提交日期。带注释的视图可帮助您找出谁在何时做了什么，并追溯更改。注释代码行可用于clearcase、mercurial、git、perforce和subversion。“注释”命令可从版本控制菜单的vcs特定节点、编辑器装订线的上下文菜单、文件上下文菜单和文件[链接]视图中使用。启用注释后，装订线看起来类似于以下示例：[图片]当前版本中修改的行的注释用粗体和星号标记。2、启用注释右键单击编辑器或[链接]中的装订线，然后从上下文菜单中选择使用gitblame进行注释。您可以为“注释”命令分配自定义快捷方式：转到ide设置的“键盘映射”页面，然后查找“版本控制系统”|“版本控制系统”。git|git注释。ctrlalts要关闭注释，请右键单击编辑器或[链接]中的装订线，然后从上下文菜单中选择“关闭注释”。3、配置注释中显示的信息量您可以选择要在注释视图中查看的信息量。右键单击注释装订线，选择“查看”并选择要查看的信息类型，包括此更改源自的修订版、日期、不同格式的作者姓名以及提交号。您还可以在“颜色”下设置突出显示。4、配置注释选项右键单击注释装订线并从上下文菜单中选择选项：忽略空格：空格将被忽略（gitblame-w）。这意味着注释将指向先前有意义的提交。检测文件内的移动：当提交在同一文件中移动或复制行时，此类更改将被忽略（gitblame-m）。这意味着注释将指向先前有意义的提交。检测跨文件的移动：当提交移动或复制在同一提交中修改的其他文件中的行时，此类更改将被忽略（gitblame-c）。这意味着注释将指向先前有意义的提交。显示提交时间戳：如果您希望intellijidea在注释视图中显示提交时间戳而不是创作更改的时间，请选择此选项。5、自定义日期格式按打开ide设置，然后选择外观和行为|系统设置|日期格式。ctrlalts单击“vcs注释”旁边的“日期时间模式”字段，并指定要用于vcs注释的日期格式。请参阅[链接]。6、注释以前的修订intellijidea不仅允许您注释当前文件修订版本，还可以注释其先前的修订版本。注释装订线的上下文菜单提供以下选项：注释修订：如果您想检查提交特定更改后文件的外观，此选项非常有用。为此，请右键单击此更改并从上下文菜单中选择注释修订。注释以前的修订：如果您发现自己处于特定行中的最后更改毫无意义的情况（例如，如果所有更改都是代码格式），则此选项很有用。在这种情况下，您可以检查该文件的先前版本是什么样子。为此，请右键单击更改并从上下文菜单中选择“注释先前修订版”。[链接]记录视图中注释特定文件。在“历史记录”选项卡中，选择要查看的文件版本，右键单击相应行并从上下文菜单中选择“注释”。7、查看修订版本之间的差异要查看文件的带注释版本与其先前版本之间的差异，请将脱字符号放在注释处，右键单击它，然后选择“显示差异”。intellijidea打开[链接]：[图片]您还可以调用vcsoperations弹出窗口并选择annotatedline|显示差异。alt8、导航至日志如果您使用git进行版本控制，还可以在版本控制工具窗口的log选项卡中从注释视图跳转到相应的提交。alt9为此，请将插入符号放在注释处，右键单击它，然后从上下文菜单中选择“在git日志中选择”。您还可以使用复制修订版本号命令在日志中查找修订版本。[链接]上托管的项目，还可以使用“在github上打开”命令，将您带到相应的提交。]]></content>
        
        
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>Nacos 安装与使用</title>
        <link href="/posts/95afb97c.html"/>
        <url>/posts/95afb97c.html</url>
        <cover>https://cdn.apifox.cn/app/project-icon/custom/20221110/b67baa75-a01e-49c3-81fc-da1f2982343a.jpeg</cover>
        <date>Tue Sep 24 2024 17:00:26 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片][链接]概述[链接]服务注册与发现微服务与传统单体式应用架构最大区别就是强调软件模块的拆分。在单体架构下，一个应用系统的多个功能模块由于组织在一起在同一个应用进程内部署与运行，因此，模块之间直接通过方法调用即可完成对一次请求得响应。但在微服务系统中需要对一个应用系统根据其功能特点，按照一定粒度进行拆分后单独部署，以便实现模块内的高内聚，模块间的低耦合，实现整个微服务系统的高可扩展性。原来一次在一个应用内即可完成的请求处理，会出现跨进程跨主机的微服务调用，如何让这个服务之间能够互相发现像单体式应用一样提供统一对外的服务调用能力式微服务框架层面需要重点解决的核心问题之一。在springcloud生态中，采用了如下服务注册与发现模型，来实现微服务之间的相互发现与调用。[图片]如上图所示，通过在微服务系统中引入一个叫做注册中心的组件，来作为协调者。其最简化的过程是，所有的微服务应用在启动过程中会将自身包含服务名称、主机ip地址和端口号等信息发送到注册中心中，然后上游的微服务在处理请求过程中，根据服务名称到注册中心查找对应服务的所有实例ip地址和端口号来进行服务调用，整个过程中如图中虚线所示。从而让分散的微服务系统之间能够像一个整体一样对外提供请求处理能力。[链接]配置管理在正式介绍分布式配置内容之前，还是先简单介绍一下配置的概念。软件系统中的配置是指在软件运行过程中所需要的各种设定和参数，包括系统配置、应用配置和用户配置等。系统配置包括操作系统、硬件和网络等基本环境参数的设定应用配置包括应用程序的各种参数和选项的设定，如数据库连接字符串、日志级别等用户配置则是指用户自定义的各种选项和参数，如快捷键、界面布局、语言等配置在软件系统中是对软件源代码的一种重要补充，通过其可以便捷的调整软件系统的执行行为，让软件系统更加灵活。除了单体应用，在分布式系统中，配置信息应用非常广泛，可以通过配置来实现不同的功能。这些配置信息如数据库连接信息、日志级别、业务配置等等。在传统的开发中，这些配置西南西通常硬编码到应用程序的代码中，与程序代码一起打包和部署。然而，这种方式有很多缺点，比如配置不易维护，只要修改配置就得重新构建和部署等。[图片]采用分布式配置中心的软件架构如上图所示，其可以在分布式场景中帮助解决以下问题：管理应用程序配置：当有大量应用程序需要管理时，手动维护配置文件会变得非常困难。分布式配置中心提供了一个集中管理和分发配置信息的解决方案。环境隔离：在开发、测试和生产等不同环境中，应用程序的配置信息往往都会有不同。使用分布式配置中心，可以轻松管理和分发不同环境下的配置信息。提高程序安全性：将配置信息存储在代码库或应用程序文件中可能会导致安全风险，因为这些信息可能会被意外地泄露或被恶意攻击者利用。使用分布式配置，可以将配置信息加密和保护，并且可以进行访问权限控制。动态更新配置：在应用程序运行时，可能需要动态地更新配置信息，以便应用程序可以及时响应变化。使用分布式配置中心，可以在运行时动态更新配置信息，而无需重新启动应用程序。[链接]nacos概述[链接]/nɑ:kəʊs/是dynamicnamingandconfigurationservice的首字母简称，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。nacos致力于帮助发现、配置和管理微服务。nacos提供了一组简单易用的特性集，帮助你快速实现动态服务发现、服务配置、服务元数据及流量管理。nacos可以更敏捷和更容易地构建、交付和管理微服务平台。nacos是构建以服务为中心的现代应用架构（例如微服务范式、云原生范式）的服务基础设施。[链接]快速开始使用spring-cloud-starter-alibaba-nacos-config和spring-cloud-starter-alibaba-nacos-discovery完成springcloud应用的配置管理和服务发现。[链接]安装nacosserver[链接]接入云上免费版本体验springcloudalibaba注册配置中心的最简单方式就是接入阿里云上的托管nacosserver，这样可以免去本地安装下载的繁琐步骤。具体参考[链接]。如果是用的云上托管版本nacosserver，在接下来的文档使用云上nacosserver地址替换127.0.0.1:8848即可。[链接]本地安装方式具体启动方式参考[链接]官网。nacosserver启动成功之后，浏览器地址栏输入http://ip:8848/nacos查看nacos控制台（默认账号名称和密码为nacos/nacos）：[图片]关于更多的nacosserver版本，可以从nacos官方[链接]页面查看。[链接]接入nacos配置中心[链接]接入nacosconfig如果在你的项目中使用nacos来实现配置管理，需要进行以下操作（确保nacosserver已启动）：需要在pom.xml文件中引入groupid为com.alibaba.cloud和atrfactid为spring-cloud-starter-alibaba-nacos-config的starter:[代码块]在应用的/src/main/resources/application.yaml配置文件中配置nacosconfig地址并引入服务配置：[代码块]完成上述两步后，应用会从nacosserver中获取相应的配置，并添加在springenvironment的propertysources中。假设我们通过nacos作为配置中心保存应用服务的部分配置，有以下几种方式实现：beanautorefreshconfigexample：通过将配置信息配置给bean，支持配置变自动刷新；configlistenerexample：监听配置信息；dockinginterfaceexample：对接nacos接口，通过接口完成对配置信息增删改查；valueannotationexample：通过@value注解进行配置信息获取。[链接]添加nacos配置命令方式：[代码块]控制台方式（推荐使用）[代码块]配置内容如下：[代码块][链接]启动应用并验证应用启动添加其他配置：在应用的src/main/resources/application.yaml中添加基本配置信息：[代码块]启动应用，支持ide直接启动和编译打包后启动。ide直接启动：找到主类nacosconfigapplication，执行main方法启动应用。打包编译后启动：首先执行mvncleanpackage将工程编译打包，然后执行java-jarnacos-config-example.jar启动应用。功能验证验证自动注入请求[链接]地址，可以看到成功从nacos配置中心中获取了数据。[代码块]响应结果：[代码块]验证动态刷新在命令行终端执行以下命令刷新nacos的配置信息：[代码块]再次请求[链接]地址，可以看到应用已经从nacos中获取到了最新的数据。[代码块]响应结果：[代码块]nacos配置管理示例源码参考：[链接][链接]接入nacos服务注册与发现[链接]接入nacosdiscovery如果要在你的项目中使用nacos来作为服务发现的组件。需要进行以下操作（确保nacosserver已启动）：需要在pom.xml文件中引入groupid为com.alibaba.cloud和artifactid为spring-cloud-stater-alibaba-nacos-discovery的stater：[代码块]添加应用配置：在应用的/src/main/resources/application.properties配置文件中配置nacosserver地址：[代码块]使用@enablediscoveryclient注解开启服务注册与发现功能：[代码块][链接]启动应用并验证应用启动添加配置：在[链接]项目的/src/main/resources/application.properties中添加基本配置信息:[代码块]启动应用，支持ide直接启动和编译打包后启动。ide直接启动：找到[链接]项目的主类providerapplication，执行main方法启动应用。打包编译后启动：在[链接]项目中执行mvncleanpackage将工程编译打包，然后执行java-jarnacos-discovery-provider-example.jar启动应用。验证查询服务使用shell终端输入如下命令查询，可以看到服务节点已经成功注册到nacosserver。terminalwindow[代码块]响应结果：[代码块]服务发现在pom.xml中加入以下依赖：[代码块]在配置文件中加入以下配置：[代码块][链接]服务消费[链接]应用配置本章节只是为了便于您理解接入方式，此处只涉及ribbon、resttemplate、feignclient相关内容，如果已经使用了其他服务发现组件，可以通过直接替换依赖来接入spring-cloud-starter-alibaba-nacos-config。添加@loadblanced注解，使得resttemplate接入ribbon：[代码块]feignclient已经默认集成了ribbon，此处演示如何配置一个feignclient：[代码块]使用@feignclient注解将echoservice这个接口包装成一个feignclient，属性name对应服务名service-provider。echo方法上的@getmapping注解将echo方法与url“/echo/{str}”相对应，@pathvariable注解将url路径中的{str}对应成echo方法的参数str。将两者注入到controller中：[代码块]添加必要的配置：在[链接]项目的/src/main/resources/application.properties中添加基本配置信息：[代码块]启动应用ide直接启动：找到[链接]项目的主类consumerapplication，执行main方法启动应用。打包编译后启动：在[链接]项目中执行mvncleanpackage将工程编译打包，然后执行java-jarnacos-discovery-consumer-example.jar启动应用。[链接]验证请求[链接]地址，可以看到响应显示了nacos-discovery-provider-example返回的消息“hellonacosdiscovery1234”，证明服务发现生效。terminalwindow[代码块]响应结果：[代码块]请求[链接]地址，可以看到响应显示了nacos-discovery-provider-example返回的消息“hellonacosdiscovery12345”，证明服务发现生效。terminalwindow[代码块]响应结果：[代码块]nacos服务注册与发现示例源码参考：[链接][链接]进阶指南本章节展示spring-cloud-starter-alibaba-nacos-config和spring-cloud-starter-nacos-discovery的高级特性和进阶用法。[链接]nacos配置中心进阶指南[链接]profile粒度配置spring-cloud-starter-alibaba-nacos-congig在加载服务配置时：不仅仅加载了以dataid为${spring.application.name}.${file-extension:properties}为前缀的基础配置，还加载了dataid为${spring.application.name}-${profile}.${file-extension:properties}的基础配置。在日常开发中如果遇到多套环境下的不同配置，可以通过spring提供的${spring.profiles.active}这个配置项选择不同情况下的配置。[代码块]nacos上新增一个dataid为：nacos-config-develop.yaml的基础配置，如下所示：[代码块]启动springboot应用测试的代码如下：[代码块]控制台输出结果如下：[代码块]如果需要切换到生产环境，只需要更改${spring.profiles.active}参数配置即可。如下所示：[代码块]同时生产环境上nacos需要添加对应dataid的基础配置。例如，在生成环境下的nacos添加了dataid为：nacos-config-product.yaml的配置：[代码块]启动测试程序，输出结果如下：[代码块]note：此案例中我们通过spring.profiles.active=&lt;profilename&gt;的方式写死在配置文件中，而在真正的项目实施过程中这个变量的值是需要不同环境而有不同的值。这个时候通常的做法是通过-dspring.profiles.active=&lt;profile&gt;参数指定其配置来达到环境间灵活的切换。[链接]自定义namespace的配置nacos内部有[链接]的概念:用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的group或dataid的配置。namespace的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。在没有明确指定${spring.cloud.nacos.config.namespace}配置的情况下，默认使用的是nacos中public命名空间即默认的命名空间。如果需要使用自定义的命名空间，可以通过以下配置来实现：[代码块]note:该配置必须放在bootstrap.properties文件中。此外spring.cloud.nacos.config.namespace的值是namespace对应的id，id值可以在nacos的控制台获取。并且在添加配置时注意不要选择其他的namespace，否则将会导致读取不到正确的配置。[链接]自定义group的配置在没有明确指定${spring.cloud.nacos.config.group}配置的情况下，默认使用的是组default_group。如果需要自定义group，可以通过以下配置来实现：[代码块]note:该配置必须放在bootstrap.properties文件中。并且在添加配置时group的值一定要和spring.cloud.nacos.config.group的配置值一致。[链接]配置的优先级nacosconfig目前提供了三种配置能力从nacos拉取相关的配置：a:通过spring.cloud.nacos.config.shared-dataids支持多个共享dataid的配置b:通过spring.cloud.nacos.config.ext-config[n].data-id的方式支持多个扩展dataid的配置c:通过内部相关规则(应用名、应用名+profile)自动生成相关的dataid配置当三种方式共同使用时，他们的一个优先级关系是:a&lt;b&lt;c\[链接]springc.config.import引入这里假设有一个配置文件bootstrap.yml，升级到2021.0.1.0以上的版本应该怎么配置呢？bootstrap.yml[代码块]注意：上面的配置和下面的配置是等价的！application.yml[代码块]使用spring.config.import引入配置时的注意事项如下：如果使用spring.config.import就不能使用bootstrap.yml/properties引入配置的方式了；如果引入了spring-cloud-starter-alibaba-nacos-config，并且使用import方式导入配置,项目启动时会自动检测是否引入了nacos条目，如果没有importnacos条目，会出现如下错误：[代码块]可以通过手动设置spring.cloud.nacos.config.import-check.enabled=false关闭它，但是不建议这么做，这个功能可以帮助你检查是否引入多余依赖假如想保留以前的使用方式(bootstrap引入配置)，你只需要添加依赖spring-cloud-starter-bootstrap依赖，不需要修改一行代码即可完成配置方式的切换！[链接]配置项参考更多关于spring-cloud-starter-alibaba-nacos-config的starter配置项如下所示:配置项key默认值说明服务端地址spring.cloud.nacos.config.server-addr服务器ip和端口dataid前缀spring.cloud.nacos.config.prefix${spring.application.name}dataid的前缀，默认值为应用名称groupspring.cloud.nacos.config.groupdefault_groupdataid后缀及内容文件格式spring.cloud.nacos.config.file-extensionpropertiesdataid的后缀，同时也是配置内容的文件格式，目前只支持properties配置内容的编码方式spring.cloud.nacos.config.encodeutf-8配置的编码获取配置的超时时间spring.cloud.nacos.config.timeout3000单位为ms配置的命名空间spring.cloud.nacos.config.namespace常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源隔离等。accesskeyspring.cloud.nacos.config.access-keysecretkeyspring.cloud.nacos.config.secret-key相对路径spring.cloud.nacos.config.context-path服务端api的相对路径接入点spring.cloud.nacos.config.endpoint地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址是否开启监听和自动刷新spring.cloud.nacos.config.refresh-enabledtrue集群服务名spring.cloud.nacos.config.cluster-name[链接]endpoint信息请求[链接]地址，可以看到相关的endpoint节点信息。terminalwindow[代码块]响应结果：[代码块][链接]nacos服务注册与发现进阶指南[链接]原理spring-cloud-starter-alibaba-nacos-discovery遵循了springcloudcommon标准，实现了autoserviceregistration、serviceregistry、registration这三个接口。在springcloud应用的启动阶段，监听了webserverinitializedevent事件，当web容器初始化完成后，即收到webserverinitializedevent事件后，会触发注册的动作，调用serviceregistry的register方法，将服务注册到nacosserver。[链接]ipv4至ipv6地址迁移方案ipv4和ipv6地址双注册在配置完成springcloudloadbalancer作为负载均衡策略后，应用启动后会默认将微服务的ipv4地址和ipv6地址注册到注册中心中，其中ipv4地址会存放在nacos服务列表中的ip字段下，ipv6地址在nacos的metadata字段中，其对应的key为ipv6。当服务消费者调用服务提供者时，会根据自身的ip地址栈支持情况，选择合适的ip地址类型发起服务调用。具体规则：服务消费者本身支持ipv4和ipv6双地址栈或仅支持ipv6地址栈的情况下，服务消费者会使用服务提供的ipv6地址发起服务调用，ipv6地址调用失败且服务本身同时支持ipv4地址栈时，暂不支持切换到ipv4地址发起重试调用；服务消费者本身仅支持ipv4单地址栈的情况下，服务消费者会使用服务提供的ipv4地址发起服务调用。仅注册ipv4如果您只想使用ipv4地址进行注册，可以在application.properties使用如下配置项进行配置：[代码块]仅注册ipv6如果您只想使用ipv6地址，可以在application.properties使用如下配置项进行配置：[代码块][链接]配置项参考更多关于spring-cloud-starter-alibaba-nacos-discovery的starter配置项如下所示:配置项key默认值说明服务端地址spring.cloud.nacos.discovery.server-addr服务名spring.cloud.nacos.discovery.service应用名注册到nacos上的服务名称，默认值为应用名称权重spring.cloud.nacos.discovery.weight1取值范围1到100，数值越大，权重越大网卡名spring.cloud.nacos.discovery.network-interface当ip未配置时，注册的ip为此网卡所对应的ip地址，如果此项也未配置，则默认取第一块网卡的地址注册的ip地址spring.cloud.nacos.discovery.ip优先级最高注册的ip地址类型spring.cloud.nacos.discovery.ip-type双栈地址可以配置ipv4和ipv6两种类型，如果网卡同类型ip地址存在多个，希望制定特定网段地址，可使用spring.cloud.inetutils.preferred-networks配置筛选地址注册的端口spring.cloud.nacos.discovery.port-1默认情况下不用配置，会自动探测命名空间spring.cloud.nacos.discovery.namespace常用场景之一是不同环境的注册的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。accesskeyspring.cloud.nacos.discovery.access-keysecretkeyspring.cloud.nacos.discovery.secret-keymetadataspring.cloud.nacos.discovery.metadata使用map格式配置日志文件名spring.cloud.nacos.discovery.log-name集群spring.cloud.nacos.discovery.cluster-namedefaultnacos集群名称接入点spring.cloud.nacos.discovery.endpoint地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址是否集成loadbalancerspring.cloud.loadbalancer.nacos.enabledfalse是否开启nacoswatchspring.cloud.nacos.discovery.watch.enabledfalse可以设置成true来开启watch是否启用nacosspring.cloud.nacos.discovery.register-enabledtrue默认启动，设置为false时会关闭自动向nacos注册的功能是否启用容错配置spring.cloud.nacos.discovery.failure-tolerance-enabledfalse开启nacos服务发现失败容错能力，该功能会在nacos获取实例失败时返回上一次获取的实例，可以在nacosserver网络不稳定时提供容错能力，不会导致请求全部挂掉[链接]endpoint信息请求[链接]地址，可以看到相关的endpoint节点信息。terminalwindow[代码块]响应结果：[代码块]]]></content>
        
        
        <categories>
            
            <category> 环境搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nacos </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>Git 安装与使用</title>
        <link href="/posts/386349fe.html"/>
        <url>/posts/386349fe.html</url>
        <cover>https://picx.zhimg.com/v2-7ed54d37ea72cd82ab66a8fa3fc24c14_720w.jpg?source=172ae18b</cover>
        <date>Mon Sep 23 2024 17:51:26 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片][链接]git教程git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目git是linustorvalds为了帮助管理linux内核开发而开发的一个开放源码的版本控制软件git与常用的版本控制工具cvs，subversion等不同，它采用了分布式版本库的方式，不必服务器端软件支持[链接]git与svn区别git不仅仅是个版本控制系统，它也是个内容管理系统，工作管理系统等如果你是一个具有使用svn背景的人，你需要做一定的思想转换，来适应git提供的一些概念和特征git与svn区别点：git是分布式的，svn不是：这是git和其他非分布式的版本控制系统，例如svn，cvs等，最核心的区别git把内容按元数据方式存储，而svn是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似svn，cvs等的文件夹里git分支和svn的分支不同：分支在svn中一点都不特别，其实它就是版本库中的另一个目录git没有一个全局的版本号，而svn有：目前为止这是跟svn相比git缺少的最大的一个特征git的内容完整性要由于svn：git的内容存储使用的是sha-1哈希算法。这能确保代码的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏[图片][链接]git安装配置在使用git前我们需要先安装gitgit目前支持linux/unix、solaris、mac和windows平台运行git各平台安装包下载地址为：[链接][图片][链接]linux平台上安装各大linux平台可以使用包管理器（apt-get、yum等）进行安装debian/ubuntugit安装最新稳定版本命令为：[代码块]centos/redhat安装命令为：[代码块]fedora安装命令：[代码块]freebsd安装命令：[代码块]openbsd安装命令：[代码块]alpine安装命令：[代码块][链接]源码安装我们也可以在官网下载源码包来安装，最新源码包下载地址：[链接][图片]也可以在github上克隆源码包：[代码块]解压安装下载的源码包：[代码块][链接]windows平台安装在windows平台上安装git同样轻松，有个叫做msysgit的项目提供了安装包，可以到github的页面上下载exe安装文件并运行：安装包下载地址：[链接]直接官网下载也可以：[链接][图片]下载后，双击安装包，打开界面如下所示，点击“next”按钮开始安装：[图片]完成安装之后，就可以使用命令行的git工具（已经自带了ssh客户端）了，另外还有一个图形界面的git项目管理工具。在开始菜单里找到“git”-&gt;”gitbash”，会弹出git命令窗口，你可以在该窗口进行git操作。使用winget工具如果你已经安装了winget，可以使用以下命令来安装：[代码块][链接]mac平台上安装通过homebrew安装：[代码块]如果您想要安装git-gui和gitk（git的提交gui和交互式历史记录浏览器），您可以使用homebrew进行安装：[代码块]也可以使用图形化的git安装工具，下载地址为：[链接]安装界面如下所示：[图片][链接]git配置git提供了一个叫gitconfig的命令，用来配置或读取相应的工作环境变量。这些环境变量，决定了git在各个环节的具体工作方式和行为。这些变量可以存放在一下三个不同的地方：/etc/gitconfig文件：系统中对所有用户都普遍适用的配置。若使用gitconfig时用--system选项，读写的就是这个文件。~/.gitconfig文件：用户目录下的配置文件只适用于该用户。若使用gitconfig时用--global选项，读写的就是这个文件。当前项目的git目录中的配置文件（也就是工作目录中的.git/config文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以.git/config里的配置会覆盖/etc/gitconfig中的同名变量。在windows系统上，git会找寻用户主目录下的.gitconfig文件。主目录即$home变量指定的目录，一般都是c:\documentsandsettings$user。此外，git还会尝试找寻/etc/gitconfig文件，只不过看当初git装在什么目录，就以此作为根目录来定位。[链接]用户信息配置个人的用户名称和电子邮件地址，这是为了在每次提交代码时记录提交者的信息：[代码块]如果用了—global选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉—global选项重新配置即可，新的设定保存在当前项目的.git/config文件里。[链接]文本编辑器设置git默认使用的文本编辑器,一般可能会是vi或者vim，如果你有其他偏好，比如vscode的话，可以重新设置：[代码块][链接]差异分析工具还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用vimdiff的话：[代码块]git可以理解kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和opendiff等合并工具的输出信息。当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。[链接]查看配置信息要检查已有的配置信息，可以使用gitconfig—list命令：[代码块]有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如/etc/gitconfig和~/.gitconfig），不过最终git实际采用的是最后一个。这些配置我们也可以在~/.gitconfig或/etc/gitconfig看到，如下所示：[代码块]显示内容如下所示：[代码块]也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：[代码块][链接]成ssh密钥（可选）如果你需要通过ssh进行git操作，可以生成ssh密钥并添加到你的git托管服务（如github、gitlab等）上。[代码块]按提示完成生成过程，然后将生成的公钥添加到相应的平台。[链接]验证安装在终端或命令行中运行以下命令，确保git已正确安装并配置：[代码块][链接]git工作流程下图展示了git的工作流程：[图片][链接]1.克隆仓库如果你要参与一个已有的项目，首先需要将远程仓库克隆到本地：[代码块][链接]2.创建分支为了避免直接在main或master分支上进行开发，通常会创建一个新的分支：[代码块][链接]3.工作目录在工作目录中进行代码编辑、添加新文件或删除不需要的文件。[链接]4.暂存文件将修改过的文件添加到暂存区，以便进行下一步的提交操作：[代码块][链接]5.提交更改将暂存区的更改提交到本地仓库，并添加提交信息：[代码块][链接]6.拉取最新更改在推送本地更改之前，最好从远程仓库拉取最新的更改，以避免冲突：[代码块][链接]7.推送更改将本地的提交推送到远程仓库：[代码块][链接]8.创建pullrequest(pr)在github或其他托管平台上创建pullrequest，邀请团队成员进行代码审查，pr合并后，你的更改就会合并到主分支。[链接]9.合并更改在pr审核通过合并后，可以将远程仓库的主分支合并到本地分支：[代码块][链接]10.删除分支如果不再需要新功能分支，可以将其删除：[代码块]或者从远程仓库删除分支：[代码块][链接]git工作区、暂存区和版本库[链接]基本概念我们先来了解一下git工作区、暂存区和版本库概念：工作区：就是你在电脑里能看到的目录。暂存区：英文叫stage或index。一般存放到.git目录下的index文件(.git/index)中，所以我们把暂存区有时也叫索引(index)。版本库：工作区有一个隐藏目录.git，这个不算工作区，而是git的版本库。下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：[图片]图中左侧为工作区，右侧为版本库。在版本库中标记为index的区域是暂存区（stage/index），标记为master的是master分支所代表的目录树。图中我们可以看出此时的head实际是指向master分支的一个游标，所以图示的命令中出现head的地方可以用master来替换。图中的objects标识的区域为git的对象库，实际位于git/objects目录下，里面包含了创建的各种对象及内容。当对工作区修改（或新增）的文件执行gitadd命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的id被记录在暂存区的文件索引中。当执行提交操作(gitcommit)时，暂存区的目录树写到版本库（对象库）中，master分支会做相应的更新。即master指向的目录树就是提交时暂存区的目录树。当执行gitresthead命令时，暂存区的目录树会被重写，被master分支指向的目录树所替换，但是工作区不受影响。当执行gitrm--cached&lt;file&gt;命令时，会直接从暂存区删除文件，工作区则不做出改变。当执行gitcheckout，或者gitcheckout--&lt;file&gt;命令时，会用暂存区全部或指定的文件替换工作区的文件，这个操作很危险，会清除工作区中未添加到暂存区中的改动。当执行gitcheckouthead.或者gitcheckouthead&lt;file&gt;命令时，会用head指向的master分支中的全部或者部分文件替换暂存区和以及工作区的文件。这个命令也是极其危险的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。[链接]1.工作区（workingdirectory）工作区是你在本地计算机上的项目目录，你在这里进行文件的创建、修改和删除操作。工作区包含了当前项目的所有文件和子目录。特点：显示项目的当前状态文件的修改[链接]2.暂存区（stagingarea）暂存区是一个临时存储区域，它包含了即将被提交到版本库中的文件快照，在提交之前，你可以选择性地将工作区中的修改添加到暂存区。特点：暂存区保存了将被包括在下一个提交的更改你可以多次使用gitadd命令来讲文件添加到暂存区，直到你准备好提交所有更改常用命令：[代码块][链接]3.版本库（repository）版本库包含项目的所有版本历史记录。每次提交都会在版本库中创建一个新的快照，这些快照是不可变的，确保了项目的完整历史记录。特点：版本库分为本地版本库和远程版本库。这里主要指本地版本库。本地版本库存储在.git目录中，它包含了所有提交的对象和引用。常用命令：[代码块][链接]工作区、暂存区和版本库之间的关系[链接]1.工作区-&gt;暂存区使用gitadd命令将工作区中的修改添加到暂存区。[代码块][链接]2.暂存区-&gt;版本库使用gitcommit命令将暂存区中的修改提交到版本库。[代码块][链接]3.版本库-&gt;远程仓库使用gitpush命令将本地版本库的提交推送到远程仓库。[代码块][链接]4.远程仓库-&gt;本地版本库使用gitpull或gitfetch从远程仓库获取更新。[代码块][链接]实例假设你在工作目录中修改了file.txt：[链接]1.工作区修改file.txt并保存。[链接]2.暂存区将修改添加到暂存区：[代码块][链接]3.版本库将暂存区的修改提交到本地版本库：[代码块][链接]4.远程仓库将本地提交推送到远程仓库：[代码块]通过理解工作区、暂存区和版本库的作用及其相互关系，你可以更加高效地使用git进行版本控制和协同开发。[链接]git创建仓库可以使用一个已经存在的目录作为git仓库。[链接]gitinitgit使用gitinit命令来初始化一个git仓库，git的很多命令都需要在git的仓库中运行，所以gitinit是使用git的第一个命令。在执行完gitinit命令后，git仓库会生成一个git目录，该目录包含了资源的所有元数据，其他的项目目录保持不变。使用方法：进入你想要创建仓库的目录，或者先创建一个新的目录：[代码块]使用当前目录作为git仓库，我们只需要使它初始化：[代码块]该命令执行完后会在当前目录生成一个.git目录。使用我们指定目录作为git仓库。[代码块]初始化后，会在newrepo目录下会出现一个名为.git的目录，所有git需要的数据和资源都存放在这个目录中。如果当前目录下有几个文件想要纳入版本控制，需要先用gitadd命令告诉git开始对这些文件进行跟踪，然后提交：[代码块]以上命令将目录下.c结尾及readme文件提交到仓库中。注：在linux系统中，commit信息使用单引号&#39;&#39;,windows系统中，commit信息使用双引号&quot;&quot;。所以在gitbash中gitcommit-m&#39;提交说明&#39;这样是可以的，在windows命令行中就要使用双引号gitcommit-m&quot;提交说明&quot;[链接]gitclone我们使用gitclone从现有git仓库中拷贝项目（类似svncheckout）克隆仓库的命令格式为：[代码块]如果我们需要克隆到指定的目录，可以使用以下命令格式：[代码块]参数说明：repo：git仓库directory：本地目录比如，要克隆ruby语言的git代码仓库grit,可以使用下面的命令：[代码块]执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个.git目录，用于保存下载下来的所有版本记录。如果自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：[代码块]配置git的设置使用gitconfig命令。显示当前的git配置信息：[代码块]编辑git配置文件：[代码块]或者：[代码块]设置提交代码时的用户信息：[代码块]如果去掉—global参数则只对当前仓库有效。[链接]git基本操作git的工作就是创建和保存你项目的快照及与之后的快照进行对比。git常用的是以下6个命令：gitclone、gitpush、gitadd、gitcommit、gitcheckout、gitpull[图片]说明：workspace：工作区stagingarea：暂存区/缓存区localrepository：版本库或本地仓库remoterepository：远程仓库一个简单的操作步骤：[代码块]gitinit-初始化仓库gitadd.-添加文件到暂存区gitcommit-将暂存区内容添加到仓库中[链接]创建仓库命令下表列出了git创建仓库的命令：命令说明gitinit初始化仓库gitclone拷贝一份远程仓库，也就是下载一个项目。[链接]提交与修改git的工作就是创建和保存你的项目的快照及与之后的快照进行对比。下表列出了有关创建与提交你的项目的快照的命令：命令说明gitadd添加文件到暂存区gitstatus查看仓库当前的状态，显示有变更的文件。gitdiff比较文件的不同，即暂存区和工作区的差异。gitdifftool使用外部差异工具查看和比较文件的更改。gitrange-diff比较两个提交范围之间的差异。gitcommit提交暂存区到本地仓库。gitreset回退版本。gitrm将文件从暂存区和工作区中删除。gitmv移动或重命名工作区文件。gitnotes添加注释。gitcheckout分支切换。gitswitch（git2.23版本引入）更清晰地切换分支。gitrestore（git2.23版本引入）恢复或撤销文件的更改。gitshow显示git对象的详细信息。[链接]提交日志命令说明gitlog查看历史提交记录gitblame&lt;file&gt;以列表形式查看指定文件的历史修改记录gitshortlog生成简洁的提交日志摘要gitdescribe生成一个可读的字符串，该字符串基于git的标签系统来描述当前的提交[链接]远程操作命令说明gitremote远程仓库操作gitfetch从远程获取代码库gitpull下载远程代码并合并gitpush上传远程代码并合并gitsubmodule管理包含其他git仓库的项目[链接]git文件状态git的文件状态分为三种：工作目录（workingdirectory）、暂存区（stagingarea）、本地仓库（localrepository）。了解这些概念及其交互方式是掌握git的关键。[链接]工作目录（workingdirectory）工作目录是你在本地计算机上看到的项目文件。它是你实际操作文件的地方，包括查看、编辑、删除和创建文件。所有对文件的更改首先发生在工作目录中。在工作目录中的文件可能有以下几种状态：未跟踪（untracked）：新创建的文件，未被git记录。已修改（modified）：已被git跟踪的文件发生了更改，但这些更改还没有被提交到git记录中。[链接]暂存区（stagingarea）暂存区，也称索引（index），是一个临时存储区域，用于保存即将提交到本地仓库的更改。你可以选择性地将工作目录中的更改添加到暂存区中，这样你可以一次提交多个文件的更改，而不必提交所有文件的更改。使用gitadd&lt;filename&gt;命令将文件从工作目录添加到暂存区。使用gitadd.命令将当前目录下的所有更改添加到暂存区。[代码块][链接]本地仓库（localrepository）本地仓库是一个隐藏在.git目录中的数据库，用于存储项目中的所有提交历史记录，每次你提交更改时，git会将暂存区中的内容保存到本地仓库中。使用gitcommit-m&quot;commitmessage&quot;命令将暂存区中的更改提交到本地仓库。[代码块][链接]文件状态转换流程未跟踪（untracked）：新创建的文件最初是未跟踪的。它们存在与工作目录中，但没有被git跟踪。[代码块]已跟踪（tracked）：通过gitadd命令将未跟踪的文件添加到暂存区后，文件变为已跟踪状态。[代码块]已修改（modified）：对已跟踪的文件进行更改后，这些更改会显示为已修改状态，但这些更改还未添加到暂存区。[代码块]已暂存（staged）：使用gitadd命令将修改过的文件添加到暂存区后，文件进入已暂存状态，等待提交。[代码块]已提交（commited）：使用gitcommit命令将暂存区的更改提交到本地仓库后，这些更改被记录下来，文件状态返回为已跟踪状态。[代码块][链接]git分支管理git分支管理是git强大功能之一，能够让多个开发人员并行工作，开发新功能，修复bug或进行试验，而不影响主代码效率。几乎每一种版本控制系统都以某种形式支持分支，一个分支代表一条独立的开发线。使用分支意味着你可以从开发主线分离开来，然后再不影响主线的同时继续工作。[图片]git分支实际上是指向更改快照的指针。有人把git的分支模型成为必杀技特性，而正式因为它，将git从版本控制系统家族里区分出来。[链接]创建分支创建新分支并切换到该分支：[代码块]例如：[代码块]切换分支命令：[代码块]例如：[代码块]当你切换分支的时候，git会用该分支的最后提交的快照替换你的工作目录的内容，所以多个分支不需要多个目录。[链接]查看分支查看所有分支：[代码块]查看远程分支：[代码块]查看所有本地和远程分支：[代码块][链接]合并分支将其他分支合并到当前分支：[代码块]例如，切换到main分支合并feature-xyz分支：[代码块][链接]解决合并冲突当合并过程中出现冲突时，git会标记冲突文件，你需要手动解决冲突。打开冲突文件，按照标记解决冲突。标记冲突解决完成：[代码块]提交合并结果：[代码块][链接]删除分支删除本地分支：[代码块]强制删除未合并的分支：[代码块]删除远程分支：[代码块][链接]实例开始前我们先创建一个测试目录：[代码块][链接]git分支管理[链接]列出分支列出分支基本命令：[代码块]没有参数时，gitbranch会列出你在本地的分支。[代码块]此例的意思就是，我们有一个叫做master的分支，并且该分支是当前分支。当你执行gitinit的时候，默认情况下git就会为你创建master分支。如果我们要手动创建一个分支，执行gitbranch(branchname)即可。[代码块]现在我们可以看到，有了一个新分支testing。当你以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交，然后又切换到了testing分支，git将还原你的工作目录到你创建分支的时候的样子。接下来我们将演示如何切换分支，我们用gitcheckout(branch)切换到我们要修改的分支。[代码块]当我们切换到testing分支的时候，我们添加的新文件test.txt被移除了。切换回master分支的时候，它们又重新出现了。[代码块]我们也可以使用gitcheckout-b(branchname)命令来创建新分支并立即切换到该分支下，从而在该分支中操作。[代码块]如你所见，我们创建了一个新分支，在该分支上移除了一些文件text.txt，并添加了runoob.php文件，然后切换回我们的主分支，删除的test.txt问及那又回来了，且新增加的runoob.php不存在主分支中。使用分支将工作切分开来，从而让我们能够在不同开发环境中做事，并来回切换。[链接]删除分支删除分支命令：[代码块]例如我们要删除testing分支：[代码块][链接]分支合并一旦某分支有了独立内容，你终究会希望将他合并回到你的主分支，你也可以使用以下命令将任何分支合并到当前分支中去：[代码块][代码块]以上实例中我们将newtest分支合并到主分支区，test.txt文件被删除。合并完后就可以删除分支：[代码块]删除后，就只剩下master分支了：[代码块][链接]合并冲突合并并不仅仅是简单的文件添加和移除操作，git也会合并修改。[代码块]首先，我们创建一个叫做change_site的分支，切换过去，我们将runoob.php内容改为：[代码块]创建change_site分支：[代码块]将修改的内容提交到change_site分支中。现在，加入切换回master分支我们可以看内容恢复到我们修改前的（空文件，没有代码），我们再次修改runoob.php文件。[代码块]现在这些改变已经记录到我的“master”分支了。接下来我们将“change_site”分支合并过来。[代码块]我们将前一个分支合并到master分支，一个合并冲突就出现了，接下来我们需要手动去修改它。[代码块]在git中，我们可以用gitadd要告诉git文件冲突已经解决[代码块]现在我们成功解决了合并中的冲突，并提交了结果。[链接]命令手册命令说明用法示例gitbranch列出、创建或删除分支。它不切换分支，只是用于管理分支的存在。gitbranch：列出所有分支gitbranchnew-branch：创建新分支gitbranch-dold-branch：删除分支gitcheckout切换到指定的分支或恢复工作目录中的文件。也可以用来检出特定的提交。gitcheckoutbranch-name：切换分支gitcheckoutfile.txt：恢复文件到工作区gitcheckout&lt;commit-hash&gt;：检出特定提交gitswitch专门用于切换分支，相比gitcheckout更加简洁和直观，主要用于分支操作。gitswitchbranch-name：切换到指定分支gitswitch-cnew-branch：创建并切换到新分支gitmerge合并指定分支的更改到当前分支。gitmergebranch-name：将指定分支的更改合并到当前分支gitmergetool启动合并工具，以解决合并冲突。gitmergetool：使用默认合并工具解决冲突gitmergetool--tool=&lt;tool-name&gt;：指定合并工具gitlog显示提交历史记录。gitlog：显示提交历史gitlog--oneline：以简洁模式显示提交历史gitstash保存当前工作目录中的未提交更改，并将其恢复到干净的工作区。gitstash：保存当前更改gitstashpop：恢复最近保存的更改gitstashlist：列出所有保存的更改gittag创建、列出或删除标签。标签用于标记特定的提交。gittag：列出所有标签gittagv1.0：创建一个新标签gittag-dv1.0：删除标签gitworktree允许在一个仓库中检查多个工作区，适用于同时处理多个分支。gitworktreeadd&lt;path&gt;branch-name：在指定路径添加新的工作区并切换到指定分支gitworktreeremove&lt;path&gt;：删除工作区[链接]git查看提交历史查看git提交历史可以帮助你了解代码的变更情况和开发进度。git提供了多种命令和选项来查看提交历史，从简单的日志到详细的差异对比。git提交历史一般常用两个命令：gitlog-查看历史提交记录gitblame&lt;file&gt;-以列表形式查看指定文件的历史修改记录。[链接]gitlog在使用git提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用gitlog命令查看。gitlog命令用于查看git仓库中提交历史记录。gitlog显示了从最新提交到最早提交的所有提交信息，包括提交的哈希值、作者、提交日期和提交消息等。gitlog命令的基本语法：[代码块]常用的选项包括：-p：显示提交的补丁（具体更改内容）。--oneline：以简洁的一行格式显示提交信息。--graph：以图形化方式显示分支和合并历史。--decorate：显示分支和标签指向的提交。--author=&lt;作者&gt;：只显示特定作者的提交。--since=&lt;时间&gt;：只显示指定时间之后的提交。--until=&lt;时间&gt;：只显示指定时间之前的提交。--grep=&lt;模式&gt;：只显示包含指定模式的提交消息。--no-merges：不显示合并提交。--stat：显示简略统计信息，包括修改的文件和行数。--abbrev-commit：使用短提交哈希值。--pretty=&lt;格式&gt;：使用自定义的提交信息显示格式。针对我们前一章节的操作，使用gitlog命令列出历史提交记录如下：[代码块]我们可以用—oneline选项来查看历史记录的简洁的版本。[代码块]这告诉我们的是，此项目的开发历史。我们还可以用—graph选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：[代码块]现在我们可以更清楚明了地看到何时工作分叉、又何时归并。你也可以用—reverse参数来逆向显示所有日志。[代码块]如果只想查找指定用户的提交日志可以使用命令：gitlog—author,例如，比方说我们要找git源码中linus提交的部分：[代码块]如果你要指定日期，可以执行几个选项：—since和—before，但是你也可以用—until和—after。例如，如果我要看git项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了—no-merges选项以隐藏合并提交）：[代码块][链接]常用选项限制显示的提交数：[代码块]例如，显示最近的5次提交：[代码块]显示自指定日期之后的提交：[代码块]显示指定日期之前的提交：[代码块]只显示某个作者的提交：[代码块]更多gitlog命令可查看[链接]或使用gitlog—help命令查看帮助信息。[链接]gitblamegitblame命令用于逐行显示指定文件的每一行代码是由谁在什么时候引入或修改的。gitblame可以追踪文件中每一行的变更历史，包括作者、提交哈希、提交日期和提交消息等信息。如果要查看指定文件的修改记录可以使用gitblame命令，格式如下：[代码块]常用的选项包括：-l&lt;起始行号&gt;,&lt;结束行号&gt;：只显示指定行号范围内的代码注释。-c：对于重命名或拷贝的代码行，也进行代码行溯源。-m：对于移动的代码行，也进行代码行溯源。-c-c或-m-m：对于较多改动的代码行，进行更进一步的溯源。--show-stats：显示包含每个作者的行数统计信息。显示文件每一行的代码注释和相关信息：[代码块]只显示指定行号范围内的代码注释：[代码块]对于重命名或拷贝的代码进行溯源：[代码块]对于移动的代码进行溯源：[代码块]显示行数统计信息：[代码块]gitblame命令是以列表形式显示修改记录，如下实例：[代码块][链接]恢复和回退git提供了多种方式来恢复和回退到之前的版本，不同的命令适用于不同的场景和需求。以下是几种常见的方法：gitcheckout：切换分支或恢复文件到指定提交gitreset：重置当前分支到指定提交（软重置、混合重置、硬重置）。gitrevert：创建一个新的提交以撤销指定提交，不改变提交历史。gitreflog：查看历史操作记录，找回丢失的提交。[链接]1、gitcheckout：检查出特定版本的文件gitcheckout命令用于切换分支或恢复工作目录中的文件到指定的提交。恢复工作目录中的文件到某个提交：[代码块]例如，将file.txt恢复到abc123提交时的版本：[代码块]切换到特定提交：[代码块]例如：[代码块]这种方式切换到特定的提交时，处于分离头指针（detachedhead）状态。[链接]2、gitreset：重置当前分支到特定提交gitreset命令可以更改当前分支的提交历史，它有三种主要模式：—soft、—mixed和—hard。—soft：只重置head到指定的提交，暂存区和工作目录保持不变。[代码块]—mixed（默认）：重置head到指定的提交，暂存区重置，但工作目录保持不变。[代码块]—hard：重置head到指定的提交，暂存区和工作目录都重置。[代码块]例如，将当前分支重置到abc123提交：[代码块][链接]3、gitrevert：撤销某次提交gitrevert命令创建一个新的提交，用来撤销指定的提交，它不会改变提交历史，适用于已经推送到远程仓库的提交。[代码块]例如，撤销abc123提交：[代码块][链接]4、gitreflog：查看历史操作记录gitreflog命令记录了所有head的移动。即使提交被删除或重置，也可以通过reflog找回。[代码块]利用reflog可以找到之前的提交哈希，从而恢复到特定状态。例如：[代码块][链接]实例以下是一个综合示例，演示如何使用这些命令恢复历史版本：查看提交历史：[代码块]假设输出如下：[代码块]切换到commit2（处于分离头指针状态）：[代码块]重置到commit2，保留更改到暂存区：[代码块]重置到commit2，取消暂存区更改：[代码块]重置到commit2，丢弃所有更改：[代码块]撤销commit2：[代码块]查看reflog找回丢失的提交：[代码块]找到之前的提交哈希并恢复：[代码块][链接]git标签如果你达到一个重要的阶段，并希望永远记住提交的快照，你可以使用gittag给它打上标签。git标签（tag）用于给仓库中的特定提交点加上标记，通常用于发布版本（如v1.0,v2.0）。比如说，我们想为我们的runoob项目发布一个“1.0”版本，我们可以用gittag-av1.0命令给最新一次提交打上（head）“v1.0”的标签。\-a\选项意为“创建一个带注解的标签”，不用-a**选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解，我们推荐一直创建带注解的标签。标签语法格式：[代码块]例如：[代码块]-a选项可以添加注解：[代码块]当你执行gittag-a命令时，git会打开你的编辑器，让你写一句标签注解，就像你给提交写注解一样。现在，注意当我们执行gitlog—decorate时，我们可以看到我们的标签了：[代码块]如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。例如，假设我们发布了提交85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。我们现在也可以：[代码块]如果我们要查看所有标签可以使用以下命令：[代码块][链接]推送标签到远程仓库默认情况下，gitpush不会推送标签，你需要显式地推送标签。[代码块]推送所有标签：[代码块][链接]删除轻量标签本地删除：[代码块]远程删除：[代码块][链接]附注标签附注标签存储了创建者的名字、电子邮件、日期，并且可以包含标签信息。附注标签更为正式，适用于需要额外元数据的场景。创建附注标签语法：[代码块]例如：[代码块]pgp签名标签命令：[代码块]查看标签信息：[代码块][链接]实例以下是一个综合示例，演示如何创建、查看、推送和删除标签。创建轻量标签和附注标签：[代码块]查看标签和标签信息：[代码块]推送标签到远程仓库：[代码块][链接]删除标签本地删除：[代码块]远程删除：[代码块][链接]gitflowgitflow是一种基于git的分支模型，旨在帮助团队更好地管理和发布软件。gitflow由vincentdriessen在2010年提出，并通过一套标准的分支命名和工作流程，使开发、测试和发布过程更加有序和高效。gitflow主要由以下几类分支组成：master、develop、feature、release、hotfix。[链接]gitflow安装[链接]linuxdebian/ubuntu:[代码块]fedora:[代码块][链接]macos在macos上，你可以使用homebrew来安装gitflow:[代码块][链接]源码安装如果你的发行版的包管理器中没有gitflow，你也可以从源代码进行安装：[代码块]安装完成后，你可以通过以下命令验证gitflow是否成功安装：[代码块][链接]windows在windows上，你可以通过以下方式安装gitflow：使用gitforwindows:gitforwindows包含了gitflow。你可以从[链接]安装git，然后使用gitbash来使用gitflow。使用scoop:如果你使用scoop包管理工具，可以通过以下命令安装gitflow：[代码块]使用chocolatey:如果你使用chocolatey包管理工具，可以通过以下命令安装gitflow：[代码块][链接]gitflow分支模型master分支：永远保持稳定和可发布的状态。每次发布一个新的版本时，都会从develop分支合并到master分支。develop分支：用于集成所有的开发分支。代表了最新的开发进度。功能分支、发布分支和修复分支都从这里分支出去，最终合并回这里。feature分支：用于开发新功能。从develop分支创建，开发完成后合并回develop分支。命名规范：feature/feature-name。release分支：用于准备新版本的发布。从develop分支创建，进行最后的测试和修复，然后合并回develop和master分支，并打上版本标签。命名规范：release/release-name。hotfix分支：用于修复紧急问题。从master分支创建，修复完成后合并回master和develop分支，并打上版本标签。命名规范：hotfix/hotfix-name。[图片][链接]分支操作原理master分支上的每个commit应打上tag，develop分支基于master创建。feature分支完成后合并回develop分支，并通常删除该分支。release分支基于develop创建，用于测试和修复bug，发布后合并回master和develop，并打tag标记版本号。hotfix分支基于master创建，完成后合并回master和develop，并打tag1。[链接]gitflow命令示例开始feature分支：gitflowfeaturestartmyfeature完成feature分支：gitflowfeaturefinishmyfeature开始release分支：gitflowreleasestartrelease[base]完成release分支：合并到master和develop，打tag，删除release分支。开始hotfix分支：gitflowhotfixstarthotfix[base]完成hotfix分支：合并到master和develop，打tag，删除hotfix分支。[链接]gitflow工作流程[链接]1.初始化gitflow首先，在项目中初始化gitflow。可以使用gitflow插件（例如git-flow）来简化操作。[代码块]初始化时，你需要设置分支命名规则和默认分支。[链接]2.创建功能分支当开始开发一个新功能时，从develop分支创建一个功能分支。[代码块]完成开发后，将功能分支合并回develop分支，并删除功能分支。[代码块][链接]3.创建发布分支当准备发布一个新版本时，从develop分支创建一个发布分支。[代码块]在发布分支上进行最后的测试和修复，准备好发布后，将发布分支合并回develop和master分支，并打上版本标签。[代码块][链接]4.创建修复分支当发现需要紧急修复的问题时，从master分支创建一个修复分支。[代码块]修复完成后，将修复分支合并回master和develop分支，并打上版本标签。[代码块][链接]实例操作以下是一个实际使用gitflow的综合实例。初始化gitflow：[代码块]创建和完成功能分支：[代码块]创建和完成发布分支：[代码块]创建和完成修复分支：[代码块][链接]优点和缺点优点明确的分支模型：清晰的分支命名和使用规则，使得开发过程井然有序。隔离开发和发布：开发和发布过程分离，减少了开发中的不确定性对发布的影响。版本管理：每次发布和修复都会打上版本标签，方便回溯和管理。缺点复杂性：对于小型团队或简单项目，gitflow的分支模型可能显得过于复杂。频繁的合并：在大型团队中，频繁的分支合并可能导致合并冲突增加。gitflow是一种结构化的分支管理模型，通过定义明确的分支和工作流程，帮助团队更好地管理软件开发和发布过程。虽然它增加了一定的复杂性，但对于大型项目和团队协作，gitflow提供了强大的支持和管理能力。[链接]git进阶操作在掌握了git的基础操作之后，进阶操作可以帮助你更高效地管理和优化你的代码库。以下是一些常见的进阶操作及其详细说明：交互式暂存：逐块选择要暂存的更改，精细控制提交内容。gitstash：临时保存工作进度，方便切换任务。gitrebase：将一个分支上的更改移到另一个分支之上，保持提交历史线性。gitcherry-pick：选择特定提交并应用到当前分支。[链接]1、交互式暂存（interactivestaging）gitadd命令可以选择性地将文件或文件的一部分添加到暂存区，这在处理复杂更改时非常有用。使用gitadd-p：逐块选择要暂存的更改。[代码块]执行此命令后，git会逐块显示文件的更改，你可以选择是否暂存每个块。常用选项包括：y：暂存当前块n：跳过当前块s：拆分当前块e：手动编辑当前块q：退出暂存[链接]2、gitstash：临时保存工作进度gitstash命令允许你临时保存当前工作目录的更改，以便你可以切换到其他分支或处理其他任务。保存当前工作进度：[代码块]查看存储的进度：[代码块]应用最近一次存储的进度：[代码块]应用并删除最近一次存储的进度：[代码块]删除特定存储：[代码块]清空所有存储：[代码块][链接]3、gitrebase：变基gitrebase命令用于将一个分支上的更改移到另一个分支之上。它可以帮助保持提交历史的线性，减少合并时的冲突。变基当前分支到指定分支：[代码块]例如，将当前分支变基到main分支：[代码块]交互式变基：[代码块]交互式变基允许你在变基过程中编辑、删除或合并提交。常用选项包括：pick：保留提交reword：修改提交信息edit：编辑提交squash：将当前提交与前一个提交合并fixup：将当前提交与前一个提交合并，不保留提交信息drop：删除提交[链接]4、gitcherry-pick：拣选提交gitcherry-pick命令允许你选择特定的提交并将其应用到当前分支。它在需要从一个分支移植特定更改到另一个分支时非常有用。拣选提交：[代码块]例如，将abc123提交应用到当前分支：[代码块]处理拣选冲突：如果拣选过程中出现冲突，解决冲突后使用gitcherry-pick--continue继续拣选。[链接]示例操作以下是一个综合示例，展示了如何使用这些进阶操作：交互式暂存：[代码块]保存工作进度：[代码块]查看存储的进度：[代码块]应用存储的进度：[代码块]变基当前分支到main分支：[代码块]交互式变基，编辑提交历史：[代码块]编辑提交历史，如合并和重命名提交。拣选feature分支上的特定提交到main分支：[代码块]]]></content>
        
        
        <categories>
            
            <category> 环境搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>SpringCloud微服务项目</title>
        <link href="/posts/6ed5eebe.html"/>
        <url>/posts/6ed5eebe.html</url>
        <cover>https://tse4-mm.cn.bing.net/th/id/OIP-C.oIn0fJel0mQ1k1qKb-pEKQAAAA?rs=1&amp;pid=ImgDetMain</cover>
        <date>Mon Sep 23 2024 16:01:27 GMT+0800</date>
        
        <content type="html"><![CDATA[[链接]技术[链接]1.前端项目采用vue3+ts+elementplus[链接]2.后端项目结构采用插件化+扩展包形式结构解耦已于扩展[链接]3.后端代码风格严格遵守alibaba规范与项目统一配置的代码格式化[链接]4.分布式注册中心alibabanacos[链接]5.分布式配置中心alibabanacos[链接]6.服务网关springcloudgateway[链接]7.负载均衡springcloudloadbalancer[链接]8.rpc远程调用apachedubbo3.xopenfeign[链接]9.分布式限流熔断alibabasentinel[链接]10.分布式事务alibabaseata[链接]11.web容器采用undertow基于xnio的高性能容器[链接]12.权限认证sa-tokenspringsecurity[链接]13.权限注解sa-tokenspringsecurity[链接]14.关系型数据库mysqloraclepostgresqlsqlserver使用异构切换（支持mybatis-plus支持的所有数据库）[链接]15.缓存数据库redis[链接]16.redis客户端redisson[链接]17.缓存注解spring-cache[链接]18.orm框架mybatis-plus[链接]19.sql监控p6spy[链接]20.数据分页mybatis-plus分页插件[链接]21.数据权限采用mybatis-plus插件，自行分析拼接sql无感式过滤，只需要为mapper设置好注解条件支持多种自定义不限于部门角色[链接]22.数据脱敏注解+jackson[链接]23.多数据源框架dynamic-datasource[链接]24.多数据源事务dynamic-datasource[链接]25.数据库连接池hikaricp[链接]26.数据库主键采用雪花id基于时间戳的有序增长唯一id[链接]27.websocket协议基于spring封装的websocket协议，扩展token鉴权与分布式会话，不局限于单机[链接]28.sse推送springsse[链接]29.序列化jackson[链接]30.分布式幂等美团gtis[链接]31.分布式任务调度snailjobxxljob[链接]32.分布式日志中心elk[链接]33.分布式搜索引擎采用elasticsearch、easy-es以mybatis-plus方式操作elasticsearch[链接]34.分布式消息队列kafakarockketmqrabbitmq[链接]35.分布式消息总线采用springcloudbus实现事件总线跨服务通知，支持kafaka、rocketmq、rabbitm!q[链接]36.分库分表功能apachesharding-proxy[链接]37.文件存储采用minio分布式文件存储支持七牛、阿里、腾讯等一切支持s3协议的厂家[链接]38.短信sms[链接]39.邮件mail-api[链接]40.接口文档springdocjavadocswagger2knife4j[链接]41.校验框架validation[链接]42.excel框架alibabaeasyexcel[链接]43.工作流支持flowableactiviti[链接]44.工具类框架hutoollombok[链接]45.服务监控框架spring-admin[链接]46.全方位监控报警prometheusgrafana[链接]47.链路追踪apacheskywalking[链接]48.代码生成器只需设计好表结构一键生成所有crud代码页面降低80%的开发量，把精力投入业务涉及上框架为其适配mp、springdoc规范化代码，同时支持动态多数据源代码生成[链接]49.部署方式docker[链接]50.国际化]]></content>
        
        
        <categories>
            
            <category> 程序员 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java程序员 </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>Java架构师成长路径图</title>
        <link href="/posts/621998ca.html"/>
        <url>/posts/621998ca.html</url>
        <cover>https://www.javaweb.cc/zb_users/upload/editor/water/2022-12-01/63887b9fdbaf2.jpeg</cover>
        <date>Mon Sep 23 2024 09:36:27 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片][链接]java架构师之路架构师的内功主要包括三部分：判断力、执行力、创新力，简单解释如下：判断力：能够准确判断系统的复杂度在哪里，就像武侠高手一样，能够准确地看出对手的破绽和弱点。执行力：能够使用合适的方案去解决复杂度问题，就像武侠高手一样，能选择合适的招式或者方法打败对手。创新里：能够创造新的解决方案解决复杂度问题，就像武侠世界里，小一些的创新是创新招式，而武学宗师能够创立新的武学或者心法，例如张三丰创立太极拳一样。因此，要成为一个优秀的架构师，就需要不断提升自己这几方面的内功，而者三方面的能力来源于经验、视野、思考。经验：设计的系统越多，系统越复杂，架构师的内功也就越强，不管是成功的架构，还是失败的架构，不管是踩坑的经验，还是填坑的经验，都将成为架构师内功的一部分。视野：掌握的知识和技能越多、越深，架构师的内功也就越强，他山之石可以攻玉，站在巨人的肩膀上会看的更高更远。思考：经验和视野都是外部输入，类似于我们吃的食物，但光吃还不行，还要消化，将其变为我们自己的营养，这就是思考的作用，思考能将部分经验和视野中的模式、判断、选择、技巧等提炼出来为我们所用，思考也能促使我们产生新的创意和灵感。结合上面的分析，从程序员到架构师的成长之路，总的指导原则是：积累经验、拓展视野、深度思考。按照这个总的原则为指导，接下来我们看看从程序员到架构师的成长过程中，具体如何实践。程序员到架构师的技术成长之路分为几个典型的阶段：[代码块]虽然总的指导原则是一样的，但具体的实践方法有很大差别，如果在正确的姐u的那采取了错误的方法，可能会出现事倍功半的问题。[链接]第一步：工程师[链接]1.阶段描述成为一个合格的工程师需要1~3年时间，其典型特征是”在别人的指导下完成开发“，这里的”别人“主要是”高级工程师“或者”技术专家“，通常情况下，高级工程师或者技术专家负责需求分析和过程讨论、方案设计，工程师则负责编码实现，高级工程师或者技术专家会指导工程师进行编码实现。[链接]2.成长指导工程师阶段是最原始的基础技能积累阶段，主要积累基础知识，包括编程语言、编程工具、各类系统的基本使用。以java后端工程师为例，工程师阶段需要积累的经验和技能有：java的语法、基本数据结构的使用。eclipse、idea、maven、linux命令行等各种工具。数据库crud操作、缓存的基本使用等。业务系统的基本流程。工程师阶段最好的学习方法就是，找经典的书籍系统地学习，而不是遇到一个问题到网上搜搜然后就解决了事。以java为例，《java编程思想》《java核心技术》《tcp/ip协议》这类大部头，一定要完整地看一遍，即使里面很多内容当前工作暂时用不上。[链接]第二步：高级工程师[链接]1.阶段描述成为高级工程师需要2~5年，其典型特征是独立完成开发，包括需求分析、方案设计、编码实现，其中需求分析和方案设计已经包含了判断和选择，只是范围相对于来说小一些，更多是在已有架构下进行设计。以java后端工程师为例，高级工程师需要完成的工作包括：mysql数据库表如何设计，是设计成两个表还是三个表？是否要使用缓存，缓存的key和value如何设计，缓存的更新策略是什么？产品提出的需求是否合理？是否有更好的方式来满足？[链接]2.成长指导从普通工程师成长为高级工程师，主要需要积累方案设计经验，简单来说就是业务当前用到德相关技术德设计经验。以java后端工程师为例，包括：表设计经验、缓存设计经验、业务流程设计经验、接口设计经验等。当接到一个业务需求德时候，高级工程师柠檬狗组合这些设计经验，最终完成业务需求。高级工程师阶段相比于工程师阶段，有两个典型的差异：深度：如果说工程师是要求知道how，那高级工程师就要求知道why了。例如java的各种数据结构的实现原理，因为只有深入掌握了这些实现原理，才能对其优缺点和使用场景有深刻理解，这样在做具体方案设计的时候才能够选择合适的数据结构。理论：理论就是前人总结出来的成熟的设计经验，例如数据库设计的3个范式、面向对象的设计模式、solid设计原则、缓存设计理论(缓存穿透、缓存雪崩、缓存热点)等。针对技术深度，建议去进行系统地学习，包括看书和研究源码。例如研究java虚拟机可以看《深入理解java虚拟机》、研究mysql可以看《mysql技术内幕：innodb存储引擎》、研究memcache可以去看其源码。针对设计理论，由于涉及的点很多，没有一本书能够涵盖这么多的设计点，因此更多的是依靠自己去网上搜索资料学习、那么我们怎么知道哪些地方有设计理论呢？简单来说，就是假设每个环节都有设计理论，然后带着这种假设去搜索验证看看是否真的有很成熟的设计理念。[链接]第三步：技术专家[链接]1.阶段描述成长为技术专家需要4~8年时间，其典型的特征是”某个领域的专家“，通俗地讲，只要是这个领域的问题，技术专家都可以解决。例如java开发专家、php开发专家、android开发专家、ios开发专家、前端开发专家等等。通常情况下，”领域“的范围不能太小，例如我们可以说”java开发专家“，但不会说”java多线程专家“或”javajdbc专家“。技术专家与高级工程师的一个典型区别就是，高级工程师主要是在已有的架构框架下完成设计，而技术专家会根据需要修改、扩展、优化架构。例如，同样是java开发，高级工程师关注的是如何优化mysql的查询性能，而技术专家就会考虑引入elasticsearch来完成搜索。[链接]2.成长指导从高级工程师成长为技术专家，主要需要拓展技术宽度，因为一个领域必然会涉及众多的技术面。以java后端开发为例，要成为一个java开发专家，需要掌握java多线程、jdbc、java虚拟机、面向对象、设计模式、netty、elasrucsearch、memcache、redis、mysql等众多技术。常见的拓展技术宽度的方法有：学习业界成熟的开源方案，例如，java开发可以去学习redis、memcache、netty等，android开发可以去研究retrofit、fresco、okhttp等。研究业界的经验分享，例如bat、fang等大公司的经验，可以通过参加技术大会等方式去近距离了解。需要注意的是，拓展技术宽度并不意味着仅仅只是知道一个技术名词，而是要深入去理解每个技术的原理、优缺点、应用场景，否则就会成为传说中的“ppt技术专家”。例如，以java开发为例，知道netty是个高性能网络库是远远不够的，还需要学习netty的原理，以及具体如何使用netty来开发高性能系统。[链接]第四步：初级架构师[链接]1.阶段描述成长为初级架构师需要5~10年，其典型特征就是能够独立完成一个系统的设计，可以是从0到1设计一个新系统，也可以是将架构从1.0重构到2.0。初级架构师负责的系统复杂度相对来说不高，例如后台管理系统、某个业务下的子系统、100万pv量级的网站等。初级架构师和技术专家的典型区别是：架构师是基于完善的架构设计方法论的指导来进行架构设计，而技术专家更多的是基于经验进行架构设计。简单来说，即使是同样一个方案，初级架构师能够清晰地阐述架构设计的理由和原因，而技术专家可能就是因为自己曾经这样做过，或者看别人这样做过而选择设计方案。但在实践工作中，技术专家和初级架构师的区别并不是很明显，事实上很多技术专家其实就承担了初级架构师的角色，因为在系统复杂度相对不高的情况下，架构设计的难度不高，用不同的备选方案最终都能够较好的完成系统设计。例如，设计一个日pv100万的网站，mysql+memcache+springboot可以很好地完成，mongodb+redis+nginx+php-fpm也可以很好地完成，备选方案设计和选择并不太难，更多的是看团队熟悉哪个技术。[链接]2.成长指导从技术专家成长为初级架构师，最主要的是形成自己的架构设计方法论，架构设计专栏其实就是为了讲述完整的架构设计方法论，包括架构设计目的、架构设计原则、架构设计步骤、架构设计模式等，类似的架构设计方法论还有《恰如其分的软件架构：风险驱动的设计方法》和《领域驱动设计》等。要形成自己的架构设计方法论，主要手段有：系统学习架构设计方法论，包括订阅专栏或者阅读书籍等。深入研究成熟开源系统的架构设计，这个手段在技术专家阶段也会用到，但关注点不一样，同样是研究开源系统，技术专家阶段聚焦于如何更好地应用开源项目；初级架构师阶段聚焦于学习其架构设计原理和理想，例如kafaka的文档中就有关于消息队列架构设计的分析和取舍。结合架构设计方法论，分析和总结自己团队甚至是公司的各种系统的架构设计优缺点，尝试思考架构重构方案。如果在这个基础上真的能够推动架构重构，那就更好了，既能够实践自己的架构设计方法论，同时积累经验，有能够展现自己的技术实力，拿到结果。[链接]第五步：中级架构师[链接]1.阶段描述成长为中级架构师需要8年以上时间，其典型特征是能够完成复杂系统的架构设计，包含高性能、高可用、可扩展、海量存储等复杂系统，例如设计一个和kafaka性能匹敌的消息队列系统，将业务改造为异地多活，设计一个总共100人参与开发的业务系统等，中级架构师与初级架构师的典型区别在于系统的复杂度不同，中级架构师面对的系统复杂度要高于初级架构师。以开源项目为例，初级架构师可能引入某个开源项目就可以完成架构设计，而中级架构师可能发现其实没有哪个开源项目是合适的，而需要自己开发一个全新的项目，事实上很多开源项目就是这样诞生出来的，[链接]2.成长指导从初级架构师成长为中级架构师，最关键的是技术深度和技术理论的积累，例如：技术理论：cap、base是异地多活的设计理论基础，paxos是分布式一致性的基础算法、2pc、3pc是分布式事务的基础算法等。技术深度：kafaka用磁盘存储还能够做到高效是因为磁盘顺序写；disruptor高性能是结合cpu预读取机制、缓存行、无锁设计等基础技术；storm的高效异或确认机制；flink的分布式快照算法等。疑问：这些技术理论和技术深度的事情不应该是高级工程师阶段或者技术专家阶段就应该积累的么？为何到了中级架构师阶段反而是成长的关键呢？主要原因在于高级工程师或者技术专家阶段即使去学习这些技术，实际上也比较难理解透彻，更加难以有机会去应用，更多的时候只是为了这个技术点而已；而到了中级架构师阶段，面对高度复杂的系统，很多时候就是几个关键技术细节决定整个架构设计的成败，或者某个设计方案理论上就是不可行的，如果不深刻理解理论和相关的关键技术点，很难设计优秀的架构。[链接]第六步：高级架构师[链接]1.阶段描述成长为高级架构师需要10年以上的时间，其典型特征是创造新的架构模式，例如：谷歌大数据论文，创造了分布式存储架构、分布式计算mapreduce架构、列式存储架构，开创了大数据时代。在有mapreduce分布式u计算架构背景下，storm有创造了流式计算架构。在虚拟机很成熟的背景下，docker创造了容器化的技术潮流。高级架构师与中级架构师相比，典型区别在于创造性，高级架构师能够创造新的架构模式，开创新的技术潮流。[链接]2.成长指导参考技术界：足够复杂的业务场景：例如谷歌的大数据、阿里的双十一、facebook的海量用户等，业务场景越复杂，给技术带来的挑战更大，更有可能产生创造性的技术突破。足够强大的技术团队：绝大部分创造性的架构都来源于公司，或者知名的研究机构；灭有技术实力支撑，想突破也是心有余而力不足。不满足于现状的态度：例如虚拟机很成熟但是资源占用太多，所以发明docker；mapreduce难以做到实时运算，所以创造storm流式运算。尊重技术价值的文化：创造性的东西往往需要投入大量的人力和时间，而且刚开始一般都不会很成熟，如果完全结果导向、kpi导向，创新技术很可能在萌芽阶段就被否定。[链接]学习线路图[链接]（一）微服务[图片][链接]（二）分布式[图片][链接]（三）源码分析[图片][链接]（四）多线程并发[图片][链接]（五）工程化[图片][链接]（六）性能优化[图片][链接]（七）电商项目[图片]]]></content>
        
        
        <categories>
            
            <category> 程序员 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java程序员 </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>SQL使用教程</title>
        <link href="/posts/5d06cb2d.html"/>
        <url>/posts/5d06cb2d.html</url>
        <cover>https://wallpaperaccess.com/full/2138094.jpg</cover>
        <date>Fri Sep 20 2024 14:15:27 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片][链接]sql教程sql(structuredquerylanguage，结构化查询语言)是一种用于管理和操作关系型数据库的标准化编程语言。在线测试工具：[链接][链接]sql简介sql（structuredquerylanguage，结构化查询语言）是用于管理关系数据库管理系统（rdbms）。sql通过一系列的语句和命令来执行数据定义、数据查询、数据操作和数据控制等功能，包括数据插入、查询、更新和删除，数据库模式创建和修改，以及数据访问控制。[链接]sql是什么？sql值结构化查询语言，全称是structuredquerylanguagesql让你可以访问和处理数据库，包括数据插入、查询、更新和删除sql语言采用英语关键词，使其易读易写sql有国际标准化组织(iso)和美国国家标准协会(ansi)标准化sql提供了丰富的操作数据的功能，从简单的查询到复杂的数据库管理操作[链接]sql能做什么？sql面向数据库执行查询sql可以从数据库取回数据sql可在数据库中插入新的记录sql可更新数据库中的数据sql可创建新数据库sql可在数据库中创建新表sql可在数据库中创建存储过程sql可在数据库中创建视图sql可设置表、存储过程和视图的权限[链接]sql是一种标准-但是…虽然sql是一门ansi（americannationalstandardsinstitute美国国家标准化组织）标准的计算机语言，但是任然存在着许多不同版本的sql语言。然而，为了与ansi标准相兼容，他们必须以相似的方式共同地来支持一些主要的命令（比如select、update、delete、insert、where等等）。💡注释：除了sql标准外，大部分sql数据库都拥有它们自己的专有扩展！[链接]在网站中使用sql要创建一个显示数据库中数据的网站：rdbms数据库程序（比如msaccess、sqlserver、mysql）使用服务器端脚本语言，比如php或asp使用sql来获取您想要的数据使用html/css[链接]rdbmsrdbms指关系型数据库管理系统，全称relationaldatabasemanagementsystem。rdbms是sql的基础，同样也是所有现代数据库系统的基础，比如mssqlserver、ibmdb2、oracle、mysql以及microsoftaccess。rdbms中的数据存储在被称为表的数据库对象中。表是相关的数据项的集合，它由列和行组成。[链接]sql发展历史以下是sql发展历史的关键节点：[链接]1970s:起源与早期发展1970年：埃德加·科德（edgarf.codd）发表了《arelationalmodelofdataforlargeshareddatabanks》论文，提出了关系数据库的概念，为sql的发展奠定了理论基础。1973年-1974年：ibm的研究人员donaldd.chamberlin和raymondf.boyce在科德的理论基础上开发了一种名为sequel（structuredenglishquerylanguage）的语言，用于操作和管理ibm的systemr关系数据库。1976年：sequel更名为sql（structuredquerylanguage）。[链接]1980s:标准化与商业化1981年：ibm推出了商用关系数据库系统sql/ds（databasesystem）和db2（database2）。1986年：美国国家标准协会（ansi）发布了第一个sql标准ansisql-86（sql-87）。1987年：国际标准化组织（iso）也采纳了ansisql-86作为国际标准。[链接]1990s:扩展与改进1992年：发布了sql-92（sql2）标准，显著扩展了sql语言的功能，包括对新数据类型、嵌套查询和连接的支持。1999年：发布了sql:1999（sql3）标准，引入了对象关系数据库（ordbms）特性、递归查询、触发器和用户定义函数。[链接]2000s:持续演进与新特性2003年：发布了sql:2003标准，引入了xml相关特性和窗口函数。2006年：发布了sql:2006标准，主要增强了对xml的支持。2008年：发布了sql:2008标准，进一步改进了语法和性能优化。[链接]2010s:新功能与大数据支持2011年：发布了sql:2011标准，增加了对时间数据类型和时间旅行（temporaldata）的支持。2016年：发布了sql:2016标准，引入了json数据类型和相关操作函数，适应了nosql数据库和大数据处理需求。[链接]2020s:现代化与标准更新2023年：最新的sql标准持续改进，增加了对更现代化的数据库需求和特性的支持。[链接]总结sql从一种基于关系模型的查询语言发展成为现代数据库管理的核心语言，其标准在不断演进和扩展。各大数据库管理系统（如mysql、postgresql、sqlite、sqlserver、oracle等）在遵循sql标准的基础上，加入了自身的扩展和优化，使sql成为数据操作和管理的强大工具。sql的发展不仅体现了技术的进步，也反映了数据管理需求的变化和增长。[链接]sql语法sql（structuredquerylanguage）是一种用于管理和操作关系数据库的标准语言，包括数据查询、数据插入、数据更新、数据删除、数据库结构创建和修改等功能[图片][链接]数据库表一个数据库通常包含一个或多个表，每个表有一个名字标识（例如:”websites“），表包含带有数据的记录（行）。在本教程中，我们在mysql的runoob数据库中创建了websites表，用于存储网站记录。我们可以通过以下命令查看“websites”表的数据：[代码块]解析userunoob;命令用于选择数据库。setnamesutf8;命令用于设置使用的字符集。select*fromwebsites;读取数据表的信息。上面的表包含五条记录（每一条对应一个网站信息）和5个列（id、name、url、alexa和country）。[链接]sql语句你需要在数据库上执行的大部分工作都由sql语句完成。下面的sql语句从websites表中选取所有记录：实例[代码块][链接]请记住…sql对大小写不敏感：select和select是相同的[链接]sql语句后面加分号?某些数据库系统要求在每条sql语句的末端使用分号。分号是在数据库系统中分隔每条sql语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的sql语句。[链接]一些重要的sql命令select-从数据库中提取数据update-更新数据库中的数据delete-从数据库中删除数据insertinto-向数据库中插入新数据createdatabase-创建新数据库alterdatabase-修改数据库droptable-删除表createindex-创建索引（搜索值）dropindex-删除索引以下是一些常用的sql语句和语法：select：用于从数据库中查询数据[代码块]column_name(s)：要查询的列table_name：要查询的表condition：查询调价（可选）orderby：排序方式，asc表示升序，desc表示降序insertinto：用于向数据库插入新数据[代码块]table_name：要插入数据的表(column1,column2,...)：要插入数据的列(value1,value2,...)：对应列的值update：用于更新数据库表中的现有数据[代码块]table_name：要更新数据的表column1=value1,column2=value2,...：要更新的列及其新值condition：更新条件delete：用于从数据库表中删除数据[代码块]table_name：要删除数据的表condition：删除条件createtable：用于创建新的数据库表[代码块]table_name：要创建的表明column1,column2,...：表的列data_type：列的数据类型（如int、varchar等）constraint：列的约束（如primarykey、notnull等）aletertable：用于修改现有数据库表的结构[代码块]table_name：要修改的表column_name：要添加的列data_type：列的数据类型或：[代码块]column_name：要删除的列droptable：用于删除数据库表[代码块]table_name：要删除的表createindex：用于创建索引，以加快查询速度[代码块]index_name：索引的名称column_name：要索引的列dropindex：用于删除索引[代码块]index_name：要删除的索引名称table_name：索引所在的表where：用于指定筛选条件。[代码块]condition：筛选条件。orderby：用于对结果集进行排序[代码块]column_name：用于排序的列asc：升序（默认）desc：降序groupby：用于将结果集按一列或多列进行分组[代码块]aggregate_function(column_name)：聚合函数（如count、sum、avg等）having：用于对分组后的结果集进行筛选[代码块]condition：筛选条件join：用于将两个或多个表的记录结合起来[代码块]join:可以是innerjoin、leftjoin、rightjoin或fulljoin。distinct：用于返回唯一不同的值。[代码块]column_name(s)：要查询的列。[链接]sqlselectselect语句用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。[链接]sqlselect语法[代码块]与[代码块]参数说明：column1,column2,...：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。table_name：要查询的表名称。*：通配符，表示选择表中的所有列。[链接]演示数据库下面是选自“websites“表的数据：[代码块][链接]selectcolumn实例下面的sql语句从websites表中选取name和country列：实例：[代码块]输出结果：[图片][链接]select*实例下面的sql语句从websites表中选取所有列：实例：[代码块]输出结果：[图片][链接]sqlselectdistinctselectdistinct语句用于返回唯一不同的值。在表中，一个列可能包含多个重复值，有时你也许希望仅仅列出不同（distinct）的值。distinct关键词用于返回唯一不同的值。[链接]sqlselectdistinct语法[代码块]参数说明：column1,column2,...：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。table_name：要查询的表名称。[链接]演示数据库下面是选自“websites“表的数据：[代码块][链接]selectdistinct实例下面的sql语句仅从websites表的country列中选取唯一不同的值，也就是去掉contry列的重复值：实例：[代码块]输出结果：[图片][链接]sqlwherewhere子句用于过滤记录[链接]sqlwhere子句where子句用于提取那些满足指定条件的记录。[链接]sqlwhere语法[代码块]参数说明：column1,column2,...：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。table_name：要查询的表名称。[链接]演示数据库下面是选自“websites“表的数据：[代码块][链接]where子句实例下面的sql语句从“websites”表中选取国家为“cn”的所有网站：实例：[代码块]输出结果：[图片][链接]文本字段vs.数值字段sql使用单引号来环绕文本值（大部分数据库系统也接受双引号）在上个实例中‘cn’文本字段使用了单引号。如果是数值字段，请不要使用引号。实例：[代码块]输出结果：[图片][链接]where子句中的运算符下面的运算符可以在where子句中使用：运算符描述=等于&lt;&gt;不等于。注释：在sql的一些版本中，该操作符可被写成!=&gt;大于&lt;小于&gt;=大于等于&lt;=小于等于between在某个范围内like搜索某种模式in指定针对某个列的多个可能值[链接]sqland&amp;orand&amp;or运算符用于基于一个以上的条件对记录进行过滤。[链接]sqland&amp;or运算符如果第一个条件和第二个条件都成立，则and运算符显示一条记录。如果第一个条件和第二个条件只要有一个成立，则or运算符显示一条记录。[链接]演示数据库下面是选自“websites“表的数据：[代码块][链接]and运算符实例下面的sql语句从websites表中选取国家为cn且alexa排名大于50的所有网站：实例：[代码块]输出结果：[图片][链接]or运算符实例下面的sql语句从websites表中选取国家为usa或者cn的所有客户：实例：[代码块]输出结果：[图片]结合and&amp;or可以把and和or结合起来（使用圆括号来组成复杂的表达式）下面的sql语句从websites表中选取alexa排名大于15且国家为cn或usa的所有网站：实例：[代码块]输出结果：[图片][链接]sqlorderbyorderby关键字用于对结果集进行排序。[链接]sqlorderby关键字orderby关键字用于对于结果集按照一个列或者多个列进行排序。orderby关键字默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，你可以使用desc关键字。[链接]sqlorderby语法[代码块]column1,column2,...：要排序的字段名称，可以为多个字段asc：表示按升序排序desc：表示按降序排序[链接]演示数据库下面是选自“websites“表的数据：[代码块][链接]orderby实例下面的sql语句从websites表中选取所有网站，并按照alexa列排序：实例：[代码块]输出结果：[图片][链接]orderbydesc实例下面的sql语句从websites表中选取所有网站，并按照alexa列降序排序：实例：[代码块]输出结果：[图片][链接]orderby多列下面的sql语句从websites表中选取所有网站，并且按照country和alexa列排序：实例：[代码块]输出结果：[图片][链接]sqlinsertintoinsertinto语句用于向表中插入新记录[链接]sqlinsertinto语法insertinto语句有两种可以编写形式。第一种形式无需指定要插入数据的列名，值需要提供被插入的值即可：[代码块]第二种形式需要指定列名及被插入的值：[代码块]参数说明：table_name：需要插入新纪录的表名column1,column2,column3,..：需要插入的字段名value1,value2,value3,...：需要插入的字段值。[链接]演示数据库下面是选自“websites“表的数据：[代码块]insertinto实例假设我们要向websites表中插入一个新列我们可以使用下面的sql语句实例：[代码块]输出结果：[图片]💡你是否注意到，我们没有向id字段插入任何数字？id列是自动更新的，表中的每条记录都有一个唯一的数字[链接]在指定的列插入数据我们也可以在指定的列插入数据下面的sql语句将插入一个新行，但只是在name、url和country列插入数据(id字段会自动更新)实例：[代码块]输出结果：[图片][链接]sqlupdateupdate语句用于更新表中的记录[链接]sqlupdate语法[代码块]参数说明：table_name：要修改的表的名称column1,column2,...：要修改的字段名称，可以为多个字段value1,value2,...：要修改的值，可以为多个值condition：修改条件，用于指定哪些数据要修改💡请注意sqlupdate语句中的where子句！where子句规定哪条记录或者哪些记录需要更新。如果你省略了where子句，所有的记录都将被更新！[链接]演示数据库下面是选自“websites“表的数据：[代码块][链接]sqlupdate实例假设我们要把菜鸟教程的alexa排名更新为5000，country改为usa我们使用下面的sql语句实例：[代码块]输出结果：[图片][链接]update警告！在更新记录时要格外小心！在上面的实例中，如果我们省略了where子句，如下所示：[代码块]执行以上代码会将websites表中所有数据的alexa改为5000，country改为usa执行没有where子句的update要慎重，再慎重。[链接]sqldeletedelete语句用于删除表中的记录sqldelete语法[代码块]参数说明：table_name：要删除的表的名称condition：删除条件，用于指定哪些数据要删除💡请注意sqldelete语句中的where子句！where子句规定哪条记录或者哪些记录需要删除，如果你省略了where子句，所有的记录都将被删除！[链接]演示数据库下面是选自“websites“表的数据：[代码块][链接]sqldelete实例假设我们要从websites表中删除网站名称为facebook且国家为usa的网站我们使用一下sql语句：实例：[代码块]输出结果：[图片][链接]删除所有数据你可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：[代码块]注释：在删除记录时要格外小心！因为你不能重来！[链接]sql高级教程[链接]sqlselecttopselecttop语句用于在sql中限制返回的结果集中的行数，它通常用于值需要查询前几行数据的情况，尤其在数据集非常大时，可]]></content>
        
        
        <categories>
            
            <category> 编程语法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>Docker使用</title>
        <link href="/posts/cd988ed5.html"/>
        <url>/posts/cd988ed5.html</url>
        <cover>https://laowangblog.com/wp-content/uploads/2020/09/docker.png</cover>
        <date>Wed Sep 18 2024 17:10:00 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片][链接]1.快速入门安装docker：[链接][链接]1.1.部署mysql传统安装mysql：搜索并下载mysql安装包上传至linux环境编译和配置环境安装docker安装mysql：[代码块]运行效果：[图片]mysql安装完毕，通过任意客户端工具即可连接mysql.执行命令后，docker回去自动搜索并下载mysql，然后自动运行mysql，并不需要我们插手，十分便捷。而且通过这种方式完全不需要考虑运行的操作系统环境，它不仅仅在centos系统，在ubuntu系统，macos系统，甚至是安装了wsl的windows系统下，都可以使用这条命令来安装mysql。要知道，不同操作系统下其安装包、运行环境是都不相同的！如果是手动安装，必须手动解决安装包不同、环境不同的、配置不同的问题！而使用docker，这些完全不用考虑。就是因为docker会自动搜索并下载mysql。注意：这里下载的不是安装包，而是镜像。镜像中不仅包含了mysql本身，还包含了其运行所需要的环境、配置、系统级函数库。因此它在运行时就有自己独立的环境，就可以跨系统运行，也不需要手动再次配置环境了。这套独立运行的隔离环境我们称为容器。说明：镜像：英文是image容器：英文是container因此，docker安装的过程，就是自动搜索并下载镜像，然后创建并运行容器的过程。docker会根据命令中的镜像名称自动搜索并下载镜像，那么问题来了，它是去哪里搜索和下载镜像的呢？这些镜像又是谁制作的呢？docker官方提供了一个专门管理、存储镜像的网站，并对外开放了镜像上传、下载的权利。docker官方提供了一些基础镜像，然后各大然间公司又在基础上，制作了自家的镜像软件，全部都存放在这个网站上，这个网站就成了docker镜像交流社区：[链接]基本上我们常用的各种软件都能在这个网站上找到，我们甚至可以自己制作镜像上传上去。像这种提供存储，管理docker镜像的服务器，被称为dockerregistry，可以翻译为镜像仓库。dockerhub网站时官方仓库，阿里云、华为云会提供一些第三方仓库，我们也可以搭建私有的镜像仓库。官方仓库在国外，下载速度较慢，一般我们都会使用第三方仓库提供的镜像加速功能，提高下载速度。在企业内部的机密项目，往往会采用私有镜像仓库。总之，镜像的来源有两种：基于官方基础镜像自己制作直接去dockerregistry下载总结一下：docker本身包含一个后台服务，我们可以利用docker命令告诉docker服务，帮助我们快速部署指定的应用。docker服务部署应用时，首先要去搜索并下载应用对应的镜像，然后根据镜像创建并允许容器，应用就部署完成了。如图所示：[图片][链接]1.2.命令解读[代码块]解读：dockerrun-d：创建并运行一个容器-d则时让容器以后台进程进行--namemysql：给容器起个名字叫mysql，也可以去别的-p3306:3306：设置多口映射容器是隔离环境，外界不可访问。但是可以将宿主机端口映射容器内到端口，当访问宿主机指定端口时，就是在访问容器内的端口了。容器内端口往往是由容器内的进程决定。例如mysql进行默认端口是3306，因此容器内端口一定是3306；而宿主机端口则可以任意指定，一般与容器内保持一致。格式：-p宿主机端口:容器内端口，示例中就是将宿主机的3306映射到容器内的3306端口-etz=asia/shanghai：配置容器内进行运行时的一些参数格式：-ekey=value,key和value都由容器内进程决定案例中tz=asia/shanghai是设置时区；mysql_root_password=123是设置mysql默认密码mysql：设置镜像名称，docker会根据这个名字搜索并下载镜像格式：repository:tag，例如mysql:8.0，其中repository可以理解为镜像名，tag是版本号在未指定tag的情况下，默认是最新版本，也就是mysql:latest镜像的名称不是随意的，而是要到dockerregistry中寻找，镜像运行时的配置也不是随意的，要参考镜像的帮助文档，这些在dockerhub网站或者软件的官方网站中都能找到。如果我们要安装其他软件，也可以到dockerregistry中寻找对应的镜像名称和版本，阅读相关配置即可。[链接]2.docker基础docker官方文档：[链接][链接]2.1.常见命令[链接][链接]2.1.1.常见命令介绍命令说明文档地址dockerpull拉取镜像[链接]dockerpush推送镜像到dockerregistry[链接]dockerimages查看本地镜像[链接]dockerrmi删除本地镜像[链接]dockerrun创建并运行容器（不能重复创建）[链接]dockerstop停止指定容器[链接]dockerstart启动指定容器[链接]dockerrestart重新启动容器[链接]dockerrm删除指定容器[链接]dockerps查看容器[链接]dockerlogs查看容器运行日志[链接]dockerexec进入容器[链接]dockersave保存镜像到本地压缩文件[链接]dockerload加载本地压缩文件到镜像[链接]dockerinspect查看容器详细信息[链接]用一幅图来表示这些命令的关系：[图片]补充：默认情况下，每次重启虚拟机我们都需要手动启动docker和docker中的容器。通过命令可以实现开机启动：[代码块][链接]2.1.2.演示以nginx为例：[代码块][链接]2.1.3.命令别名给常用的docker命令起别名，方便我们访问：[代码块]然后，执行命令使别名生效[代码块][链接]2.2.数据卷容器是隔离环境，容器内程序的文件、配置、运行时产生的容器都在容器内部，我们要读写容器内的文件非常不方便，问题思考：如果要升级mysql，需要销毁旧容器，那么旧数据岂不是跟着被销毁了？mysql、nginx容器运行后，如果我要修改其中的某些配置该怎么办？怎么让nginx代理静态资源？因此，容器提供程序的运行环境，但是程序运行产生的数据、程序运行依赖的配置都应该与容器解耦。[链接]2.2.1.什么是数据卷数据卷(volume)是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁。以nginx为例，我们知道nginx中有两个关键的目录：html：放置一些静态资源conf：放置配置文件如果我们要让nginx代理我们的静态资源，最好放到html目录；如果我们要修改nginx的配置，最好是找到conf下的nginx.conf文件但遗憾的是，容器运行的nginx所有的问及那都在容器内部。所以我们必须利用数据卷将两个目录与宿主机目录关联，方便我们操作。如图：[图片]在上图中：我们创建了两个数据卷：conf、htmlnginx容器内部的conf目录和html目录分别与两个数据卷关联。而数据卷conf和html分别指向了宿主机的/var/lib/docker/volumes/conf/_data目录和/var/lib/docker/volumes/html/_data目录这样以来，容器内的conf和html目录就与宿主机的conf和html目录关联起来，我们称为挂载。此时，我们操作宿主机的/var/lib/docker/volumes/html/_data就是在操作容器内的/usr/share/nginx/html/_data目录。只要我们将静态资源放入宿主机对应目录，就可以被nginx代理了。小提示：/var/lib/docker/volumes这个目录就是默认的存放所有容器数据卷的目录，其下再根据数据卷名称创建新目录，格式为/数据卷名/_data为什么不让容器目录直接指向宿主机目录呢？因为直接指向宿主机目录就与宿主机强耦合了，如果切换了环境，宿主机目录就可能发生改变。由于容器一旦创建，目录挂载就无法修改，这样容器就无法正常工作了。但是容器指向数据卷，一个逻辑名称，而数据卷再指向宿主机目录，就不存在强耦合。如果宿主机目录发生改变，只要改变数据卷与数组机目录之间的映射关系即可不过，我们由于数据卷目录比较深，不好寻找，通常我们也允许让容器直接与宿主机挂载而不使用数据卷[链接]2.2.2.数据卷命令命令说明文档地址dockervolumecreate创建数据卷[链接]dockervolumels查看所有数据卷[链接]dockervolumerm删除指定数据卷[链接]dockervolumeinspect查看某个数据卷的详情[链接]dockervolumeprune清除数据卷[链接]注意：容器与数据卷的挂载要在创建容器时配置，对于创建好的容器，是不能设置数据卷的。而且创建容器的过程中，数据卷会自动创建。演示一下nginx的html目录挂载：[代码块]演示一下mysql的匿名数据卷：[代码块]我们关注两部分内容，第一是.config.volumes部分：[代码块]可以发现这个容器声明了一个本地目录，需要挂载数据卷，但是数据卷未定义。这就是匿名卷。然后，我们再看结果中的.mounts部分：[代码块]可以发现，其中有几个关键属性：name：数据卷名称。由于定义容器未设置容器名，这里的就是匿名卷自动生成的名字，一串hash值。source：宿主机目录destination:容器内的目录上述配置是将容器内的/var/lib/mysql这个目录，与数据卷29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f挂载。于是在宿主机中就有了/var/lib/docker/volumes/29524ff09715d3688eae3f99803a2796558dbd00ca584a25a4bbc193ca82459f/_data这个目录。这就是匿名数据卷对应的目录，其使用方式与普通数据卷没有差别。接下来，可以查看该目录下的mysql的data文件：[代码块]注意：每一个不同的镜像，将来创建容器后内部有哪些目录可以挂载，可以参考dockerhub对应的页面[链接]2.2.3.挂载本地目录或文件可以发现，数据卷的目录结构较深，如果我们去操作数据卷目录会不太方便。在很多情况下，我们会直接将容器目录与宿主机指定目录挂载。挂载语法与数据卷类似：[代码块]注意：本地目录或文件必须以/或./开头，如果直接以名字开头，会被识别为数据卷名而非本地目录名。。例如：[代码块][链接]2.3.镜像前面我们一直在使用别人准备好的镜像，那如果我要部署一个java项目，把它打包为一个镜像该怎么做呢？[链接]2.3.1.镜像结构要想自己构建镜像，必须先了解镜像的结构。之前我们说过，镜像之所以能让我们快速跨操作系统部署应用而忽略其运行环境、配置，就是因为镜像中包含了程序运行需要的系统函数库、环境、配置、依赖。因此，自定义镜像本质就是依次准备好程序运行的基础环境、依赖、应用本身、运行配置等文件，并且打包而成。举个例子，我们要从0部署一个java应用，大概流程是这样：准备一个linux服务（centos或者ubuntu均可）安装并配置jdk上传jar包运行jar包那因此，我们打包镜像也是分成这么几步：准备linux运行环境（java项目并不需要完整的操作系统，仅仅是基础运行环境即可）安装并配置jdk拷贝jar包配置启动脚本上述步骤中的每一次操作其实都是在生产一些文件（系统运行环境、函数库、配置最终都是磁盘文件），所以镜像就是一堆文件的集合。但需要注意的是，镜像文件不是随意堆放的，而是按照操作的步骤分层叠加而成，每一层形成的文件都会单独打包并标记一个唯一id，称为layer（层）。这样，如果我们构建时用到的某些层其他人已经制作过，就可以直接拷贝使用这些层，而不用重复制作。例如，第一步中需要的linux运行环境，通用性就很强，所以docker官方就制作了这样的只包含linux运行环境的镜像。我们在制作java镜像时，就无需重复制作，直接使用docker官方提供的centos或ubuntu镜像作为基础镜像。然后再搭建其它层即可，这样逐层搭建，最终整个java项目的镜像结构如图所示：[图片][链接]2.3.2.dockerfile由于制作镜像的过程中，需要逐层处理和打包，比较复杂，所以docker就提供了自动打包镜像的功能。我们只需要将打包的过程，每一层要做的事情用固定的语法写下来，交给docker去执行即可。而这种记录镜像结构的文件就称为dockerfile，其对应的语法可以参考官方文档：[链接]其中的语法比较多，比较常用的有：指令说明示例from指定基础镜像fromcentos:6env设置环境变量，可在后面指令使用envkeyvaluecopy拷贝本地文件到镜像的指定目录copy./xx.jar/tmp/app.jarrun执行linux的shell命令，一般是安装过程的命令runyuminstallgccexpose指定容器运行时监听的端口，是给镜像使用者看的expose8080entrypoint镜像中应用的启动命令，容器运行时调用entrypointjava-jarxx.jar例如，要基于ubuntu镜像来构建一个java应用，其dockerfile内容如下：[代码块]同学们思考一下：以后我们会有很多很多java项目需要打包为镜像，他们都需要linux系统环境、jdk环境这两层，只有上面的3层不同（因为jar包不同）。如果每次制作java镜像都重复制作前两层镜像，是不是很麻烦。所以，就有人提供了基础的系统加jdk环境，我们在此基础上制作java镜像，就可以省去jdk的配置了：[代码块]是不是简单多了。[链接]2.3.3.构建镜像当dockerfile文件写好以后，就可以利用命令来构建镜像了准备好了一个demo项目及对应的dockerfile[图片]首先，我们将课前资料提供的docker-demo.jar包以及dockerfile拷贝到虚拟机的/root/demo目录：[图片]然后，执行命令，构建镜像：[代码块]命令说明：dockerbuild:就是构建一个docker镜像-tdocker-demo:1.0：-t参数是指定镜像的名称（repository和tag）.:最后的点是指构建时dockerfile所在路径，由于我们进入了demo目录，所以指定的是.代表当前目录，也可以直接指定dockerfile目录：[代码块]结果：[图片]查看镜像列表：[代码块]然后尝试运行该镜像：[代码块][链接]2.4.网络我们创建了一个java项目的容器，而java项目往往需要访问其它各种中间件，例如mysql、redis等。现在，我们的容器之间能否互相访问呢？我们来测试一下首先，我们查看下mysql容器的详细信息，重点关注其中的网络ip地址：[代码块]发现可以互联，没有问题。但是，容器的网络ip其实是一个虚拟的ip，其值并不固定与某一个容器绑定，如果我们在开发时写死某个ip，而在部署时很可能mysql容器的ip会发生变化，连接会失败。所以，我们必须借助于docker的网络功能来解决这个问题，官方文档：[链接]常见命令有：命令说明文档地址dockernetworkcreate创建一个网络[链接]dockernetworkls查看所有网络[链接]dockernetworkrm删除指定网络[链接]dockernetworkprune清除未使用的网络[链接]dockernetworkconnect使指定容器连接加入某网络[链接]dockernetworkdisconnect使指定容器连接离开某网络[链接]dockernetworkinspect查看网络详细信息[链接]教学演示：自定义网络[代码块]ok，现在无需记住ip地址也可以实现容器互联了。总结：在自定义网络中，可以给容器起多个别名，默认的别名是容器名本身在同一个自定义网络中的容器，可以通过别名互相访问]]></content>
        
        
        <categories>
            
            <category> SpringCloud </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>Redis安装说明</title>
        <link href="/posts/6b830637.html"/>
        <url>/posts/6b830637.html</url>
        <cover>https://files.lynchow.com/2022-04-22-redis.png</cover>
        <date>Thu Sep 12 2024 17:28:27 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片][链接]redis安装说明大多数企业都是基于linux服务器来部署项目，而且redis官方也没有提供windows版本的安装包。因此我们会基于linux系统来安装redis。此处选择的linux版本为centos7.redis的官方网站地址：[链接][链接]1.单机安装redis[链接]1.1安装redis依赖redis是基于c语言编写的，因此首先需要安装redis所需要的gcc依赖：[代码块][链接]1.2上传安装包并解压然后将课前资料提供的redis安装包上传到虚拟机的任意目录：[图片]例如，我放到了/usr/local/src目录：[图片]解压缩：[代码块]解压后：[图片]进入redis目录：[代码块]运行编译命令：[代码块]如果没有出错，应该就安装成功了。默认的安装路径是在/usr/local/bin目录下：[图片]该目录以及默认配置到环境变量，因此可以在任意目录下运行这些命令。其中：redis-cli：是redis提供的命令行客户端redis-server：是redis的服务端启动脚本redis-sentinel：是redis的哨兵启动脚本[链接]1.3.启动redis的启动方式有很多种，例如：默认启动指定配置启动开机自启[链接]1.3.1.默认启动安装完成后，在任意目录输入redis-server命令即可启动redis：[代码块]如图：[图片]这种启动属于前台启动，会阻塞整个会话窗口，窗口关闭或者按下ctrl+c则redis停止。不推荐使用。[链接]1.3.2.指定配置启动如果要让redis以后台方式启动，则必须修改redis配置文件，就在我们之前解压的redis安装包下（/usr/local/src/redis-6.2.6），名字叫redis.conf：[图片]我们先将这个配置文件备份一份：[代码块]然后修改redis.conf文件中的一些配置：[代码块]redis的其它常见配置：[代码块]启动redis：[代码块]停止服务：[代码块][链接]1.3.3.开机自启我们也可以通过配置来实现开机自启。首先，新建一个系统服务文件：[代码块]内容如下：[代码块]然后重载系统服务：[代码块]现在，我们可以用下面这组命令来操作redis了：[代码块]执行下面的命令，可以让redis开机自启：[代码块][链接]2.redis客户端安装完成redis，我们就可以操作redis，实现数据的crud了。这需要用到redis客户端，包括：命令行客户端图形化桌面客户端编程客户端[链接]2.1.redis命令行客户端redis安装完成后就自带了命令行客户端：redis-cli，使用方式如下：[代码块]其中常见的options有：-h127.0.0.1：指定要连接的redis节点的ip地址，默认是127.0.0.1-p6379：指定要连接的redis节点的端口，默认是6379-a123321：指定redis的访问密码其中的commonds就是redis的操作命令，例如：ping：与redis服务端做心跳测试，服务端正常会返回pong不指定commond时，会进入redis-cli的交互控制台：[图片][链接]2.2.图形化桌面客户端github上的大神编写了redis的图形化桌面客户端，地址：[链接]不过该仓库提供的是redisdesktopmanager的源码，并未提供windows安装包。在下面这个仓库可以找到安装包：[链接][图片][链接]2.2.1.安装在课前资料中可以找到redis的图形化桌面客户端：[图片]解压缩后，运行安装程序即可安装：[图片]此处略。安装完成后，在安装目录下找到rdm.exe文件：[图片]双击即可运行：[图片][链接]2.2.2.建立连接点击左上角的连接到redis服务器按钮：[图片]在弹出的窗口中填写redis服务信息：[图片]点击确定后，在左侧菜单会出现这个链接：[图片]点击即可建立连接了：[图片]redis默认有16个仓库，编号从0至15.通过配置文件可以设置仓库数量，但是不超过16，并且不能自定义仓库名称。如果是基于redis-cli连接redis服务，可以通过select命令来选择数据库：[代码块]]]></content>
        
        
        <categories>
            
            <category> 环境搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>VMware</title>
        <link href="/posts/545a6120.html"/>
        <url>/posts/545a6120.html</url>
        <cover>https://img.onlinedown.net/download/202011/130602-5faa1fba690d4.jpg</cover>
        <date>Thu Sep 12 2024 11:20:02 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片][链接]什么是虚拟机虚拟机是指软件模拟的具有完整硬件系统功能的，运行在一个完全隔离环境中的完整计算系统，在实体计算机中能够完成的工作，在虚拟机中都能够实现。[链接]vmware简介简而言之，[链接]（链接位于ibm.com外部）主要用于开发虚拟化软件。虚拟化软件会在计算机硬件上创建一个抽象层，从而能够将单台计算机的硬件要素（处理器、内存、存储等）分成多个虚拟计算机（通常称为虚拟机(vm)）。每个虚拟机都运行自己的操作系统(os)，其行为就像一台独立的计算机，而实际上它只是在一部分底层计算机硬件上运行。[链接]ⅰ大概介绍vmware虚拟机软件是一个虚拟pc软件，它可以让你在一台电脑上运行一个或多个操作系统。[链接]ⅱ详细介绍vmware是一款功能强大的桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试、部署新的应用程序的最佳解决方案。vmware可在一部实体机器上模拟完整的网络环境，以及可便于携带的虚拟机器，其更好的灵活性与先进的技术胜过了市面上其他的虚拟计算机软件。[链接]vmware下载[链接]ⅰ官网地址[链接][链接]ⅱ网盘下载打开浏览器搜索vmware下载，然后打开帖子，复制网盘下载。或者打开[链接]，进行搜索。[链接]vmware安装[图片]vmware安装，点击下一步[图片]接受协议，下一步[图片]自定义vmware安装位置，下一步[图片]勾选快捷方式，下一步[图片]安装vmware虚拟机，点击完成即可。[链接]vmware新建虚拟机①创建新的虚拟机[图片]②选择典型或自定义[图片]③安装系统驱动[图片]④下载linux镜像网易开源镜像站:[链接]阿里云官方镜像站:[链接]可选centos或unbtor[图片][图片]⑤配置信息[图片]⑥自定义名称和路径[图片]⑦设置磁盘[图片]⑧配置硬件[图片]⑨点击完成[图片]即可完成创建：[图片][链接]安装centos7接下来，我们启动刚刚创建的虚拟机，开始安装centos7系统：[图片]启动后需要选择安装菜单，将鼠标移入黑窗口中后，将无法再使用鼠标，需要按上下键选择菜单。选中installcentos7后按下回车：[图片]然后会提示我们按下enter键继续：[图片]过一会儿后，会进入语言选择菜单，这里可以使用鼠标选择。选择中文-简体中文，然后继续：[图片]接下来，会进入安装配置页面：[图片]鼠标向下滚动后，找到系统安装位置配置，点击：[图片]选择刚刚添加的磁盘，并点击完成：[图片]然后回到配置页面，这次点击《网络和主机名》：[图片]在网络页面做下面的几件事情：修改主机名为自己喜欢的主机名，不要出现中文和特殊字符，建议用localhost点击应用将网络连接打开点击配置，设置详细网络信息[图片]本机网络详细信息：[图片]点击配置按钮后，我们需要把网卡地址改为静态ip，这样可以避免每次启动虚拟机ip都变化。所有配置照搬你自己截图的网络信息填写：[图片]最后，点击完成按钮：[图片]回到配置界面后，点击开始安装：[图片]接下来需要设置root密码：[图片]填写你要使用的root密码，然后点击完成：[图片]接下来，耐心等待安装即可。[图片]等待安装完成后，点击重启：[图片]输入密码即可登录：[图片][图片]打开中端输入密码切换root用户：[图片]此时你要输入密码，不过需要注意的是密码是隐藏的，输入了也看不见。所以放心输入，完成后回车即可：[图片]测试网络是否通畅：[代码块]如果看到这样的结果代表网络畅通：[图片]默认ping命令会持续执行，按下ctrl+c后命令即可停止。[链接]设置虚拟机快照在虚拟机安装完成后，最好立刻设置一个快照，这样一旦将来虚拟机出现问题，可以快速恢复。我们先停止虚拟机，点击vmware顶部菜单中的暂停下拉选框，选择关闭客户机：[图片]接着，点击vmware菜单中的🔧按钮:[图片]然后在弹出的快照管理窗口中，点击拍摄快照，填写新的快照信息：[图片]快照拍摄完成了！而且我们可以在不同阶段拍摄多个不同快照作为备份，方便后期恢复数据。假如以后虚拟机文件受损，需要恢复到初始状态的话，可以选中要恢复的快照，点击转到即可：[图片]]]></content>
        
        
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VMware </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>MybatisPlus</title>
        <link href="/posts/8af9e237.html"/>
        <url>/posts/8af9e237.html</url>
        <cover>%09https://www.mulei.ltd/wp-content/uploads/2021/07/cover-mybatis-plus.png</cover>
        <date>Mon Sep 09 2024 17:39:20 GMT+0800</date>
        
        <content type="html"><![CDATA[[链接]mybatisplus简介在日常开发生活中，单表的crud功能代码重复度很高，也没什么难度，但是这部分代码的开发量往往却比较大，开发起来相当费时。因此，目前企业中会使用一些组件来简化crud开发工作，而国内，使用最多的一个组件就是mybatisplus。官方网站如下：[链接]mybatisplus不仅仅可以简化单表操作，而且还对mybatis进行了增强。可以让我们能够简单高效地进行开发。我们需要掌握的内容如下：能利用mybatisplus实现基本的crud使用条件构造器构建查询和更新语句掌握mybatisplus中常用的注解会使用mybatisplus处理枚举类、json类型字段会使用mybatisplus实现分页[链接]快速入门创建一个mybatisplus项目，并准备一些基础数据。[图片][链接]ⅰ环境准备①打开idea导入mybatisplus项目②打开navicat导入mp.sql文件[图片]③配置项目jdk版本[图片]④在application.yml文件中配置参数[代码块][链接]ⅱ快速开始引入mybatisplus依赖定义mapper[链接]①引入依赖mybatisplus提供了starter，实现了自动mybatis以及mybatisplus的自动装配功能，坐标如下：[代码块]该依赖包含了对mybatis的自动装配，因此不需要mybatis的starter。[代码块][链接]②定义mapper为了简化单表crud开发，mybatisplus已经提供了一个基础的basemapper接口来实现单表crud[代码块]因此我们只需要将自定义的mapper实现basemapper接口，就无需自己实现crud。[图片]代码如下：[代码块][链接]③测试新建测试类，进行curd测试：[代码块][链接]ⅲ常见注解在上述的案例中我们发现仅仅引入了依赖，继承了basemapper就能够使用mybatisplus。但是问题是：mybatisplus是怎么知道我们要查询的是哪张表呢？表中有哪些字段呢？其实在我们继承basemapper的时候，就给其指定了一个泛型：[图片]泛型中的userentity就是与数据库对应的po实体mybatisplus就是根据po实体的信息来推断出数据库表的信息，从而生成sql，默认情况是：mybatisplus会把po实体的类名驼峰转下划线作为表名mybatisplus会把po实体的所有变量名驼峰转下划线作为表的字段名，并根据变量类型推断字段类型mybatisplus会把名为id的字段作为主键但在很多情况下，默认的实现与我们的实际场景不符，因此mybatisplus提供了一些注解来让我们进行声明[链接]①@tablename描述：表名注解，标识实体类对应的表使用位置：实体类示例：[代码块]tablename的属性：属性类型必须指定默认值描述valuestring否“”表名schemastring否“”schemakeepglobalprefixboolean否false是否保持使用全局的tableprefix的值（当全局tableprefix生效时）resultmapstring否“”xml中resultmap的id（用于满足特定类型的实体类对象绑定）autoresultmapboolean否false是否自动构建resultmap并使用（如果设置resultmap则不会进行resultmap的自动构建与注入）excludepropertystring[]否{}需要排除的属性名@since3.3.1[链接]②@tableid描述：主键注解，标识实体类中的主键字段使用位置：实体类的主键字段示例：[代码块]tableid的属性：属性类型必须指定默认值描述valuestring否“”表名typeenum否idtype.none指定主键类型idtype支持的类型有：值描述auto数据库id自增none无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于input）inputinsert前自行set主键值assign_id分配id(主键类型为number(long和integer)或string)(since3.3.0),使用接口identifiergenerator的方法nextid(默认实现类为defaultidentifiergenerator雪花算法)assign_uuid分配uuid,主键类型为string(since3.3.0),使用接口identifiergenerator的方法nextuuid(默认default方法)id_worker分布式全局唯一id长整型类型(pleaseuseassign_id)uuid32位uuid字符串(pleaseuseassign_uuid)id_worker_str分布式全局唯一id字符串类型(pleaseuseassign_id)这里比较常见的有三种：auto：利用数据库的id自增长input：手动生成idassign_id：雪花算法生成long类型的全局唯一id，这是默认的id策略[链接]③@tablefield描述：普通字段的注解（与数据库字段匹配）使用位置：po实体的普通字段示例：[代码块]tablefield的属性：属性类型必填默认值描述valuestring否“”数据库字段值existboolean否true是否为数据库表字段conditionstring否“”字段where实体查询比较条件，有值设置则按设置的值为准，没有则为默认全局updatestring否“”字段updateset部分注入，例如：当在version字段上注解update=”%s+1”表示更新时会setversion=version+1（该属性优先级高于el属性）insertstrategyenum否fieldstrategy.default字段验证策略之insert:当insert操作时，该字段拼接insert语句时的策略updatestrategyenum否fieldstrategy.default字段验证策略之update:当更新操作时，该字段拼接set语句时的策略wherestrategyenum否fieldstrategy.default字段验证策略之where:表示该字段在拼接where条件时的策略fillenum否fieldfill.default字段自动填充策略selectboolean否true是否进行select查询keepglobalformatboolean否false是否保持使用全局的format进行处理jdbctypejdbctype否jdbctype.undefinedjdbc类型(该默认值不代表会按照该值生效)typehandlertypehander否类型处理器(该默认值不代表会按照该值生效)numericscalestring否“”指定小数点后保留的位数[链接]ⅳ常见配置[代码块]config-location：用于指定mybatis配置文件的路径mapper-locations：配置mapperxml文件所在的位置type-aliases-package：配置实体类所在的包名，mybatisplus会自动扫描并注册为别名global-config：全局配置configuration：自定义配置pagination：分页插件配置大多数的配置都是有默认值的，因此我们都无需配置，但还是有一些没有默认值的，例如：实体类的别名扫描包全局id类型[代码块]需要注意的是mybatisplus也支持手写sql的，而mapper文件的读取地址可以自己配置：[代码块]可以看到默认值是&quot;classpath*:/mapper/**/*.xml&quot;，也就是说我们需要把mapper.xml文件放在这个位置下被加载例如：[图片][链接]核心功能[链接]ⅰ条件构造器除了新增以外，修改、删除、查询的sql语句都需要指定where条件。因此basemapper中提供了了相关的方法除了支持id还支持更复杂的where条件。[图片]参数中的wrapper就是条件构造的抽象类，其下有很多默认实现，继承关系如下图所示：[图片]wrapper的子类abstractwrapper提供了where中所包含的所有条件构造方法：[图片]而querywrapper在abstractwrapper基础上拓展了一个select方法，用于指定查询字段：[代码块]而updatewrapper则在abstractwrapper基础上拓展了了一个set方法，用于指定sql中的set部分：[代码块][链接]①querywrapper无论是修改、更新、查询，都可以使用querywrapper来构建查询条件。查询：[代码块]更新：[代码块][链接]②updatewrapper[代码块][链接]③lambdaquerywrapper其中一种办法是基于变量的gettter方法结合反射技术。因此我们只要将条件对应的字段的gettter方法传递给mybatisplus，它就能计算出对应的变量名了。而传递方法可以使用jdk8中的方法引用和lambda表达式。因此mybatisplus又提供了一套基于lambda的wrapper，包含两个：lambdaquerywrapperlambdaupdatewrapper分别对应querywrapper和updatewrappe[代码块][链接]ⅱ自定义sqlmybatisplus提供了自定义sql功能，可以让我们先利用wrapper来构建查询条件，然后再结合mapper.xml来编写sql[链接]①基本用法先构建查询条件：[代码块]再在usermapper中定义sql：[代码块][链接]②多表关联理论上来说mybatisplus是单表操作不支持多表关联的，不过我们可以利用wrapper中自定义条件结合自定义sql来实现多表查询的效果。例如，我们要查出所有收获地址在北京并且用户id在1、2、4的用户如果是基于mybatis实现sql：[代码块]我们也可以使用自定义sql结合wrapper：先构建查询条件：[代码块]再在usermapper中自定义sql方法：[代码块]当然也可以在usermapper.xml中写sql：[代码块][链接]ⅲservice接口通用接口为iservice，默认实现为serviceimpl，其中封装方法为一下几类：save：新增remove：删除update：更新get：查询单个结果list：查询集合结果count：计数page：分页查询[链接]①crud[代码块]新增：save是新增单个元素savebatch是批量新增saveorupdate是根据id判断，如果数据存在就更新，不存在则新增saveorupdatebatch是批量的新增或修改删除：removebyid：根据id删除removebyids：根据id批量删除removebymap：根据map中的键值对为条件删除remove(wrapper&lt;t&gt;)：根据wrapper条件删除~~removebatchbyids~~：暂不支持修改：updatebyid：根据id修改update(wrapper&lt;t&gt;)：根据updatewrapper修改，wrapper中包含set和where部分update(t，wrapper&lt;t&gt;)：按照t内的数据修改与wrapper匹配到的数据updatebatchbyid：根据id批量修改get：getbyid：根据id查询1条数据getone(wrapper&lt;t&gt;)：根据wrapper查询1条数据getbasemapper：获取service内的basemapper实现，某些时候需要直接调用mapper内的自定义sql时可以用这个方法获取到mapperlist：listbyids：根据id批量查询list(wrapper&lt;t&gt;)：根据wrapper条件查询多条数据list()：查询所有count：count()：统计所有数量count(wrapper&lt;t&gt;)：统计符合wrapper条件的数据数量getbasemapper：当我们在service中要调用mapper中自定义sql时，就必须获取service对应的mapper，就可以通过这个方法[链接]②基本用法首先，定义iuserservice，继承iservice：[代码块]然后，编写userserviceimpl类，继承serviceimpl，实现userservice：[代码块]项目结构如下：[图片]接下来，我们快速实现下面4个接口：编号接口请求方式请求路径请求参数返回值1新增用户post/users用户表单实体无2删除用户delete/users/{id}用户id无3根据id查询用户get/users/{id}用户id用户vo4根据id批量查询get/users用户id集合用户vo集合为了方便测试，引入swagger-knife4j：依赖：[代码块]yml文件中swagger配置[代码块]usercontroller：[代码块]uservo：返回用户对象给前端[代码块]iuserservice：[代码块]userserviceimpl：[代码块]usermapper：[代码块]可以看到上述接口，通过引入在controller层就可以完成业务接口，但是为了能够更加规范，所以对于复杂的业务，我们任然会选择将业务功能放到service层去进行业务实现。[链接]③lambdaiservice中还提供了lambda方法来简化我们复杂的查询和更新功能。案例一：实现一个根据复杂条件查询用户的接口，查询条件如下：name：用户关键名称，可以为空status：用户状态，可以为空minbalance：最小余额，可以为空maxbalance：最大余额，可以为空首先定义查询实体，userquery：[代码块]接下来，在usercontroller中定义查询方法：[代码块]在组织查询的时候，我们加入username!=null这样的参数，表示只有当这个条件成立的时候才会添加到这个查询条件里，类似与mapper.xml文件中的&lt;if&gt;标签。这样就实现了动态查询效果。service中对lambdaquerywrapper和lambdaupdatewrapper的用法进一步做了简化，不需要使用new来创建wrapper，而是直接调用lambdaquery和lambdaupdate方法：lambdaquery：[代码块]可以发现lambdaquery方法中除了可以构建条件，还需要在链式编程的最后添加一个list()，这是在告诉mp我们的调用结果需要是一个list集合。这里不仅可以用list()，可选的方法有：.one()：最多1个结果.list()：返回集合结果.count()：返回计数结果lambdaupdate：[代码块][链接]④批量新增逐条插入：[代码块]耗时长速度慢[图片]批量插入：[代码块]耗时较短速度较快[图片]可以看到批处理后，比逐条新增的效率提高了10倍左右，性能还是不错的。不过我们查看mybatisplus源码：[代码块]可以发现其实mybatisplus的批处理是基于preparestatement的预编译模式，然后批量提交，最终在数据库执行时还是会有多条insert语句，逐条插入数据。[代码块]而如果想要得到最佳性能，最好将多条sql合并为一条：[代码块]该怎么做呢？mysql的客户端连接参数中，有一个rewritebatchedstatements，顾名思义，就是重写批处理statement语句。修改application.yml在jdbc的url后面添加参数&amp;rewritebatchedstatements=true：[代码块]再次测试插入10万条数据，可以发现速度有明显的提升：[图片]在clientpreparedstatement的executebatchinternal中，有判断rewritebatchedstatements值是否为true并重写sql的功能：最终，sql被重写了：[图片][链接]扩展功能[链接]ⅰ代码生成在使用mybatisplus以后，基础的mapper、servce、po代码相对固定，重复编写也比较麻烦。推荐利用mybatisx插件进行代码生成：[链接]①插件安装[图片][链接]②使用[链接]idea集成数据库：[图片][图片][链接]选择生成数据：[图片]点击右侧database展开连接数据库选择所需生成业务表，右键点击mybatisx-generator打开代码生成窗口[链接]配置代码生成：[图片][图片][链接]生成结果：[图片][链接]ⅱ静态工具有的时候service之间也会相互调用，为了避免出现循环依赖问题，mybatisplus提供了一个静态工具类：db，其中的一些静态方法与iservice中方法签名基本一致，也可以帮助我们实现crud功能：[代码块]示例：[代码块]需求：改造根据id查询用户接口，查询用户的同时返回用户收获地址列表：uservo：[代码块]添加一个地址列表的属性usercontroller：[代码块]需求：根据id批量查询用户，并查询出用户对应的所有地址[代码块][链接]ⅲ逻辑删除对于一些比较重要的数据，我们往往会采用逻辑删除的方式，而不是直接将其冲数据库中删除。在表中添加一个字段标记数据是否被删除当删除数据时把标记置为true查询时过滤掉标记为true的数据mybatisplus就添加了对逻辑删除的支持：注意，只有mybatisplus生成的sql语句才支持自动的逻辑删除，自定义sql需要自己手动处理逻辑删除。例如，给adress表添加逻辑删除字段：[代码块]adressentity：[代码块]application.yml：[代码块]方法与普通的方法一样，但是底层的逻辑已经改变了：[图片]查询：[代码块]会发现id为59的确实没有查询出来，而且sql中也对逻辑删除字段做了判断：[图片]综上，开启了逻辑删除功能以后，我们就可以像普通删除一样做crud，基本不用考虑代码逻辑问题。还是非常方便的。注意：逻辑删除本身也有自己的问题，比如：会导致数据库表垃圾数据越来越多，从而影响查询效率sql中全都需要对逻辑删除字段做判断，影响查询效率[链接]ⅳ通用枚举userentity中有一个用户状态[图片]像这种字段，我们一般会定义一个枚举，做业务判断的时候，就可以直接基于枚举比较，但是我们数据库采用的是int型，对应的po也是一个integer。因此业务操作时必须手动转换枚举和integer。但是mybatisplus提供了一个处理枚举类型的类型转换器，可以帮我们把枚举类型和数据库类型自动转换。[链接]①定义枚举定义一个用户状态枚举：[图片]代码如下：[代码块]然后将userentity类中的status字段改为userstatus类型：[图片]当然，要让mybatisplus处理枚举与数据库自动类型转换，我们必须要告诉mybatisplus，枚举中的哪个字段值作为数据库值。mybatisplus提供了@enumvalue来标记枚举属性[链接]②配置枚举处理器在application.yml中添加配置：[代码块]测试：[代码块]最终，查询出的user类的status字段会是枚举类型：[图片]同时，为了使页面查询结果也是枚举格式，我们需要修改uservo中的status属性并且，在userstatus枚举中通过@jsonvalue注解标记json序列化时展示的字段：[图片]最后，在页面查询，结果如下：[图片][链接]ⅴjson类型处理器数据库的user表中有一个info字段，是json类型：[图片]格式：[代码块]而目前userentity实体类中却是string类型：[图片]这样一来，我们要读取info中的属性时就非常不方便。如果要方便获取，info的类型最好是一个map或者实体类。而一旦我们把info改为对象类型，就需要在写入数据库时手动转为string，再读取数据库时，手动转换为对象，这会非常麻烦。因此mybatisplus提供了很多特殊类型字段的类型处理器，解决特殊字段类型与数据库类型转换的问题。例如处理json就可以使用jacksontypehandler处理器。[链接]①定义实体[图片]代码如下：[代码块][链接]②使用类型处理器将userentity类的info字段修改为userinfo类型，并声明类型处理器：[图片][链接]插件功能mybatisplus提供了很多的插件功能，进一步拓展其功能。目前已有的插件有：paginationinnerinterceptor：自动分页tenantlineinnerinterceptor：多租户dynamictablenameinnerinterceptor：动态表名optimisticlockerinnerinterceptor：乐观锁illegalsqlinnerinterceptor：sql性能规范blockattackinnerinterceptor：防止全表更新与删除注意：使用多个分页插件的时候需要注意插件定义顺序，建议使用顺序如下：多租户,动态表名分页,乐观锁sql性能规范,防止全表更新与删除[链接]ⅰ分页插件在未引入分页插件的情况下，mybatisplus是不支持分页功能的，iservice和basemapper中的分页方法都无法正常起效。所以，我们必须配置分页插件。[链接]①配置分页插件在config下配置分页插件[图片]代码如下：[代码块][链接]②分页api[代码块][图片]这里用到了分页参数，page，即可以支持分页参数，也可以支持排序参数。常见的api如下：[代码块][链接]ⅱ通用分页实体现在要实现一个用户分页查询的接口，接口规范如下：参数说明请求方式get请求路径/users/page请求参数[代码块]返回值[代码块]特殊说明如果排序字段为空，默认按照更新时间排序；如果排序字段不为空，则按照排序字段排序。这里需要定义3个实体：userquery：分页查询条件的实体，包含分页、排序参数、过滤条件pagedto：分页结果实体，包含总条数、总页数、当前页数据uservo：用户页面视图实体[链接]①实体userquery：[代码块]pagequery：[代码块]pagequery是前端提交的查询参数，一般包含四个属性：pageno：页码pagesize：每页数据条数sortby：排序字段isasc：是否升序pagedto：[代码块][链接]②开发接口[代码块]]]></content>
        
        
        <categories>
            
            <category> SpringCloud </category>
            
            <category> 开发框架 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> MybatisPlus </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>VsCode下载安装</title>
        <link href="/posts/c68db7e6.html"/>
        <url>/posts/c68db7e6.html</url>
        <cover>https://file.psd.cn/20211216A/l2g0lriaknq_PSD_cn.jpg</cover>
        <date>Mon Sep 09 2024 11:27:27 GMT+0800</date>
        
        <content type="html"><![CDATA[[链接]图片]]></content>
        
        
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> VsCode </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>Idea下载安装</title>
        <link href="/posts/97a0a1c6.html"/>
        <url>/posts/97a0a1c6.html</url>
        <cover>https://tse1-mm.cn.bing.net/th/id/OIP-C.YD64LaQFsNmslsvpQbzuQgHaD0?rs=1&amp;pid=ImgDetMain</cover>
        <date>Mon Sep 09 2024 11:20:02 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片][链接]idea的下载①打开浏览器，访问idea官网链接：[链接]，如下图所示：[图片]②点击developertools后选择[链接]进入idea下载界面：[图片]③点击download后选择所处环境的idea进行download下载[图片][图片][链接]idea的安装①双击运行下载好的idea安装程序②除了选择文件安装位置，其余一律默认即可[图片][链接]idea插件[链接]①文档快速生成插件[图片][链接]②显示代码缩略图插件[图片][链接]③代码快速生成插件[图片][链接]④代码提交信息规范插件[图片][链接]⑤mybatis框架插件[图片][链接]⑥彩虹括号插件[图片][链接]⑦类注释呈现插件[图片][链接]⑧通义智能ai插件[图片][链接]⑨阿里巴巴规约插件[图片]]]></content>
        
        
        <categories>
            
            <category> 工具 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> IDEA </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>安装Docker</title>
        <link href="/posts/f5f9fa9b.html"/>
        <url>/posts/f5f9fa9b.html</url>
        <cover>https://pic.imgdb.cn/item/64c0ad651ddac507cc99ceb7.jpg</cover>
        <date>Tue Sep 03 2024 09:10:27 GMT+0800</date>
        
        <content type="html"><![CDATA[[图片][链接]1.卸载旧版首先如果系统中已存在旧的docker，则先卸载：[代码块][链接]2.配置docker的yum库首先要安装一个yum工具[代码块]安装成功后，执行命令，配置docker的yum源[代码块]更新yum建立缓存[代码块][链接]3.安装docker执行命令，安装docker[代码块][链接]4.启动和校验[代码块][链接]5.配置镜像加速[代码块]]]></content>
        
        
        <categories>
            
            <category> SpringCloud </category>
            
            <category> 环境搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    
    
    <entry>
        <title>Hello World</title>
        <link href="/posts/4a17b156.html"/>
        <url>/posts/4a17b156.html</url>
        <cover>https://img1.baidu.com/it/u=3093179843,731129673&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=952&amp;h=500</cover>
        <date>Mon Sep 02 2024 22:00:22 GMT+0800</date>
        
        <content type="html"><![CDATA[welcometo[链接]!thisisyourveryfirstpost.check[链接]formoreinfo.ifyougetanyproblemswhenusinghexo,youcanfindtheanswerin[链接]oryoucanaskmeon[链接].[链接]quickstart[链接]createanewpost[代码块]moreinfo:[链接][链接]runserver[代码块]moreinfo:[链接][链接]generatestaticfiles[代码块]moreinfo:[链接][链接]deploytoremotesites[代码块]moreinfo:[链接][链接]图片[图片]]]></content>
        
        
        
    </entry>
    
    
    
    
</search>